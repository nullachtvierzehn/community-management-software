/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
import gql from 'graphql-tag';
import * as Urql from '@urql/vue';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: { input: string; output: string; }
  /** Represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { input: any; output: any; }
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) and, if it has a timezone, [RFC
   * 3339](https://datatracker.ietf.org/doc/html/rfc3339) standards. Input values
   * that do not conform to both ISO 8601 and RFC 3339 may be coerced, which may lead
   * to unexpected results.
   */
  Datetime: { input: string; output: string; }
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: { input: any; output: any; }
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /** Get a single `ActiveMessageRevision`. */
  activeMessageRevision: Maybe<ActiveMessageRevision>;
  /** Reads a single `ActiveMessageRevision` using its globally unique `ID`. */
  activeMessageRevisionByNodeId: Maybe<ActiveMessageRevision>;
  /** Reads and enables pagination through a set of `ActiveMessageRevision`. */
  activeMessageRevisions: Maybe<ActiveMessageRevisionsConnection>;
  /** Get a single `CurrentMessageRevision`. */
  currentMessageRevision: Maybe<CurrentMessageRevision>;
  /** Reads a single `CurrentMessageRevision` using its globally unique `ID`. */
  currentMessageRevisionByNodeId: Maybe<CurrentMessageRevision>;
  /** Reads and enables pagination through a set of `CurrentMessageRevision`. */
  currentMessageRevisions: Maybe<CurrentMessageRevisionsConnection>;
  /** Handy method to get the current session ID. */
  currentSessionId: Maybe<Scalars['UUID']['output']>;
  /** The currently logged in user (or null if not logged in). */
  currentUser: Maybe<User>;
  currentUserFirstMemberOrganizationId: Maybe<Scalars['UUID']['output']>;
  /** Handy method to get the current user ID for use in RLS policies, etc; in GraphQL, use `currentUser{id}` instead. */
  currentUserId: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `Uuid`. */
  currentUserInvitedOrganizationIds: Maybe<CurrentUserInvitedOrganizationIdsConnection>;
  /** Reads and enables pagination through a set of `Uuid`. */
  currentUserMemberOrganizationIds: Maybe<CurrentUserMemberOrganizationIdsConnection>;
  /** Get a single `FileRevision`. */
  fileRevision: Maybe<FileRevision>;
  /** Reads a single `FileRevision` using its globally unique `ID`. */
  fileRevisionByNodeId: Maybe<FileRevision>;
  /** Get a single `FileRevision`. */
  fileRevisionByRevisionId: Maybe<FileRevision>;
  /** Reads and enables pagination through a set of `FileRevision`. */
  fileRevisions: Maybe<FileRevisionsConnection>;
  /** Get a single `MessageRevision`. */
  messageRevision: Maybe<MessageRevision>;
  /** Reads a single `MessageRevision` using its globally unique `ID`. */
  messageRevisionByNodeId: Maybe<MessageRevision>;
  /** Get a single `MessageRevision`. */
  messageRevisionByRevisionId: Maybe<MessageRevision>;
  /** Reads and enables pagination through a set of `MessageRevision`. */
  messageRevisions: Maybe<MessageRevisionsConnection>;
  /** Reads and enables pagination through a set of `Uuid`. */
  myOrganizationIds: Maybe<MyOrganizationIdsConnection>;
  /** Reads and enables pagination through a set of `Uuid`. */
  mySpaceIds: Maybe<MySpaceIdsConnection>;
  /** Reads and enables pagination through a set of `Uuid`. */
  mySpaceSubscriptionIds: Maybe<MySpaceSubscriptionIdsConnection>;
  /** Fetches an object given its globally unique `ID`. */
  node: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']['output'];
  /** Get a single `Organization`. */
  organization: Maybe<Organization>;
  /** Reads a single `Organization` using its globally unique `ID`. */
  organizationByNodeId: Maybe<Organization>;
  /** Get a single `Organization`. */
  organizationBySlug: Maybe<Organization>;
  organizationForInvitation: Maybe<Organization>;
  /** Get a single `OrganizationMembership`. */
  organizationMembership: Maybe<OrganizationMembership>;
  /** Reads a single `OrganizationMembership` using its globally unique `ID`. */
  organizationMembershipByNodeId: Maybe<OrganizationMembership>;
  /** Get a single `OrganizationMembership`. */
  organizationMembershipByOrganizationIdAndUserId: Maybe<OrganizationMembership>;
  /** Reads and enables pagination through a set of `OrganizationMembership`. */
  organizationMemberships: Maybe<OrganizationMembershipsConnection>;
  /** Reads and enables pagination through a set of `Organization`. */
  organizations: Maybe<OrganizationsConnection>;
  /** Get a single `PdfFileRevision`. */
  pdfFileRevision: Maybe<PdfFileRevision>;
  /** Reads a single `PdfFileRevision` using its globally unique `ID`. */
  pdfFileRevisionByNodeId: Maybe<PdfFileRevision>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** Get a single `Space`. */
  space: Maybe<Space>;
  /** Reads a single `Space` using its globally unique `ID`. */
  spaceByNodeId: Maybe<Space>;
  /** Get a single `Space`. */
  spaceByOrganizationIdAndSlug: Maybe<Space>;
  /** Get a single `SpaceItem`. */
  spaceItem: Maybe<SpaceItem>;
  /** Reads a single `SpaceItem` using its globally unique `ID`. */
  spaceItemByNodeId: Maybe<SpaceItem>;
  /** Reads and enables pagination through a set of `SpaceItem`. */
  spaceItems: Maybe<SpaceItemsConnection>;
  /** Get a single `SpaceItemSubmissionAndApprovalTime`. */
  spaceItemSubmissionAndApprovalTime: Maybe<SpaceItemSubmissionAndApprovalTime>;
  /** Reads a single `SpaceItemSubmissionAndApprovalTime` using its globally unique `ID`. */
  spaceItemSubmissionAndApprovalTimeByNodeId: Maybe<SpaceItemSubmissionAndApprovalTime>;
  /** Reads and enables pagination through a set of `Space`. */
  spaces: Maybe<SpacesConnection>;
  /** Get a single `SpaceSubmission`. */
  spaceSubmission: Maybe<SpaceSubmission>;
  /** Reads a single `SpaceSubmission` using its globally unique `ID`. */
  spaceSubmissionByNodeId: Maybe<SpaceSubmission>;
  /** Get a single `SpaceSubmissionReview`. */
  spaceSubmissionReview: Maybe<SpaceSubmissionReview>;
  /** Reads a single `SpaceSubmissionReview` using its globally unique `ID`. */
  spaceSubmissionReviewByNodeId: Maybe<SpaceSubmissionReview>;
  /** Reads and enables pagination through a set of `SpaceSubmissionReview`. */
  spaceSubmissionReviews: Maybe<SpaceSubmissionReviewsConnection>;
  /** Reads and enables pagination through a set of `SpaceSubmission`. */
  spaceSubmissions: Maybe<SpaceSubmissionsConnection>;
  /** Get a single `SpaceSubscription`. */
  spaceSubscription: Maybe<SpaceSubscription>;
  /** Reads a single `SpaceSubscription` using its globally unique `ID`. */
  spaceSubscriptionByNodeId: Maybe<SpaceSubscription>;
  /** Get a single `SpaceSubscription`. */
  spaceSubscriptionBySubscriberIdAndSpaceId: Maybe<SpaceSubscription>;
  /** Reads and enables pagination through a set of `SpaceSubscription`. */
  spaceSubscriptions: Maybe<SpaceSubscriptionsConnection>;
  /** Get a single `User`. */
  user: Maybe<User>;
  /** Get a single `UserAuthentication`. */
  userAuthentication: Maybe<UserAuthentication>;
  /** Reads a single `UserAuthentication` using its globally unique `ID`. */
  userAuthenticationByNodeId: Maybe<UserAuthentication>;
  /** Get a single `UserAuthentication`. */
  userAuthenticationByServiceAndIdentifier: Maybe<UserAuthentication>;
  /** Reads and enables pagination through a set of `UserAuthentication`. */
  userAuthentications: Maybe<UserAuthenticationsConnection>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId: Maybe<User>;
  /** Get a single `User`. */
  userByUsername: Maybe<User>;
  /** Get a single `UserEmail`. */
  userEmail: Maybe<UserEmail>;
  /** Reads a single `UserEmail` using its globally unique `ID`. */
  userEmailByNodeId: Maybe<UserEmail>;
  /** Get a single `UserEmail`. */
  userEmailByUserIdAndEmail: Maybe<UserEmail>;
  /** Reads and enables pagination through a set of `UserEmail`. */
  userEmails: Maybe<UserEmailsConnection>;
  /** Reads and enables pagination through a set of `User`. */
  users: Maybe<UsersConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActiveMessageRevisionArgs = {
  id: Scalars['UUID']['input'];
  revisionId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActiveMessageRevisionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActiveMessageRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActiveMessageRevisionCondition>;
  filter?: InputMaybe<ActiveMessageRevisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActiveMessageRevisionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentMessageRevisionArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentMessageRevisionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentMessageRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CurrentMessageRevisionCondition>;
  filter?: InputMaybe<CurrentMessageRevisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CurrentMessageRevisionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentUserInvitedOrganizationIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<UuidFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentUserMemberOrganizationIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<UuidFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFileRevisionArgs = {
  id: Scalars['UUID']['input'];
  revisionId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFileRevisionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFileRevisionByRevisionIdArgs = {
  revisionId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFileRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileRevisionCondition>;
  filter?: InputMaybe<FileRevisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FileRevisionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageRevisionArgs = {
  id: Scalars['UUID']['input'];
  revisionId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageRevisionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageRevisionByRevisionIdArgs = {
  revisionId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageRevisionCondition>;
  filter?: InputMaybe<MessageRevisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageRevisionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMyOrganizationIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<UuidFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  withAllAbilities?: InputMaybe<Array<InputMaybe<Ability>>>;
  withAnyAbilities?: InputMaybe<Array<InputMaybe<Ability>>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMySpaceIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<UuidFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  withAllAbilities?: InputMaybe<Array<InputMaybe<Ability>>>;
  withAnyAbilities?: InputMaybe<Array<InputMaybe<Ability>>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMySpaceSubscriptionIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<UuidFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationBySlugArgs = {
  slug: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationForInvitationArgs = {
  code?: InputMaybe<Scalars['String']['input']>;
  invitationId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationMembershipArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationMembershipByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationMembershipByOrganizationIdAndUserIdArgs = {
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationMembershipsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationMembershipCondition>;
  filter?: InputMaybe<OrganizationMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationMembershipsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPdfFileRevisionArgs = {
  id: Scalars['UUID']['input'];
  revisionId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPdfFileRevisionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceByOrganizationIdAndSlugArgs = {
  organizationId: Scalars['UUID']['input'];
  slug: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceItemArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceItemByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceItemCondition>;
  filter?: InputMaybe<SpaceItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceItemSubmissionAndApprovalTimeArgs = {
  spaceItemId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceItemSubmissionAndApprovalTimeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpacesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceCondition>;
  filter?: InputMaybe<SpaceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpacesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceSubmissionArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceSubmissionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceSubmissionReviewArgs = {
  spaceSubmissionId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceSubmissionReviewByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceSubmissionReviewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceSubmissionReviewCondition>;
  filter?: InputMaybe<SpaceSubmissionReviewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceSubmissionReviewsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceSubmissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceSubmissionCondition>;
  filter?: InputMaybe<SpaceSubmissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceSubmissionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceSubscriptionArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceSubscriptionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceSubscriptionBySubscriberIdAndSpaceIdArgs = {
  spaceId: Scalars['UUID']['input'];
  subscriberId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpaceSubscriptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceSubscriptionCondition>;
  filter?: InputMaybe<SpaceSubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceSubscriptionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationByServiceAndIdentifierArgs = {
  identifier: Scalars['String']['input'];
  service: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserAuthenticationCondition>;
  filter?: InputMaybe<UserAuthenticationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserAuthenticationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByUsernameArgs = {
  username: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserEmailArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserEmailByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserEmailByUserIdAndEmailArgs = {
  email: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserEmailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserEmailCondition>;
  filter?: InputMaybe<UserEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type ActiveMessageRevision = Node & {
  __typename?: 'ActiveMessageRevision';
  body: Maybe<Scalars['JSON']['output']>;
  createdAt: Maybe<Scalars['Datetime']['output']>;
  editorId: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parentRevisionId: Maybe<Scalars['UUID']['output']>;
  revisionId: Scalars['UUID']['output'];
  subject: Maybe<Scalars['String']['output']>;
  updateComment: Maybe<Scalars['String']['output']>;
  updatedAt: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `ActiveMessageRevision` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ActiveMessageRevisionCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `editorId` field. */
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `parentRevisionId` field. */
  parentRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updateComment` field. */
  updateComment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `ActiveMessageRevision` object types. All fields are combined with a logical ‘and.’ */
export type ActiveMessageRevisionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ActiveMessageRevisionFilter>>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `editorId` field. */
  editorId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ActiveMessageRevisionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ActiveMessageRevisionFilter>>;
  /** Filter by the object’s `parentRevisionId` field. */
  parentRevisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `subject` field. */
  subject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updateComment` field. */
  updateComment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Contained by the specified JSON. */
  containedBy?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains the specified JSON. */
  contains?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified key. */
  containsKey?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['JSON']['input']>>;
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']['input']>>;
};

/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['UUID']['input']>>;
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
};

/** Methods to use when ordering `ActiveMessageRevision`. */
export type ActiveMessageRevisionsOrderBy =
  | 'BODY_ASC'
  | 'BODY_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'EDITOR_ID_ASC'
  | 'EDITOR_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PARENT_REVISION_ID_ASC'
  | 'PARENT_REVISION_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REVISION_ID_ASC'
  | 'REVISION_ID_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'UPDATE_COMMENT_ASC'
  | 'UPDATE_COMMENT_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `ActiveMessageRevision` values. */
export type ActiveMessageRevisionsConnection = {
  __typename?: 'ActiveMessageRevisionsConnection';
  /** A list of edges which contains the `ActiveMessageRevision` and cursor to aid in pagination. */
  edges: Array<ActiveMessageRevisionsEdge>;
  /** A list of `ActiveMessageRevision` objects. */
  nodes: Array<ActiveMessageRevision>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ActiveMessageRevision` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ActiveMessageRevision` edge in the connection. */
export type ActiveMessageRevisionsEdge = {
  __typename?: 'ActiveMessageRevisionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `ActiveMessageRevision` at the end of the edge. */
  node: ActiveMessageRevision;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']['output']>;
};

export type CurrentMessageRevision = Node & {
  __typename?: 'CurrentMessageRevision';
  body: Maybe<Scalars['JSON']['output']>;
  createdAt: Maybe<Scalars['Datetime']['output']>;
  editorId: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parentRevisionId: Maybe<Scalars['UUID']['output']>;
  revisionId: Maybe<Scalars['UUID']['output']>;
  subject: Maybe<Scalars['String']['output']>;
  updateComment: Maybe<Scalars['String']['output']>;
  updatedAt: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `CurrentMessageRevision` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type CurrentMessageRevisionCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `editorId` field. */
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `parentRevisionId` field. */
  parentRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updateComment` field. */
  updateComment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `CurrentMessageRevision` object types. All fields are combined with a logical ‘and.’ */
export type CurrentMessageRevisionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CurrentMessageRevisionFilter>>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `editorId` field. */
  editorId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CurrentMessageRevisionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CurrentMessageRevisionFilter>>;
  /** Filter by the object’s `parentRevisionId` field. */
  parentRevisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `subject` field. */
  subject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updateComment` field. */
  updateComment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** Methods to use when ordering `CurrentMessageRevision`. */
export type CurrentMessageRevisionsOrderBy =
  | 'BODY_ASC'
  | 'BODY_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'EDITOR_ID_ASC'
  | 'EDITOR_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PARENT_REVISION_ID_ASC'
  | 'PARENT_REVISION_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REVISION_ID_ASC'
  | 'REVISION_ID_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'UPDATE_COMMENT_ASC'
  | 'UPDATE_COMMENT_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `CurrentMessageRevision` values. */
export type CurrentMessageRevisionsConnection = {
  __typename?: 'CurrentMessageRevisionsConnection';
  /** A list of edges which contains the `CurrentMessageRevision` and cursor to aid in pagination. */
  edges: Array<CurrentMessageRevisionsEdge>;
  /** A list of `CurrentMessageRevision` objects. */
  nodes: Array<CurrentMessageRevision>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CurrentMessageRevision` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CurrentMessageRevision` edge in the connection. */
export type CurrentMessageRevisionsEdge = {
  __typename?: 'CurrentMessageRevisionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `CurrentMessageRevision` at the end of the edge. */
  node: CurrentMessageRevision;
};

/** A user who can log in to the application. */
export type User = Node & {
  __typename?: 'User';
  /** Optional avatar URL. */
  avatarUrl: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `FileRevision`. */
  editedFileRevisions: FileRevisionsConnection;
  /** Reads and enables pagination through a set of `MessageRevision`. */
  editedMessageRevisions: MessageRevisionsConnection;
  /** Reads and enables pagination through a set of `SpaceItem`. */
  editedSpaceItems: SpaceItemsConnection;
  hasPassword: Maybe<Scalars['Boolean']['output']>;
  /** Unique identifier for the user. */
  id: Scalars['UUID']['output'];
  /** If true, the user has elevated privileges. */
  isAdmin: Scalars['Boolean']['output'];
  isVerified: Scalars['Boolean']['output'];
  /** Public-facing name (or pseudonym) of the user. */
  name: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `OrganizationMembership`. */
  organizationMemberships: OrganizationMembershipsConnection;
  /** Reads and enables pagination through a set of `SpaceSubmissionReview`. */
  reviewedSpaceSubmissionReviews: SpaceSubmissionReviewsConnection;
  /** Reads and enables pagination through a set of `Space`. */
  spacesByCreatorId: SpacesConnection;
  /** Reads and enables pagination through a set of `SpaceSubmission`. */
  spaceSubmissionsBySubmitterId: SpaceSubmissionsConnection;
  /** Reads and enables pagination through a set of `SpaceSubscription`. */
  spaceSubscriptionsBySubscriberId: SpaceSubscriptionsConnection;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `UserAuthentication`. */
  userAuthentications: UserAuthenticationsConnection;
  /** Reads and enables pagination through a set of `UserEmail`. */
  userEmails: UserEmailsConnection;
  /** Public-facing username (or 'handle') of the user. */
  username: Scalars['String']['output'];
};


/** A user who can log in to the application. */
export type UserEditedFileRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileRevisionCondition>;
  filter?: InputMaybe<FileRevisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FileRevisionsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserEditedMessageRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageRevisionCondition>;
  filter?: InputMaybe<MessageRevisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageRevisionsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserEditedSpaceItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceItemCondition>;
  filter?: InputMaybe<SpaceItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceItemsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserOrganizationMembershipsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationMembershipCondition>;
  filter?: InputMaybe<OrganizationMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationMembershipsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserReviewedSpaceSubmissionReviewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceSubmissionReviewCondition>;
  filter?: InputMaybe<SpaceSubmissionReviewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceSubmissionReviewsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserSpacesByCreatorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceCondition>;
  filter?: InputMaybe<SpaceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpacesOrderBy>>;
};


/** A user who can log in to the application. */
export type UserSpaceSubmissionsBySubmitterIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceSubmissionCondition>;
  filter?: InputMaybe<SpaceSubmissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceSubmissionsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserSpaceSubscriptionsBySubscriberIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceSubscriptionCondition>;
  filter?: InputMaybe<SpaceSubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceSubscriptionsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserUserAuthenticationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserAuthenticationCondition>;
  filter?: InputMaybe<UserAuthenticationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserAuthenticationsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserUserEmailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserEmailCondition>;
  filter?: InputMaybe<UserEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailsOrderBy>>;
};

/**
 * A condition to be used against `FileRevision` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FileRevisionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `editorId` field. */
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `filename` field. */
  filename?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `mimeType` field. */
  mimeType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `parentRevisionId` field. */
  parentRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `pathOnStorage` field. */
  pathOnStorage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `sha256` field. */
  sha256?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `totalBytes` field. */
  totalBytes?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `updateComment` field. */
  updateComment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uploadedBytes` field. */
  uploadedBytes?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FileRevision` object types. All fields are combined with a logical ‘and.’ */
export type FileRevisionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FileRevisionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `editor` relation. */
  editor?: InputMaybe<UserFilter>;
  /** A related `editor` exists. */
  editorExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `editorId` field. */
  editorId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `filename` field. */
  filename?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fileRevision` relation. */
  fileRevision?: InputMaybe<FileRevisionFilter>;
  /** A related `fileRevision` exists. */
  fileRevisionExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `fileRevisionsByIdAndParentRevisionId` relation. */
  fileRevisionsByIdAndParentRevisionId?: InputMaybe<FileRevisionToManyFileRevisionFilter>;
  /** Some related `fileRevisionsByIdAndParentRevisionId` exist. */
  fileRevisionsByIdAndParentRevisionIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `mimeType` field. */
  mimeType?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FileRevisionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FileRevisionFilter>>;
  /** Filter by the object’s `parentRevisionId` field. */
  parentRevisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `pathOnStorage` field. */
  pathOnStorage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pdfFileRevision` relation. */
  pdfFileRevision?: InputMaybe<PdfFileRevisionFilter>;
  /** A related `pdfFileRevision` exists. */
  pdfFileRevisionExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `pdfFileRevisionsByThumbnailIdAndThumbnailRevisionId` relation. */
  pdfFileRevisionsByThumbnailIdAndThumbnailRevisionId?: InputMaybe<FileRevisionToManyPdfFileRevisionFilter>;
  /** Some related `pdfFileRevisionsByThumbnailIdAndThumbnailRevisionId` exist. */
  pdfFileRevisionsByThumbnailIdAndThumbnailRevisionIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `sha256` field. */
  sha256?: InputMaybe<StringFilter>;
  /** Filter by the object’s `spaceItems` relation. */
  spaceItems?: InputMaybe<FileRevisionToManySpaceItemFilter>;
  /** Some related `spaceItems` exist. */
  spaceItemsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `spaceSubmissions` relation. */
  spaceSubmissions?: InputMaybe<FileRevisionToManySpaceSubmissionFilter>;
  /** Some related `spaceSubmissions` exist. */
  spaceSubmissionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `totalBytes` field. */
  totalBytes?: InputMaybe<IntFilter>;
  /** Filter by the object’s `updateComment` field. */
  updateComment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uploadedBytes` field. */
  uploadedBytes?: InputMaybe<IntFilter>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `avatarUrl` field. */
  avatarUrl?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `editedFileRevisions` relation. */
  editedFileRevisions?: InputMaybe<UserToManyFileRevisionFilter>;
  /** Some related `editedFileRevisions` exist. */
  editedFileRevisionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `editedMessageRevisions` relation. */
  editedMessageRevisions?: InputMaybe<UserToManyMessageRevisionFilter>;
  /** Some related `editedMessageRevisions` exist. */
  editedMessageRevisionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `editedSpaceItems` relation. */
  editedSpaceItems?: InputMaybe<UserToManySpaceItemFilter>;
  /** Some related `editedSpaceItems` exist. */
  editedSpaceItemsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `hasPassword` field. */
  hasPassword?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isVerified` field. */
  isVerified?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `organizationMemberships` relation. */
  organizationMemberships?: InputMaybe<UserToManyOrganizationMembershipFilter>;
  /** Some related `organizationMemberships` exist. */
  organizationMembershipsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewedSpaceSubmissionReviews` relation. */
  reviewedSpaceSubmissionReviews?: InputMaybe<UserToManySpaceSubmissionReviewFilter>;
  /** Some related `reviewedSpaceSubmissionReviews` exist. */
  reviewedSpaceSubmissionReviewsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `spacesByCreatorId` relation. */
  spacesByCreatorId?: InputMaybe<UserToManySpaceFilter>;
  /** Some related `spacesByCreatorId` exist. */
  spacesByCreatorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `spaceSubmissionsBySubmitterId` relation. */
  spaceSubmissionsBySubmitterId?: InputMaybe<UserToManySpaceSubmissionFilter>;
  /** Some related `spaceSubmissionsBySubmitterId` exist. */
  spaceSubmissionsBySubmitterIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `spaceSubscriptionsBySubscriberId` relation. */
  spaceSubscriptionsBySubscriberId?: InputMaybe<UserToManySpaceSubscriptionFilter>;
  /** Some related `spaceSubscriptionsBySubscriberId` exist. */
  spaceSubscriptionsBySubscriberIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userAuthentications` relation. */
  userAuthentications?: InputMaybe<UserToManyUserAuthenticationFilter>;
  /** Some related `userAuthentications` exist. */
  userAuthenticationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userEmails` relation. */
  userEmails?: InputMaybe<UserToManyUserEmailFilter>;
  /** Some related `userEmails` exist. */
  userEmailsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
};

/** A filter to be used against many `FileRevision` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyFileRevisionFilter = {
  /** Every related `FileRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileRevisionFilter>;
  /** No related `FileRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileRevisionFilter>;
  /** Some related `FileRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileRevisionFilter>;
};

/** A filter to be used against many `MessageRevision` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyMessageRevisionFilter = {
  /** Every related `MessageRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageRevisionFilter>;
  /** No related `MessageRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageRevisionFilter>;
  /** Some related `MessageRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageRevisionFilter>;
};

/** A filter to be used against `MessageRevision` object types. All fields are combined with a logical ‘and.’ */
export type MessageRevisionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MessageRevisionFilter>>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `childRevisions` relation. */
  childRevisions?: InputMaybe<MessageRevisionToManyMessageRevisionFilter>;
  /** Some related `childRevisions` exist. */
  childRevisionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `editor` relation. */
  editor?: InputMaybe<UserFilter>;
  /** A related `editor` exists. */
  editorExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `editorId` field. */
  editorId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MessageRevisionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MessageRevisionFilter>>;
  /** Filter by the object’s `parentRevision` relation. */
  parentRevision?: InputMaybe<MessageRevisionFilter>;
  /** A related `parentRevision` exists. */
  parentRevisionExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `parentRevisionId` field. */
  parentRevisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `spaceItems` relation. */
  spaceItems?: InputMaybe<MessageRevisionToManySpaceItemFilter>;
  /** Some related `spaceItems` exist. */
  spaceItemsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `spaceSubmissions` relation. */
  spaceSubmissions?: InputMaybe<MessageRevisionToManySpaceSubmissionFilter>;
  /** Some related `spaceSubmissions` exist. */
  spaceSubmissionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `subject` field. */
  subject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updateComment` field. */
  updateComment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against many `MessageRevision` object types. All fields are combined with a logical ‘and.’ */
export type MessageRevisionToManyMessageRevisionFilter = {
  /** Every related `MessageRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageRevisionFilter>;
  /** No related `MessageRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageRevisionFilter>;
  /** Some related `MessageRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageRevisionFilter>;
};

/** A filter to be used against many `SpaceItem` object types. All fields are combined with a logical ‘and.’ */
export type MessageRevisionToManySpaceItemFilter = {
  /** Every related `SpaceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceItemFilter>;
  /** No related `SpaceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceItemFilter>;
  /** Some related `SpaceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceItemFilter>;
};

/** A filter to be used against `SpaceItem` object types. All fields are combined with a logical ‘and.’ */
export type SpaceItemFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SpaceItemFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `editor` relation. */
  editor?: InputMaybe<UserFilter>;
  /** A related `editor` exists. */
  editorExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `editorId` field. */
  editorId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `fileId` field. */
  fileId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `fileRevision` relation. */
  fileRevision?: InputMaybe<FileRevisionFilter>;
  /** A related `fileRevision` exists. */
  fileRevisionExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isReviewed` field. */
  isReviewed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isSubmitted` field. */
  isSubmitted?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `latestReviewResult` field. */
  latestReviewResult?: InputMaybe<ReviewResultFilter>;
  /** Filter by the object’s `messageId` field. */
  messageId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `messageRevision` relation. */
  messageRevision?: InputMaybe<MessageRevisionFilter>;
  /** A related `messageRevision` exists. */
  messageRevisionExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<SpaceItemFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SpaceItemFilter>>;
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `space` relation. */
  space?: InputMaybe<SpaceFilter>;
  /** Filter by the object’s `spaceId` field. */
  spaceId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `submissions` relation. */
  submissions?: InputMaybe<SpaceItemToManySpaceSubmissionFilter>;
  /** Some related `submissions` exist. */
  submissionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `times` relation. */
  times?: InputMaybe<SpaceItemSubmissionAndApprovalTimeFilter>;
  /** A related `times` exists. */
  timesExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

/** A filter to be used against ReviewResult fields. All fields are combined with a logical ‘and.’ */
export type ReviewResultFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewResult>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewResult>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewResult>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewResult>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewResult>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewResult>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewResult>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewResult>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewResult>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewResult>>;
};

export type ReviewResult =
  | 'APPROVED'
  | 'COMMENTED'
  | 'DECLINED';

/** A filter to be used against `Space` object types. All fields are combined with a logical ‘and.’ */
export type SpaceFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SpaceFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `creator` relation. */
  creator?: InputMaybe<UserFilter>;
  /** A related `creator` exists. */
  creatorExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `creatorId` field. */
  creatorId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isPublic` field. */
  isPublic?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `items` relation. */
  items?: InputMaybe<SpaceToManySpaceItemFilter>;
  /** Some related `items` exist. */
  itemsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SpaceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SpaceFilter>>;
  /** Filter by the object’s `organization` relation. */
  organization?: InputMaybe<OrganizationFilter>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `slug` field. */
  slug?: InputMaybe<StringFilter>;
  /** Filter by the object’s `spaceItemSubmissionAndApprovalTimes` relation. */
  spaceItemSubmissionAndApprovalTimes?: InputMaybe<SpaceToManySpaceItemSubmissionAndApprovalTimeFilter>;
  /** Some related `spaceItemSubmissionAndApprovalTimes` exist. */
  spaceItemSubmissionAndApprovalTimesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `subscriptions` relation. */
  subscriptions?: InputMaybe<SpaceToManySpaceSubscriptionFilter>;
  /** Some related `subscriptions` exist. */
  subscriptionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against many `SpaceItem` object types. All fields are combined with a logical ‘and.’ */
export type SpaceToManySpaceItemFilter = {
  /** Every related `SpaceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceItemFilter>;
  /** No related `SpaceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceItemFilter>;
  /** Some related `SpaceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceItemFilter>;
};

/** A filter to be used against `Organization` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganizationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currentUserIsBillingContact` field. */
  currentUserIsBillingContact?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `currentUserIsOwner` field. */
  currentUserIsOwner?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `memberAbilities` field. */
  memberAbilities?: InputMaybe<AbilityListFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganizationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganizationFilter>>;
  /** Filter by the object’s `organizationMemberships` relation. */
  organizationMemberships?: InputMaybe<OrganizationToManyOrganizationMembershipFilter>;
  /** Some related `organizationMemberships` exist. */
  organizationMembershipsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `ownerAbilities` field. */
  ownerAbilities?: InputMaybe<AbilityListFilter>;
  /** Filter by the object’s `slug` field. */
  slug?: InputMaybe<StringFilter>;
  /** Filter by the object’s `spaceCreatorAbilities` field. */
  spaceCreatorAbilities?: InputMaybe<AbilityListFilter>;
  /** Filter by the object’s `spaceItemSubmissionAndApprovalTimes` relation. */
  spaceItemSubmissionAndApprovalTimes?: InputMaybe<OrganizationToManySpaceItemSubmissionAndApprovalTimeFilter>;
  /** Some related `spaceItemSubmissionAndApprovalTimes` exist. */
  spaceItemSubmissionAndApprovalTimesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `spaces` relation. */
  spaces?: InputMaybe<OrganizationToManySpaceFilter>;
  /** Some related `spaces` exist. */
  spacesExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A filter to be used against Ability List fields. All fields are combined with a logical ‘and.’ */
export type AbilityListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<Ability>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<Ability>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<Ability>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<Ability>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<Ability>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<Ability>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<Ability>>>;
};

export type Ability =
  | 'ACCEPT'
  | 'ACCEPT_FILE'
  | 'ACCEPT_MESSAGE'
  | 'CREATE'
  | 'CREATE_FILE'
  | 'CREATE_MESSAGE'
  | 'CREATE_SPACE'
  | 'DELETE'
  | 'DELETE_FILE'
  | 'DELETE_MESSAGE'
  | 'DELETE_SPACE'
  | 'GRANT'
  | 'GRANT_ABILITY'
  | 'MANAGE'
  | 'SUBMIT'
  | 'SUBMIT_FILE'
  | 'SUBMIT_MESSAGE'
  | 'UPDATE'
  | 'UPDATE_FILE'
  | 'UPDATE_MESSAGE'
  | 'UPDATE_SPACE'
  | 'VIEW';

/** A filter to be used against many `OrganizationMembership` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationToManyOrganizationMembershipFilter = {
  /** Every related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OrganizationMembershipFilter>;
  /** No related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OrganizationMembershipFilter>;
  /** Some related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OrganizationMembershipFilter>;
};

/** A filter to be used against `OrganizationMembership` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationMembershipFilter = {
  /** Filter by the object’s `abilities` field. */
  abilities?: InputMaybe<AbilityListFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganizationMembershipFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isBillingContact` field. */
  isBillingContact?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isOwner` field. */
  isOwner?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganizationMembershipFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganizationMembershipFilter>>;
  /** Filter by the object’s `organization` relation. */
  organization?: InputMaybe<OrganizationFilter>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** A filter to be used against many `SpaceItemSubmissionAndApprovalTime` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationToManySpaceItemSubmissionAndApprovalTimeFilter = {
  /** Every related `SpaceItemSubmissionAndApprovalTime` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceItemSubmissionAndApprovalTimeFilter>;
  /** No related `SpaceItemSubmissionAndApprovalTime` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceItemSubmissionAndApprovalTimeFilter>;
  /** Some related `SpaceItemSubmissionAndApprovalTime` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceItemSubmissionAndApprovalTimeFilter>;
};

/** A filter to be used against `SpaceItemSubmissionAndApprovalTime` object types. All fields are combined with a logical ‘and.’ */
export type SpaceItemSubmissionAndApprovalTimeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SpaceItemSubmissionAndApprovalTimeFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currentApprovalSince` field. */
  currentApprovalSince?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currentSubmissionSince` field. */
  currentSubmissionSince?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `editorId` field. */
  editorId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `firstApprovalAt` field. */
  firstApprovalAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `firstSubmissionAt` field. */
  firstSubmissionAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `item` relation. */
  item?: InputMaybe<SpaceItemFilter>;
  /** Filter by the object’s `lastApprovalAt` field. */
  lastApprovalAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `lastSubmissionAt` field. */
  lastSubmissionAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SpaceItemSubmissionAndApprovalTimeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SpaceItemSubmissionAndApprovalTimeFilter>>;
  /** Filter by the object’s `organization` relation. */
  organization?: InputMaybe<OrganizationFilter>;
  /** A related `organization` exists. */
  organizationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `space` relation. */
  space?: InputMaybe<SpaceFilter>;
  /** A related `space` exists. */
  spaceExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `spaceId` field. */
  spaceId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `spaceItemId` field. */
  spaceItemId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against many `Space` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationToManySpaceFilter = {
  /** Every related `Space` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceFilter>;
  /** No related `Space` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceFilter>;
  /** Some related `Space` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceFilter>;
};

/** A filter to be used against many `SpaceItemSubmissionAndApprovalTime` object types. All fields are combined with a logical ‘and.’ */
export type SpaceToManySpaceItemSubmissionAndApprovalTimeFilter = {
  /** Every related `SpaceItemSubmissionAndApprovalTime` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceItemSubmissionAndApprovalTimeFilter>;
  /** No related `SpaceItemSubmissionAndApprovalTime` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceItemSubmissionAndApprovalTimeFilter>;
  /** Some related `SpaceItemSubmissionAndApprovalTime` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceItemSubmissionAndApprovalTimeFilter>;
};

/** A filter to be used against many `SpaceSubscription` object types. All fields are combined with a logical ‘and.’ */
export type SpaceToManySpaceSubscriptionFilter = {
  /** Every related `SpaceSubscription` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceSubscriptionFilter>;
  /** No related `SpaceSubscription` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceSubscriptionFilter>;
  /** Some related `SpaceSubscription` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceSubscriptionFilter>;
};

/** A filter to be used against `SpaceSubscription` object types. All fields are combined with a logical ‘and.’ */
export type SpaceSubscriptionFilter = {
  /** Filter by the object’s `abilities` field. */
  abilities?: InputMaybe<AbilityListFilter>;
  /** Filter by the object’s `allAbilities` field. */
  allAbilities?: InputMaybe<AbilityListFilter>;
  /** Filter by the object’s `allAbilitiesWithGrantOption` field. */
  allAbilitiesWithGrantOption?: InputMaybe<AbilityListFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SpaceSubscriptionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isReceivingNotifications` field. */
  isReceivingNotifications?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `lastNotificationAt` field. */
  lastNotificationAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `lastVisitAt` field. */
  lastVisitAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SpaceSubscriptionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SpaceSubscriptionFilter>>;
  /** Filter by the object’s `space` relation. */
  space?: InputMaybe<SpaceFilter>;
  /** A related `space` exists. */
  spaceExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `spaceId` field. */
  spaceId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `subscriber` relation. */
  subscriber?: InputMaybe<UserFilter>;
  /** A related `subscriber` exists. */
  subscriberExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `subscriberId` field. */
  subscriberId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against many `SpaceSubmission` object types. All fields are combined with a logical ‘and.’ */
export type SpaceItemToManySpaceSubmissionFilter = {
  /** Every related `SpaceSubmission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceSubmissionFilter>;
  /** No related `SpaceSubmission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceSubmissionFilter>;
  /** Some related `SpaceSubmission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceSubmissionFilter>;
};

/** A filter to be used against `SpaceSubmission` object types. All fields are combined with a logical ‘and.’ */
export type SpaceSubmissionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SpaceSubmissionFilter>>;
  /** Filter by the object’s `fileId` field. */
  fileId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `fileRevision` relation. */
  fileRevision?: InputMaybe<FileRevisionFilter>;
  /** A related `fileRevision` exists. */
  fileRevisionExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `messageId` field. */
  messageId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `messageRevision` relation. */
  messageRevision?: InputMaybe<MessageRevisionFilter>;
  /** A related `messageRevision` exists. */
  messageRevisionExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<SpaceSubmissionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SpaceSubmissionFilter>>;
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `spaceItem` relation. */
  spaceItem?: InputMaybe<SpaceItemFilter>;
  /** Filter by the object’s `spaceItemId` field. */
  spaceItemId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `spaceSubmissionReview` relation. */
  spaceSubmissionReview?: InputMaybe<SpaceSubmissionReviewFilter>;
  /** A related `spaceSubmissionReview` exists. */
  spaceSubmissionReviewExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `submittedAt` field. */
  submittedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `submitter` relation. */
  submitter?: InputMaybe<UserFilter>;
  /** A related `submitter` exists. */
  submitterExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `submitterId` field. */
  submitterId?: InputMaybe<UuidFilter>;
};

/** A filter to be used against `SpaceSubmissionReview` object types. All fields are combined with a logical ‘and.’ */
export type SpaceSubmissionReviewFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SpaceSubmissionReviewFilter>>;
  /** Filter by the object’s `comment` field. */
  comment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SpaceSubmissionReviewFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SpaceSubmissionReviewFilter>>;
  /** Filter by the object’s `result` field. */
  result?: InputMaybe<ReviewResultFilter>;
  /** Filter by the object’s `reviewer` relation. */
  reviewer?: InputMaybe<UserFilter>;
  /** A related `reviewer` exists. */
  reviewerExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewerId` field. */
  reviewerId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `spaceSubmission` relation. */
  spaceSubmission?: InputMaybe<SpaceSubmissionFilter>;
  /** Filter by the object’s `spaceSubmissionId` field. */
  spaceSubmissionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against many `SpaceSubmission` object types. All fields are combined with a logical ‘and.’ */
export type MessageRevisionToManySpaceSubmissionFilter = {
  /** Every related `SpaceSubmission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceSubmissionFilter>;
  /** No related `SpaceSubmission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceSubmissionFilter>;
  /** Some related `SpaceSubmission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceSubmissionFilter>;
};

/** A filter to be used against many `SpaceItem` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySpaceItemFilter = {
  /** Every related `SpaceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceItemFilter>;
  /** No related `SpaceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceItemFilter>;
  /** Some related `SpaceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceItemFilter>;
};

/** A filter to be used against many `OrganizationMembership` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyOrganizationMembershipFilter = {
  /** Every related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OrganizationMembershipFilter>;
  /** No related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OrganizationMembershipFilter>;
  /** Some related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OrganizationMembershipFilter>;
};

/** A filter to be used against many `SpaceSubmissionReview` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySpaceSubmissionReviewFilter = {
  /** Every related `SpaceSubmissionReview` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceSubmissionReviewFilter>;
  /** No related `SpaceSubmissionReview` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceSubmissionReviewFilter>;
  /** Some related `SpaceSubmissionReview` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceSubmissionReviewFilter>;
};

/** A filter to be used against many `Space` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySpaceFilter = {
  /** Every related `Space` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceFilter>;
  /** No related `Space` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceFilter>;
  /** Some related `Space` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceFilter>;
};

/** A filter to be used against many `SpaceSubmission` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySpaceSubmissionFilter = {
  /** Every related `SpaceSubmission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceSubmissionFilter>;
  /** No related `SpaceSubmission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceSubmissionFilter>;
  /** Some related `SpaceSubmission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceSubmissionFilter>;
};

/** A filter to be used against many `SpaceSubscription` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySpaceSubscriptionFilter = {
  /** Every related `SpaceSubscription` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceSubscriptionFilter>;
  /** No related `SpaceSubscription` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceSubscriptionFilter>;
  /** Some related `SpaceSubscription` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceSubscriptionFilter>;
};

/** A filter to be used against many `UserAuthentication` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserAuthenticationFilter = {
  /** Every related `UserAuthentication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserAuthenticationFilter>;
  /** No related `UserAuthentication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserAuthenticationFilter>;
  /** Some related `UserAuthentication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserAuthenticationFilter>;
};

/** A filter to be used against `UserAuthentication` object types. All fields are combined with a logical ‘and.’ */
export type UserAuthenticationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserAuthenticationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `details` field. */
  details?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `identifier` field. */
  identifier?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserAuthenticationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserAuthenticationFilter>>;
  /** Filter by the object’s `service` field. */
  service?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** A filter to be used against many `UserEmail` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserEmailFilter = {
  /** Every related `UserEmail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserEmailFilter>;
  /** No related `UserEmail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserEmailFilter>;
  /** Some related `UserEmail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserEmailFilter>;
};

/** A filter to be used against `UserEmail` object types. All fields are combined with a logical ‘and.’ */
export type UserEmailFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserEmailFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isPrimary` field. */
  isPrimary?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isVerified` field. */
  isVerified?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserEmailFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserEmailFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** A filter to be used against many `FileRevision` object types. All fields are combined with a logical ‘and.’ */
export type FileRevisionToManyFileRevisionFilter = {
  /** Every related `FileRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileRevisionFilter>;
  /** No related `FileRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileRevisionFilter>;
  /** Some related `FileRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileRevisionFilter>;
};

/** A filter to be used against `PdfFileRevision` object types. All fields are combined with a logical ‘and.’ */
export type PdfFileRevisionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PdfFileRevisionFilter>>;
  /** Filter by the object’s `contentAsPlainText` field. */
  contentAsPlainText?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `fileRevision` relation. */
  fileRevision?: InputMaybe<FileRevisionFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `metadata` field. */
  metadata?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PdfFileRevisionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PdfFileRevisionFilter>>;
  /** Filter by the object’s `pages` field. */
  pages?: InputMaybe<IntFilter>;
  /** Filter by the object’s `revisionId` field. */
  revisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `thumbnailId` field. */
  thumbnailId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `thumbnailRevisionId` field. */
  thumbnailRevisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `thumbnailThumbnailRevision` relation. */
  thumbnailThumbnailRevision?: InputMaybe<FileRevisionFilter>;
  /** A related `thumbnailThumbnailRevision` exists. */
  thumbnailThumbnailRevisionExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** A filter to be used against many `PdfFileRevision` object types. All fields are combined with a logical ‘and.’ */
export type FileRevisionToManyPdfFileRevisionFilter = {
  /** Every related `PdfFileRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PdfFileRevisionFilter>;
  /** No related `PdfFileRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PdfFileRevisionFilter>;
  /** Some related `PdfFileRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PdfFileRevisionFilter>;
};

/** A filter to be used against many `SpaceItem` object types. All fields are combined with a logical ‘and.’ */
export type FileRevisionToManySpaceItemFilter = {
  /** Every related `SpaceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceItemFilter>;
  /** No related `SpaceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceItemFilter>;
  /** Some related `SpaceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceItemFilter>;
};

/** A filter to be used against many `SpaceSubmission` object types. All fields are combined with a logical ‘and.’ */
export type FileRevisionToManySpaceSubmissionFilter = {
  /** Every related `SpaceSubmission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SpaceSubmissionFilter>;
  /** No related `SpaceSubmission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SpaceSubmissionFilter>;
  /** Some related `SpaceSubmission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SpaceSubmissionFilter>;
};

/** Methods to use when ordering `FileRevision`. */
export type FileRevisionsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'EDITOR_ID_ASC'
  | 'EDITOR_ID_DESC'
  | 'FILENAME_ASC'
  | 'FILENAME_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'MIME_TYPE_ASC'
  | 'MIME_TYPE_DESC'
  | 'NATURAL'
  | 'PARENT_REVISION_ID_ASC'
  | 'PARENT_REVISION_ID_DESC'
  | 'PATH_ON_STORAGE_ASC'
  | 'PATH_ON_STORAGE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REVISION_ID_ASC'
  | 'REVISION_ID_DESC'
  | 'SHA256_ASC'
  | 'SHA256_DESC'
  | 'TOTAL_BYTES_ASC'
  | 'TOTAL_BYTES_DESC'
  | 'UPDATE_COMMENT_ASC'
  | 'UPDATE_COMMENT_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'UPLOADED_BYTES_ASC'
  | 'UPLOADED_BYTES_DESC';

/** A connection to a list of `FileRevision` values. */
export type FileRevisionsConnection = {
  __typename?: 'FileRevisionsConnection';
  /** A list of edges which contains the `FileRevision` and cursor to aid in pagination. */
  edges: Array<FileRevisionsEdge>;
  /** A list of `FileRevision` objects. */
  nodes: Array<FileRevision>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FileRevision` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FileRevision` edge in the connection. */
export type FileRevisionsEdge = {
  __typename?: 'FileRevisionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `FileRevision` at the end of the edge. */
  node: FileRevision;
};

export type FileRevision = Node & {
  __typename?: 'FileRevision';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `FileRevision`. */
  editor: Maybe<User>;
  editorId: Maybe<Scalars['UUID']['output']>;
  filename: Maybe<Scalars['String']['output']>;
  /** Reads a single `FileRevision` that is related to this `FileRevision`. */
  fileRevision: Maybe<FileRevision>;
  /** Reads and enables pagination through a set of `FileRevision`. */
  fileRevisionsByIdAndParentRevisionId: FileRevisionsConnection;
  id: Scalars['UUID']['output'];
  mimeType: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parentRevisionId: Maybe<Scalars['UUID']['output']>;
  pathOnStorage: Maybe<Scalars['String']['output']>;
  /** Reads a single `PdfFileRevision` that is related to this `FileRevision`. */
  pdfFileRevision: Maybe<PdfFileRevision>;
  /** Reads and enables pagination through a set of `PdfFileRevision`. */
  pdfFileRevisionsByThumbnailIdAndThumbnailRevisionId: PdfFileRevisionsConnection;
  revisionId: Scalars['UUID']['output'];
  sha256: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `SpaceItem`. */
  spaceItems: SpaceItemsConnection;
  /** Reads and enables pagination through a set of `SpaceSubmission`. */
  spaceSubmissions: SpaceSubmissionsConnection;
  totalBytes: Maybe<Scalars['Int']['output']>;
  updateComment: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
  uploadedBytes: Maybe<Scalars['Int']['output']>;
};


export type FileRevisionFileRevisionsByIdAndParentRevisionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileRevisionCondition>;
  filter?: InputMaybe<FileRevisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FileRevisionsOrderBy>>;
};


export type FileRevisionPdfFileRevisionsByThumbnailIdAndThumbnailRevisionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PdfFileRevisionCondition>;
  filter?: InputMaybe<PdfFileRevisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PdfFileRevisionsOrderBy>>;
};


export type FileRevisionSpaceItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceItemCondition>;
  filter?: InputMaybe<SpaceItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceItemsOrderBy>>;
};


export type FileRevisionSpaceSubmissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceSubmissionCondition>;
  filter?: InputMaybe<SpaceSubmissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceSubmissionsOrderBy>>;
};

export type PdfFileRevision = Node & {
  __typename?: 'PdfFileRevision';
  contentAsPlainText: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `FileRevision` that is related to this `PdfFileRevision`. */
  fileRevision: Maybe<FileRevision>;
  id: Scalars['UUID']['output'];
  metadata: Maybe<Scalars['JSON']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  pages: Scalars['Int']['output'];
  revisionId: Scalars['UUID']['output'];
  thumbnailId: Maybe<Scalars['UUID']['output']>;
  thumbnailRevisionId: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `FileRevision` that is related to this `PdfFileRevision`. */
  thumbnailThumbnailRevision: Maybe<FileRevision>;
  title: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `PdfFileRevision` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PdfFileRevisionCondition = {
  /** Checks for equality with the object’s `contentAsPlainText` field. */
  contentAsPlainText?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `metadata` field. */
  metadata?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `pages` field. */
  pages?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `thumbnailId` field. */
  thumbnailId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `thumbnailRevisionId` field. */
  thumbnailRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `PdfFileRevision`. */
export type PdfFileRevisionsOrderBy =
  | 'CONTENT_AS_PLAIN_TEXT_ASC'
  | 'CONTENT_AS_PLAIN_TEXT_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'METADATA_ASC'
  | 'METADATA_DESC'
  | 'NATURAL'
  | 'PAGES_ASC'
  | 'PAGES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REVISION_ID_ASC'
  | 'REVISION_ID_DESC'
  | 'THUMBNAIL_ID_ASC'
  | 'THUMBNAIL_ID_DESC'
  | 'THUMBNAIL_REVISION_ID_ASC'
  | 'THUMBNAIL_REVISION_ID_DESC'
  | 'TITLE_ASC'
  | 'TITLE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `PdfFileRevision` values. */
export type PdfFileRevisionsConnection = {
  __typename?: 'PdfFileRevisionsConnection';
  /** A list of edges which contains the `PdfFileRevision` and cursor to aid in pagination. */
  edges: Array<PdfFileRevisionsEdge>;
  /** A list of `PdfFileRevision` objects. */
  nodes: Array<PdfFileRevision>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PdfFileRevision` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PdfFileRevision` edge in the connection. */
export type PdfFileRevisionsEdge = {
  __typename?: 'PdfFileRevisionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `PdfFileRevision` at the end of the edge. */
  node: PdfFileRevision;
};

/**
 * A condition to be used against `SpaceItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SpaceItemCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `editorId` field. */
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `fileId` field. */
  fileId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isReviewed` field. */
  isReviewed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isSubmitted` field. */
  isSubmitted?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `latestReviewResult` field. */
  latestReviewResult?: InputMaybe<ReviewResult>;
  /** Checks for equality with the object’s `messageId` field. */
  messageId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `spaceId` field. */
  spaceId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `SpaceItem`. */
export type SpaceItemsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'EDITOR_ID_ASC'
  | 'EDITOR_ID_DESC'
  | 'FILE_ID_ASC'
  | 'FILE_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_REVIEWED_ASC'
  | 'IS_REVIEWED_DESC'
  | 'IS_SUBMITTED_ASC'
  | 'IS_SUBMITTED_DESC'
  | 'LATEST_REVIEW_RESULT_ASC'
  | 'LATEST_REVIEW_RESULT_DESC'
  | 'MESSAGE_ID_ASC'
  | 'MESSAGE_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REVISION_ID_ASC'
  | 'REVISION_ID_DESC'
  | 'SPACE_ID_ASC'
  | 'SPACE_ID_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `SpaceItem` values. */
export type SpaceItemsConnection = {
  __typename?: 'SpaceItemsConnection';
  /** A list of edges which contains the `SpaceItem` and cursor to aid in pagination. */
  edges: Array<SpaceItemsEdge>;
  /** A list of `SpaceItem` objects. */
  nodes: Array<SpaceItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SpaceItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SpaceItem` edge in the connection. */
export type SpaceItemsEdge = {
  __typename?: 'SpaceItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `SpaceItem` at the end of the edge. */
  node: SpaceItem;
};

export type SpaceItem = Node & {
  __typename?: 'SpaceItem';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `SpaceItem`. */
  editor: Maybe<User>;
  editorId: Maybe<Scalars['UUID']['output']>;
  fileId: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `FileRevision` that is related to this `SpaceItem`. */
  fileRevision: Maybe<FileRevision>;
  id: Scalars['UUID']['output'];
  isReviewed: Maybe<Scalars['Boolean']['output']>;
  isSubmitted: Maybe<Scalars['Boolean']['output']>;
  latestActiveSubmission: Maybe<SpaceSubmission>;
  latestReviewResult: Maybe<ReviewResult>;
  messageId: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `MessageRevision` that is related to this `SpaceItem`. */
  messageRevision: Maybe<MessageRevision>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  revisionId: Scalars['UUID']['output'];
  /** Reads a single `Space` that is related to this `SpaceItem`. */
  space: Maybe<Space>;
  spaceId: Scalars['UUID']['output'];
  /** Reads and enables pagination through a set of `SpaceSubmission`. */
  submissions: SpaceSubmissionsConnection;
  /** Reads a single `SpaceItemSubmissionAndApprovalTime` that is related to this `SpaceItem`. */
  times: Maybe<SpaceItemSubmissionAndApprovalTime>;
  updatedAt: Scalars['Datetime']['output'];
};


export type SpaceItemSubmissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceSubmissionCondition>;
  filter?: InputMaybe<SpaceSubmissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceSubmissionsOrderBy>>;
};

export type SpaceSubmission = Node & {
  __typename?: 'SpaceSubmission';
  fileId: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `FileRevision` that is related to this `SpaceSubmission`. */
  fileRevision: Maybe<FileRevision>;
  id: Scalars['UUID']['output'];
  messageId: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `MessageRevision` that is related to this `SpaceSubmission`. */
  messageRevision: Maybe<MessageRevision>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  revisionId: Scalars['UUID']['output'];
  /** Reads a single `SpaceItem` that is related to this `SpaceSubmission`. */
  spaceItem: Maybe<SpaceItem>;
  spaceItemId: Scalars['UUID']['output'];
  /** Reads a single `SpaceSubmissionReview` that is related to this `SpaceSubmission`. */
  spaceSubmissionReview: Maybe<SpaceSubmissionReview>;
  submittedAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `SpaceSubmission`. */
  submitter: Maybe<User>;
  submitterId: Maybe<Scalars['UUID']['output']>;
};

export type MessageRevision = Node & {
  __typename?: 'MessageRevision';
  body: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `MessageRevision`. */
  childRevisions: MessageRevisionsConnection;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `MessageRevision`. */
  editor: Maybe<User>;
  editorId: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `MessageRevision` that is related to this `MessageRevision`. */
  parentRevision: Maybe<MessageRevision>;
  parentRevisionId: Maybe<Scalars['UUID']['output']>;
  revisionId: Scalars['UUID']['output'];
  /** Reads and enables pagination through a set of `SpaceItem`. */
  spaceItems: SpaceItemsConnection;
  /** Reads and enables pagination through a set of `SpaceSubmission`. */
  spaceSubmissions: SpaceSubmissionsConnection;
  subject: Maybe<Scalars['String']['output']>;
  updateComment: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
};


export type MessageRevisionChildRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageRevisionCondition>;
  filter?: InputMaybe<MessageRevisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageRevisionsOrderBy>>;
};


export type MessageRevisionSpaceItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceItemCondition>;
  filter?: InputMaybe<SpaceItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceItemsOrderBy>>;
};


export type MessageRevisionSpaceSubmissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceSubmissionCondition>;
  filter?: InputMaybe<SpaceSubmissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceSubmissionsOrderBy>>;
};

/**
 * A condition to be used against `MessageRevision` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type MessageRevisionCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `editorId` field. */
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `parentRevisionId` field. */
  parentRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updateComment` field. */
  updateComment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `MessageRevision`. */
export type MessageRevisionsOrderBy =
  | 'BODY_ASC'
  | 'BODY_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'EDITOR_ID_ASC'
  | 'EDITOR_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PARENT_REVISION_ID_ASC'
  | 'PARENT_REVISION_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REVISION_ID_ASC'
  | 'REVISION_ID_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'UPDATE_COMMENT_ASC'
  | 'UPDATE_COMMENT_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `MessageRevision` values. */
export type MessageRevisionsConnection = {
  __typename?: 'MessageRevisionsConnection';
  /** A list of edges which contains the `MessageRevision` and cursor to aid in pagination. */
  edges: Array<MessageRevisionsEdge>;
  /** A list of `MessageRevision` objects. */
  nodes: Array<MessageRevision>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MessageRevision` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MessageRevision` edge in the connection. */
export type MessageRevisionsEdge = {
  __typename?: 'MessageRevisionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `MessageRevision` at the end of the edge. */
  node: MessageRevision;
};

/**
 * A condition to be used against `SpaceSubmission` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SpaceSubmissionCondition = {
  /** Checks for equality with the object’s `fileId` field. */
  fileId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `messageId` field. */
  messageId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `revisionId` field. */
  revisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `spaceItemId` field. */
  spaceItemId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `submittedAt` field. */
  submittedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `submitterId` field. */
  submitterId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Methods to use when ordering `SpaceSubmission`. */
export type SpaceSubmissionsOrderBy =
  | 'FILE_ID_ASC'
  | 'FILE_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'MESSAGE_ID_ASC'
  | 'MESSAGE_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REVISION_ID_ASC'
  | 'REVISION_ID_DESC'
  | 'SPACE_ITEM_ID_ASC'
  | 'SPACE_ITEM_ID_DESC'
  | 'SUBMITTED_AT_ASC'
  | 'SUBMITTED_AT_DESC'
  | 'SUBMITTER_ID_ASC'
  | 'SUBMITTER_ID_DESC';

/** A connection to a list of `SpaceSubmission` values. */
export type SpaceSubmissionsConnection = {
  __typename?: 'SpaceSubmissionsConnection';
  /** A list of edges which contains the `SpaceSubmission` and cursor to aid in pagination. */
  edges: Array<SpaceSubmissionsEdge>;
  /** A list of `SpaceSubmission` objects. */
  nodes: Array<SpaceSubmission>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SpaceSubmission` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SpaceSubmission` edge in the connection. */
export type SpaceSubmissionsEdge = {
  __typename?: 'SpaceSubmissionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `SpaceSubmission` at the end of the edge. */
  node: SpaceSubmission;
};

export type SpaceSubmissionReview = Node & {
  __typename?: 'SpaceSubmissionReview';
  comment: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  result: ReviewResult;
  /** Reads a single `User` that is related to this `SpaceSubmissionReview`. */
  reviewer: Maybe<User>;
  reviewerId: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `SpaceSubmission` that is related to this `SpaceSubmissionReview`. */
  spaceSubmission: Maybe<SpaceSubmission>;
  spaceSubmissionId: Scalars['UUID']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

export type Space = Node & {
  __typename?: 'Space';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `Space`. */
  creator: Maybe<User>;
  creatorId: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  isPublic: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `SpaceItem`. */
  items: SpaceItemsConnection;
  mySubscription: Maybe<SpaceSubscription>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Space`. */
  organization: Maybe<Organization>;
  organizationId: Scalars['UUID']['output'];
  slug: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `SpaceItemSubmissionAndApprovalTime`. */
  spaceItemSubmissionAndApprovalTimes: SpaceItemSubmissionAndApprovalTimesConnection;
  /** Reads and enables pagination through a set of `SpaceSubscription`. */
  subscriptions: SpaceSubscriptionsConnection;
  updatedAt: Scalars['Datetime']['output'];
};


export type SpaceItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceItemCondition>;
  filter?: InputMaybe<SpaceItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceItemsOrderBy>>;
};


export type SpaceSpaceItemSubmissionAndApprovalTimesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceItemSubmissionAndApprovalTimeCondition>;
  filter?: InputMaybe<SpaceItemSubmissionAndApprovalTimeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceItemSubmissionAndApprovalTimesOrderBy>>;
};


export type SpaceSubscriptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceSubscriptionCondition>;
  filter?: InputMaybe<SpaceSubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceSubscriptionsOrderBy>>;
};

export type SpaceSubscription = Node & {
  __typename?: 'SpaceSubscription';
  abilities: Array<Maybe<Ability>>;
  allAbilities: Maybe<Array<Maybe<Ability>>>;
  allAbilitiesWithGrantOption: Maybe<Array<Maybe<Ability>>>;
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  isReceivingNotifications: Scalars['Boolean']['output'];
  lastNotificationAt: Maybe<Scalars['Datetime']['output']>;
  lastVisitAt: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Space` that is related to this `SpaceSubscription`. */
  space: Maybe<Space>;
  spaceId: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `User` that is related to this `SpaceSubscription`. */
  subscriber: Maybe<User>;
  subscriberId: Maybe<Scalars['UUID']['output']>;
  updatedAt: Scalars['Datetime']['output'];
};

export type Organization = Node & {
  __typename?: 'Organization';
  createdAt: Scalars['Datetime']['output'];
  currentUserIsBillingContact: Maybe<Scalars['Boolean']['output']>;
  currentUserIsOwner: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['UUID']['output'];
  memberAbilities: Array<Maybe<Ability>>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `OrganizationMembership`. */
  organizationMemberships: OrganizationMembershipsConnection;
  ownerAbilities: Array<Maybe<Ability>>;
  slug: Scalars['String']['output'];
  spaceCreatorAbilities: Array<Maybe<Ability>>;
  /** Reads and enables pagination through a set of `SpaceItemSubmissionAndApprovalTime`. */
  spaceItemSubmissionAndApprovalTimes: SpaceItemSubmissionAndApprovalTimesConnection;
  /** Reads and enables pagination through a set of `Space`. */
  spaces: SpacesConnection;
};


export type OrganizationOrganizationMembershipsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationMembershipCondition>;
  filter?: InputMaybe<OrganizationMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationMembershipsOrderBy>>;
};


export type OrganizationSpaceItemSubmissionAndApprovalTimesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceItemSubmissionAndApprovalTimeCondition>;
  filter?: InputMaybe<SpaceItemSubmissionAndApprovalTimeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpaceItemSubmissionAndApprovalTimesOrderBy>>;
};


export type OrganizationSpacesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceCondition>;
  filter?: InputMaybe<SpaceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpacesOrderBy>>;
};

/**
 * A condition to be used against `OrganizationMembership` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type OrganizationMembershipCondition = {
  /** Checks for equality with the object’s `abilities` field. */
  abilities?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isBillingContact` field. */
  isBillingContact?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isOwner` field. */
  isOwner?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Methods to use when ordering `OrganizationMembership`. */
export type OrganizationMembershipsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_BILLING_CONTACT_ASC'
  | 'IS_BILLING_CONTACT_DESC'
  | 'IS_OWNER_ASC'
  | 'IS_OWNER_DESC'
  | 'NATURAL'
  | 'ORGANIZATION_ID_ASC'
  | 'ORGANIZATION_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** A connection to a list of `OrganizationMembership` values. */
export type OrganizationMembershipsConnection = {
  __typename?: 'OrganizationMembershipsConnection';
  /** A list of edges which contains the `OrganizationMembership` and cursor to aid in pagination. */
  edges: Array<OrganizationMembershipsEdge>;
  /** A list of `OrganizationMembership` objects. */
  nodes: Array<OrganizationMembership>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrganizationMembership` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `OrganizationMembership` edge in the connection. */
export type OrganizationMembershipsEdge = {
  __typename?: 'OrganizationMembershipsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `OrganizationMembership` at the end of the edge. */
  node: OrganizationMembership;
};

export type OrganizationMembership = Node & {
  __typename?: 'OrganizationMembership';
  abilities: Maybe<Array<Maybe<Ability>>>;
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  isBillingContact: Scalars['Boolean']['output'];
  isOwner: Scalars['Boolean']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `OrganizationMembership`. */
  organization: Maybe<Organization>;
  organizationId: Scalars['UUID']['output'];
  /** Reads a single `User` that is related to this `OrganizationMembership`. */
  user: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `SpaceItemSubmissionAndApprovalTime` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type SpaceItemSubmissionAndApprovalTimeCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `currentApprovalSince` field. */
  currentApprovalSince?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `currentSubmissionSince` field. */
  currentSubmissionSince?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `editorId` field. */
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `firstApprovalAt` field. */
  firstApprovalAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `firstSubmissionAt` field. */
  firstSubmissionAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `lastApprovalAt` field. */
  lastApprovalAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `lastSubmissionAt` field. */
  lastSubmissionAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `spaceId` field. */
  spaceId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `spaceItemId` field. */
  spaceItemId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `SpaceItemSubmissionAndApprovalTime`. */
export type SpaceItemSubmissionAndApprovalTimesOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CURRENT_APPROVAL_SINCE_ASC'
  | 'CURRENT_APPROVAL_SINCE_DESC'
  | 'CURRENT_SUBMISSION_SINCE_ASC'
  | 'CURRENT_SUBMISSION_SINCE_DESC'
  | 'EDITOR_ID_ASC'
  | 'EDITOR_ID_DESC'
  | 'FIRST_APPROVAL_AT_ASC'
  | 'FIRST_APPROVAL_AT_DESC'
  | 'FIRST_SUBMISSION_AT_ASC'
  | 'FIRST_SUBMISSION_AT_DESC'
  | 'LAST_APPROVAL_AT_ASC'
  | 'LAST_APPROVAL_AT_DESC'
  | 'LAST_SUBMISSION_AT_ASC'
  | 'LAST_SUBMISSION_AT_DESC'
  | 'NATURAL'
  | 'ORGANIZATION_ID_ASC'
  | 'ORGANIZATION_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SPACE_ID_ASC'
  | 'SPACE_ID_DESC'
  | 'SPACE_ITEM_ID_ASC'
  | 'SPACE_ITEM_ID_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `SpaceItemSubmissionAndApprovalTime` values. */
export type SpaceItemSubmissionAndApprovalTimesConnection = {
  __typename?: 'SpaceItemSubmissionAndApprovalTimesConnection';
  /** A list of edges which contains the `SpaceItemSubmissionAndApprovalTime` and cursor to aid in pagination. */
  edges: Array<SpaceItemSubmissionAndApprovalTimesEdge>;
  /** A list of `SpaceItemSubmissionAndApprovalTime` objects. */
  nodes: Array<SpaceItemSubmissionAndApprovalTime>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SpaceItemSubmissionAndApprovalTime` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SpaceItemSubmissionAndApprovalTime` edge in the connection. */
export type SpaceItemSubmissionAndApprovalTimesEdge = {
  __typename?: 'SpaceItemSubmissionAndApprovalTimesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `SpaceItemSubmissionAndApprovalTime` at the end of the edge. */
  node: SpaceItemSubmissionAndApprovalTime;
};

export type SpaceItemSubmissionAndApprovalTime = Node & {
  __typename?: 'SpaceItemSubmissionAndApprovalTime';
  createdAt: Maybe<Scalars['Datetime']['output']>;
  currentApprovalSince: Maybe<Scalars['Datetime']['output']>;
  currentSubmissionSince: Maybe<Scalars['Datetime']['output']>;
  editorId: Maybe<Scalars['UUID']['output']>;
  firstApprovalAt: Maybe<Scalars['Datetime']['output']>;
  firstSubmissionAt: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `SpaceItem` that is related to this `SpaceItemSubmissionAndApprovalTime`. */
  item: Maybe<SpaceItem>;
  lastApprovalAt: Maybe<Scalars['Datetime']['output']>;
  lastSubmissionAt: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `SpaceItemSubmissionAndApprovalTime`. */
  organization: Maybe<Organization>;
  organizationId: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `Space` that is related to this `SpaceItemSubmissionAndApprovalTime`. */
  space: Maybe<Space>;
  spaceId: Maybe<Scalars['UUID']['output']>;
  spaceItemId: Scalars['UUID']['output'];
  updatedAt: Maybe<Scalars['Datetime']['output']>;
};

/** A condition to be used against `Space` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SpaceCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `creatorId` field. */
  creatorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `Space`. */
export type SpacesOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CREATOR_ID_ASC'
  | 'CREATOR_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'ORGANIZATION_ID_ASC'
  | 'ORGANIZATION_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SLUG_ASC'
  | 'SLUG_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `Space` values. */
export type SpacesConnection = {
  __typename?: 'SpacesConnection';
  /** A list of edges which contains the `Space` and cursor to aid in pagination. */
  edges: Array<SpacesEdge>;
  /** A list of `Space` objects. */
  nodes: Array<Space>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Space` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Space` edge in the connection. */
export type SpacesEdge = {
  __typename?: 'SpacesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Space` at the end of the edge. */
  node: Space;
};

/**
 * A condition to be used against `SpaceSubscription` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SpaceSubscriptionCondition = {
  /** Checks for equality with the object’s `abilities` field. */
  abilities?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isReceivingNotifications` field. */
  isReceivingNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `lastNotificationAt` field. */
  lastNotificationAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `lastVisitAt` field. */
  lastVisitAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `spaceId` field. */
  spaceId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `subscriberId` field. */
  subscriberId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `SpaceSubscription`. */
export type SpaceSubscriptionsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_RECEIVING_NOTIFICATIONS_ASC'
  | 'IS_RECEIVING_NOTIFICATIONS_DESC'
  | 'LAST_NOTIFICATION_AT_ASC'
  | 'LAST_NOTIFICATION_AT_DESC'
  | 'LAST_VISIT_AT_ASC'
  | 'LAST_VISIT_AT_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SPACE_ID_ASC'
  | 'SPACE_ID_DESC'
  | 'SUBSCRIBER_ID_ASC'
  | 'SUBSCRIBER_ID_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `SpaceSubscription` values. */
export type SpaceSubscriptionsConnection = {
  __typename?: 'SpaceSubscriptionsConnection';
  /** A list of edges which contains the `SpaceSubscription` and cursor to aid in pagination. */
  edges: Array<SpaceSubscriptionsEdge>;
  /** A list of `SpaceSubscription` objects. */
  nodes: Array<SpaceSubscription>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SpaceSubscription` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SpaceSubscription` edge in the connection. */
export type SpaceSubscriptionsEdge = {
  __typename?: 'SpaceSubscriptionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `SpaceSubscription` at the end of the edge. */
  node: SpaceSubscription;
};

/**
 * A condition to be used against `SpaceSubmissionReview` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type SpaceSubmissionReviewCondition = {
  /** Checks for equality with the object’s `comment` field. */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `result` field. */
  result?: InputMaybe<ReviewResult>;
  /** Checks for equality with the object’s `reviewerId` field. */
  reviewerId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `spaceSubmissionId` field. */
  spaceSubmissionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `SpaceSubmissionReview`. */
export type SpaceSubmissionReviewsOrderBy =
  | 'COMMENT_ASC'
  | 'COMMENT_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'RESULT_ASC'
  | 'RESULT_DESC'
  | 'REVIEWER_ID_ASC'
  | 'REVIEWER_ID_DESC'
  | 'SPACE_SUBMISSION_ID_ASC'
  | 'SPACE_SUBMISSION_ID_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `SpaceSubmissionReview` values. */
export type SpaceSubmissionReviewsConnection = {
  __typename?: 'SpaceSubmissionReviewsConnection';
  /** A list of edges which contains the `SpaceSubmissionReview` and cursor to aid in pagination. */
  edges: Array<SpaceSubmissionReviewsEdge>;
  /** A list of `SpaceSubmissionReview` objects. */
  nodes: Array<SpaceSubmissionReview>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SpaceSubmissionReview` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SpaceSubmissionReview` edge in the connection. */
export type SpaceSubmissionReviewsEdge = {
  __typename?: 'SpaceSubmissionReviewsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `SpaceSubmissionReview` at the end of the edge. */
  node: SpaceSubmissionReview;
};

/**
 * A condition to be used against `UserAuthentication` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UserAuthenticationCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `details` field. */
  details?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `identifier` field. */
  identifier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `service` field. */
  service?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Methods to use when ordering `UserAuthentication`. */
export type UserAuthenticationsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'DETAILS_ASC'
  | 'DETAILS_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IDENTIFIER_ASC'
  | 'IDENTIFIER_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SERVICE_ASC'
  | 'SERVICE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** A connection to a list of `UserAuthentication` values. */
export type UserAuthenticationsConnection = {
  __typename?: 'UserAuthenticationsConnection';
  /** A list of edges which contains the `UserAuthentication` and cursor to aid in pagination. */
  edges: Array<UserAuthenticationsEdge>;
  /** A list of `UserAuthentication` objects. */
  nodes: Array<UserAuthentication>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserAuthentication` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserAuthentication` edge in the connection. */
export type UserAuthenticationsEdge = {
  __typename?: 'UserAuthenticationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UserAuthentication` at the end of the edge. */
  node: UserAuthentication;
};

/** Contains information about the login providers this user has used, so that they may disconnect them should they wish. */
export type UserAuthentication = Node & {
  __typename?: 'UserAuthentication';
  createdAt: Scalars['Datetime']['output'];
  /** Additional profile details extracted from this login method */
  details: Scalars['JSON']['output'];
  id: Scalars['UUID']['output'];
  /** A unique identifier for the user within the login service. */
  identifier: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** The login service used, e.g. `twitter` or `github`. */
  service: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `UserAuthentication`. */
  user: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `UserEmail` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserEmailCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isPrimary` field. */
  isPrimary?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isVerified` field. */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Methods to use when ordering `UserEmail`. */
export type UserEmailsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_PRIMARY_ASC'
  | 'IS_PRIMARY_DESC'
  | 'IS_VERIFIED_ASC'
  | 'IS_VERIFIED_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** A connection to a list of `UserEmail` values. */
export type UserEmailsConnection = {
  __typename?: 'UserEmailsConnection';
  /** A list of edges which contains the `UserEmail` and cursor to aid in pagination. */
  edges: Array<UserEmailsEdge>;
  /** A list of `UserEmail` objects. */
  nodes: Array<UserEmail>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserEmail` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserEmail` edge in the connection. */
export type UserEmailsEdge = {
  __typename?: 'UserEmailsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UserEmail` at the end of the edge. */
  node: UserEmail;
};

/** Information about a user's email address. */
export type UserEmail = Node & {
  __typename?: 'UserEmail';
  createdAt: Scalars['Datetime']['output'];
  /** The users email address, in `a@b.c` format. */
  email: Scalars['String']['output'];
  id: Scalars['UUID']['output'];
  isPrimary: Scalars['Boolean']['output'];
  /** True if the user has is_verified their email address (by clicking the link in the email we sent them, or logging in with a social login provider), false otherwise. */
  isVerified: Scalars['Boolean']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/** A connection to a list of `UUID` values. */
export type CurrentUserInvitedOrganizationIdsConnection = {
  __typename?: 'CurrentUserInvitedOrganizationIdsConnection';
  /** A list of edges which contains the `UUID` and cursor to aid in pagination. */
  edges: Array<Maybe<CurrentUserInvitedOrganizationIdsEdge>>;
  /** A list of `UUID` objects. */
  nodes: Array<Maybe<Scalars['UUID']['output']>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UUID` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UUID` edge in the connection. */
export type CurrentUserInvitedOrganizationIdsEdge = {
  __typename?: 'CurrentUserInvitedOrganizationIdsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UUID` at the end of the edge. */
  node: Maybe<Scalars['UUID']['output']>;
};

/** A connection to a list of `UUID` values. */
export type CurrentUserMemberOrganizationIdsConnection = {
  __typename?: 'CurrentUserMemberOrganizationIdsConnection';
  /** A list of edges which contains the `UUID` and cursor to aid in pagination. */
  edges: Array<Maybe<CurrentUserMemberOrganizationIdsEdge>>;
  /** A list of `UUID` objects. */
  nodes: Array<Maybe<Scalars['UUID']['output']>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UUID` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UUID` edge in the connection. */
export type CurrentUserMemberOrganizationIdsEdge = {
  __typename?: 'CurrentUserMemberOrganizationIdsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UUID` at the end of the edge. */
  node: Maybe<Scalars['UUID']['output']>;
};

/** A connection to a list of `UUID` values. */
export type MyOrganizationIdsConnection = {
  __typename?: 'MyOrganizationIdsConnection';
  /** A list of edges which contains the `UUID` and cursor to aid in pagination. */
  edges: Array<Maybe<MyOrganizationIdsEdge>>;
  /** A list of `UUID` objects. */
  nodes: Array<Maybe<Scalars['UUID']['output']>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UUID` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UUID` edge in the connection. */
export type MyOrganizationIdsEdge = {
  __typename?: 'MyOrganizationIdsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UUID` at the end of the edge. */
  node: Maybe<Scalars['UUID']['output']>;
};

/** A connection to a list of `UUID` values. */
export type MySpaceIdsConnection = {
  __typename?: 'MySpaceIdsConnection';
  /** A list of edges which contains the `UUID` and cursor to aid in pagination. */
  edges: Array<Maybe<MySpaceIdsEdge>>;
  /** A list of `UUID` objects. */
  nodes: Array<Maybe<Scalars['UUID']['output']>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UUID` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UUID` edge in the connection. */
export type MySpaceIdsEdge = {
  __typename?: 'MySpaceIdsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UUID` at the end of the edge. */
  node: Maybe<Scalars['UUID']['output']>;
};

/** A connection to a list of `UUID` values. */
export type MySpaceSubscriptionIdsConnection = {
  __typename?: 'MySpaceSubscriptionIdsConnection';
  /** A list of edges which contains the `UUID` and cursor to aid in pagination. */
  edges: Array<Maybe<MySpaceSubscriptionIdsEdge>>;
  /** A list of `UUID` objects. */
  nodes: Array<Maybe<Scalars['UUID']['output']>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UUID` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UUID` edge in the connection. */
export type MySpaceSubscriptionIdsEdge = {
  __typename?: 'MySpaceSubscriptionIdsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UUID` at the end of the edge. */
  node: Maybe<Scalars['UUID']['output']>;
};

/**
 * A condition to be used against `Organization` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OrganizationCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `currentUserIsBillingContact` field. */
  currentUserIsBillingContact?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `currentUserIsOwner` field. */
  currentUserIsOwner?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `memberAbilities` field. */
  memberAbilities?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerAbilities` field. */
  ownerAbilities?: InputMaybe<Array<InputMaybe<Ability>>>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `spaceCreatorAbilities` field. */
  spaceCreatorAbilities?: InputMaybe<Array<InputMaybe<Ability>>>;
};

/** Methods to use when ordering `Organization`. */
export type OrganizationsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SLUG_ASC'
  | 'SLUG_DESC';

/** A connection to a list of `Organization` values. */
export type OrganizationsConnection = {
  __typename?: 'OrganizationsConnection';
  /** A list of edges which contains the `Organization` and cursor to aid in pagination. */
  edges: Array<OrganizationsEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection. */
export type OrganizationsEdge = {
  __typename?: 'OrganizationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `avatarUrl` field. */
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `hasPassword` field. */
  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isVerified` field. */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Methods to use when ordering `User`. */
export type UsersOrderBy =
  | 'AVATAR_URL_ASC'
  | 'AVATAR_URL_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_ADMIN_ASC'
  | 'IS_ADMIN_DESC'
  | 'IS_VERIFIED_ASC'
  | 'IS_VERIFIED_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'USERNAME_ASC'
  | 'USERNAME_DESC';

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  acceptInvitationToOrganization: Maybe<AcceptInvitationToOrganizationPayload>;
  /** Enter your old password and a new password to change your password. */
  changePassword: Maybe<ChangePasswordPayload>;
  /** If you're certain you want to delete your account, use `requestAccountDeletion` to request an account deletion token, and then supply the token through this mutation to complete account deletion. */
  confirmAccountDeletion: Maybe<ConfirmAccountDeletionPayload>;
  /** Creates a single `ActiveMessageRevision`. */
  createActiveMessageRevision: Maybe<CreateActiveMessageRevisionPayload>;
  /** Creates a single `CurrentMessageRevision`. */
  createCurrentMessageRevision: Maybe<CreateCurrentMessageRevisionPayload>;
  /** Creates a single `FileRevision`. */
  createFileRevision: Maybe<CreateFileRevisionPayload>;
  /** Creates a single `MessageRevision`. */
  createMessageRevision: Maybe<CreateMessageRevisionPayload>;
  createOrganization: Maybe<CreateOrganizationPayload>;
  /** Creates a single `Space`. */
  createSpace: Maybe<CreateSpacePayload>;
  /** Creates a single `SpaceItem`. */
  createSpaceItem: Maybe<CreateSpaceItemPayload>;
  /** Creates a single `SpaceSubmission`. */
  createSpaceSubmission: Maybe<CreateSpaceSubmissionPayload>;
  /** Creates a single `SpaceSubmissionReview`. */
  createSpaceSubmissionReview: Maybe<CreateSpaceSubmissionReviewPayload>;
  /** Creates a single `SpaceSubscription`. */
  createSpaceSubscription: Maybe<CreateSpaceSubscriptionPayload>;
  /** Creates a single `UserEmail`. */
  createUserEmail: Maybe<CreateUserEmailPayload>;
  /** Deletes a single `ActiveMessageRevision` using a unique key. */
  deleteActiveMessageRevision: Maybe<DeleteActiveMessageRevisionPayload>;
  /** Deletes a single `ActiveMessageRevision` using its globally unique id. */
  deleteActiveMessageRevisionByNodeId: Maybe<DeleteActiveMessageRevisionPayload>;
  /** Deletes a single `CurrentMessageRevision` using a unique key. */
  deleteCurrentMessageRevision: Maybe<DeleteCurrentMessageRevisionPayload>;
  /** Deletes a single `CurrentMessageRevision` using its globally unique id. */
  deleteCurrentMessageRevisionByNodeId: Maybe<DeleteCurrentMessageRevisionPayload>;
  /** Deletes a single `FileRevision` using a unique key. */
  deleteFileRevision: Maybe<DeleteFileRevisionPayload>;
  /** Deletes a single `FileRevision` using its globally unique id. */
  deleteFileRevisionByNodeId: Maybe<DeleteFileRevisionPayload>;
  /** Deletes a single `FileRevision` using a unique key. */
  deleteFileRevisionByRevisionId: Maybe<DeleteFileRevisionPayload>;
  /** Deletes a single `MessageRevision` using a unique key. */
  deleteMessageRevision: Maybe<DeleteMessageRevisionPayload>;
  /** Deletes a single `MessageRevision` using its globally unique id. */
  deleteMessageRevisionByNodeId: Maybe<DeleteMessageRevisionPayload>;
  /** Deletes a single `MessageRevision` using a unique key. */
  deleteMessageRevisionByRevisionId: Maybe<DeleteMessageRevisionPayload>;
  deleteOrganization: Maybe<DeleteOrganizationPayload>;
  /** Deletes a single `Space` using a unique key. */
  deleteSpace: Maybe<DeleteSpacePayload>;
  /** Deletes a single `Space` using its globally unique id. */
  deleteSpaceByNodeId: Maybe<DeleteSpacePayload>;
  /** Deletes a single `Space` using a unique key. */
  deleteSpaceByOrganizationIdAndSlug: Maybe<DeleteSpacePayload>;
  /** Deletes a single `SpaceItem` using a unique key. */
  deleteSpaceItem: Maybe<DeleteSpaceItemPayload>;
  /** Deletes a single `SpaceItem` using its globally unique id. */
  deleteSpaceItemByNodeId: Maybe<DeleteSpaceItemPayload>;
  /** Deletes a single `SpaceSubmission` using a unique key. */
  deleteSpaceSubmission: Maybe<DeleteSpaceSubmissionPayload>;
  /** Deletes a single `SpaceSubmission` using its globally unique id. */
  deleteSpaceSubmissionByNodeId: Maybe<DeleteSpaceSubmissionPayload>;
  /** Deletes a single `SpaceSubmissionReview` using a unique key. */
  deleteSpaceSubmissionReview: Maybe<DeleteSpaceSubmissionReviewPayload>;
  /** Deletes a single `SpaceSubmissionReview` using its globally unique id. */
  deleteSpaceSubmissionReviewByNodeId: Maybe<DeleteSpaceSubmissionReviewPayload>;
  /** Deletes a single `SpaceSubscription` using a unique key. */
  deleteSpaceSubscription: Maybe<DeleteSpaceSubscriptionPayload>;
  /** Deletes a single `SpaceSubscription` using its globally unique id. */
  deleteSpaceSubscriptionByNodeId: Maybe<DeleteSpaceSubscriptionPayload>;
  /** Deletes a single `SpaceSubscription` using a unique key. */
  deleteSpaceSubscriptionBySubscriberIdAndSpaceId: Maybe<DeleteSpaceSubscriptionPayload>;
  /** Deletes a single `UserAuthentication` using a unique key. */
  deleteUserAuthentication: Maybe<DeleteUserAuthenticationPayload>;
  /** Deletes a single `UserAuthentication` using its globally unique id. */
  deleteUserAuthenticationByNodeId: Maybe<DeleteUserAuthenticationPayload>;
  /** Deletes a single `UserAuthentication` using a unique key. */
  deleteUserAuthenticationByServiceAndIdentifier: Maybe<DeleteUserAuthenticationPayload>;
  /** Deletes a single `UserEmail` using a unique key. */
  deleteUserEmail: Maybe<DeleteUserEmailPayload>;
  /** Deletes a single `UserEmail` using its globally unique id. */
  deleteUserEmailByNodeId: Maybe<DeleteUserEmailPayload>;
  /** Deletes a single `UserEmail` using a unique key. */
  deleteUserEmailByUserIdAndEmail: Maybe<DeleteUserEmailPayload>;
  /** If you've forgotten your password, give us one of your email addresses and we'll send you a reset token. Note this only works if you have added an email address! */
  forgotPassword: Maybe<ForgotPasswordPayload>;
  inviteToOrganization: Maybe<InviteToOrganizationPayload>;
  /** Use this mutation to log in to your account; this login uses sessions so you do not need to take further action. */
  login: Maybe<LoginPayload>;
  /** Use this mutation to logout from your account. Don't forget to clear the client state! */
  logout: Maybe<LogoutPayload>;
  /** Your primary email is where we'll notify of account events; other emails may be used for discovery or login. Use this when you're changing your email address. */
  makeEmailPrimary: Maybe<MakeEmailPrimaryPayload>;
  /** Use this mutation to create an account on our system. This may only be used if you are logged out. */
  register: Maybe<RegisterPayload>;
  removeFromOrganization: Maybe<RemoveFromOrganizationPayload>;
  /** Begin the account deletion flow by requesting the confirmation email */
  requestAccountDeletion: Maybe<RequestAccountDeletionPayload>;
  /** If you didn't receive the verification code for this email, we can resend it. We silently cap the rate of resends on the backend, so calls to this function may not result in another email being sent if it has been called recently. */
  resendEmailVerificationCode: Maybe<ResendEmailVerificationCodePayload>;
  /** After triggering forgotPassword, you'll be sent a reset token. Combine this with your user ID and a new password to reset your password. */
  resetPassword: Maybe<ResetPasswordPayload>;
  transferOrganizationBillingContact: Maybe<TransferOrganizationBillingContactPayload>;
  transferOrganizationOwnership: Maybe<TransferOrganizationOwnershipPayload>;
  /** Updates a single `ActiveMessageRevision` using a unique key and a patch. */
  updateActiveMessageRevision: Maybe<UpdateActiveMessageRevisionPayload>;
  /** Updates a single `ActiveMessageRevision` using its globally unique id and a patch. */
  updateActiveMessageRevisionByNodeId: Maybe<UpdateActiveMessageRevisionPayload>;
  /** Updates a single `CurrentMessageRevision` using a unique key and a patch. */
  updateCurrentMessageRevision: Maybe<UpdateCurrentMessageRevisionPayload>;
  /** Updates a single `CurrentMessageRevision` using its globally unique id and a patch. */
  updateCurrentMessageRevisionByNodeId: Maybe<UpdateCurrentMessageRevisionPayload>;
  /** Updates a single `FileRevision` using a unique key and a patch. */
  updateFileRevision: Maybe<UpdateFileRevisionPayload>;
  /** Updates a single `FileRevision` using its globally unique id and a patch. */
  updateFileRevisionByNodeId: Maybe<UpdateFileRevisionPayload>;
  /** Updates a single `FileRevision` using a unique key and a patch. */
  updateFileRevisionByRevisionId: Maybe<UpdateFileRevisionPayload>;
  /** Updates a single `MessageRevision` using a unique key and a patch. */
  updateMessageRevision: Maybe<UpdateMessageRevisionPayload>;
  /** Updates a single `MessageRevision` using its globally unique id and a patch. */
  updateMessageRevisionByNodeId: Maybe<UpdateMessageRevisionPayload>;
  /** Updates a single `MessageRevision` using a unique key and a patch. */
  updateMessageRevisionByRevisionId: Maybe<UpdateMessageRevisionPayload>;
  /** Updates a single `Organization` using a unique key and a patch. */
  updateOrganization: Maybe<UpdateOrganizationPayload>;
  /** Updates a single `Organization` using its globally unique id and a patch. */
  updateOrganizationByNodeId: Maybe<UpdateOrganizationPayload>;
  /** Updates a single `Organization` using a unique key and a patch. */
  updateOrganizationBySlug: Maybe<UpdateOrganizationPayload>;
  /** Updates a single `Space` using a unique key and a patch. */
  updateSpace: Maybe<UpdateSpacePayload>;
  /** Updates a single `Space` using its globally unique id and a patch. */
  updateSpaceByNodeId: Maybe<UpdateSpacePayload>;
  /** Updates a single `Space` using a unique key and a patch. */
  updateSpaceByOrganizationIdAndSlug: Maybe<UpdateSpacePayload>;
  /** Updates a single `SpaceItem` using a unique key and a patch. */
  updateSpaceItem: Maybe<UpdateSpaceItemPayload>;
  /** Updates a single `SpaceItem` using its globally unique id and a patch. */
  updateSpaceItemByNodeId: Maybe<UpdateSpaceItemPayload>;
  /** Updates a single `SpaceSubmissionReview` using a unique key and a patch. */
  updateSpaceSubmissionReview: Maybe<UpdateSpaceSubmissionReviewPayload>;
  /** Updates a single `SpaceSubmissionReview` using its globally unique id and a patch. */
  updateSpaceSubmissionReviewByNodeId: Maybe<UpdateSpaceSubmissionReviewPayload>;
  /** Updates a single `SpaceSubscription` using a unique key and a patch. */
  updateSpaceSubscription: Maybe<UpdateSpaceSubscriptionPayload>;
  /** Updates a single `SpaceSubscription` using its globally unique id and a patch. */
  updateSpaceSubscriptionByNodeId: Maybe<UpdateSpaceSubscriptionPayload>;
  /** Updates a single `SpaceSubscription` using a unique key and a patch. */
  updateSpaceSubscriptionBySubscriberIdAndSpaceId: Maybe<UpdateSpaceSubscriptionPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByUsername: Maybe<UpdateUserPayload>;
  /** Once you have received a verification token for your email, you may call this mutation with that token to make your email verified. */
  verifyEmail: Maybe<VerifyEmailPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationAcceptInvitationToOrganizationArgs = {
  input: AcceptInvitationToOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationChangePasswordArgs = {
  input: ChangePasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationConfirmAccountDeletionArgs = {
  input: ConfirmAccountDeletionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateActiveMessageRevisionArgs = {
  input: CreateActiveMessageRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCurrentMessageRevisionArgs = {
  input: CreateCurrentMessageRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFileRevisionArgs = {
  input: CreateFileRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMessageRevisionArgs = {
  input: CreateMessageRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrganizationArgs = {
  input: CreateOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSpaceArgs = {
  input: CreateSpaceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSpaceItemArgs = {
  input: CreateSpaceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSpaceSubmissionArgs = {
  input: CreateSpaceSubmissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSpaceSubmissionReviewArgs = {
  input: CreateSpaceSubmissionReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSpaceSubscriptionArgs = {
  input: CreateSpaceSubscriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserEmailArgs = {
  input: CreateUserEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActiveMessageRevisionArgs = {
  input: DeleteActiveMessageRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActiveMessageRevisionByNodeIdArgs = {
  input: DeleteActiveMessageRevisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCurrentMessageRevisionArgs = {
  input: DeleteCurrentMessageRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCurrentMessageRevisionByNodeIdArgs = {
  input: DeleteCurrentMessageRevisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileRevisionArgs = {
  input: DeleteFileRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileRevisionByNodeIdArgs = {
  input: DeleteFileRevisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileRevisionByRevisionIdArgs = {
  input: DeleteFileRevisionByRevisionIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageRevisionArgs = {
  input: DeleteMessageRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageRevisionByNodeIdArgs = {
  input: DeleteMessageRevisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageRevisionByRevisionIdArgs = {
  input: DeleteMessageRevisionByRevisionIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationArgs = {
  input: DeleteOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpaceArgs = {
  input: DeleteSpaceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpaceByNodeIdArgs = {
  input: DeleteSpaceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpaceByOrganizationIdAndSlugArgs = {
  input: DeleteSpaceByOrganizationIdAndSlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpaceItemArgs = {
  input: DeleteSpaceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpaceItemByNodeIdArgs = {
  input: DeleteSpaceItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpaceSubmissionArgs = {
  input: DeleteSpaceSubmissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpaceSubmissionByNodeIdArgs = {
  input: DeleteSpaceSubmissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpaceSubmissionReviewArgs = {
  input: DeleteSpaceSubmissionReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpaceSubmissionReviewByNodeIdArgs = {
  input: DeleteSpaceSubmissionReviewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpaceSubscriptionArgs = {
  input: DeleteSpaceSubscriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpaceSubscriptionByNodeIdArgs = {
  input: DeleteSpaceSubscriptionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpaceSubscriptionBySubscriberIdAndSpaceIdArgs = {
  input: DeleteSpaceSubscriptionBySubscriberIdAndSpaceIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserAuthenticationArgs = {
  input: DeleteUserAuthenticationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserAuthenticationByNodeIdArgs = {
  input: DeleteUserAuthenticationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserAuthenticationByServiceAndIdentifierArgs = {
  input: DeleteUserAuthenticationByServiceAndIdentifierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserEmailArgs = {
  input: DeleteUserEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserEmailByNodeIdArgs = {
  input: DeleteUserEmailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserEmailByUserIdAndEmailArgs = {
  input: DeleteUserEmailByUserIdAndEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationForgotPasswordArgs = {
  input: ForgotPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationInviteToOrganizationArgs = {
  input: InviteToOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLoginArgs = {
  input: LoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationMakeEmailPrimaryArgs = {
  input: MakeEmailPrimaryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRegisterArgs = {
  input: RegisterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRemoveFromOrganizationArgs = {
  input: RemoveFromOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRequestAccountDeletionArgs = {
  input: RequestAccountDeletionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResendEmailVerificationCodeArgs = {
  input: ResendEmailVerificationCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationTransferOrganizationBillingContactArgs = {
  input: TransferOrganizationBillingContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationTransferOrganizationOwnershipArgs = {
  input: TransferOrganizationOwnershipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActiveMessageRevisionArgs = {
  input: UpdateActiveMessageRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActiveMessageRevisionByNodeIdArgs = {
  input: UpdateActiveMessageRevisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCurrentMessageRevisionArgs = {
  input: UpdateCurrentMessageRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCurrentMessageRevisionByNodeIdArgs = {
  input: UpdateCurrentMessageRevisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileRevisionArgs = {
  input: UpdateFileRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileRevisionByNodeIdArgs = {
  input: UpdateFileRevisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileRevisionByRevisionIdArgs = {
  input: UpdateFileRevisionByRevisionIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageRevisionArgs = {
  input: UpdateMessageRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageRevisionByNodeIdArgs = {
  input: UpdateMessageRevisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageRevisionByRevisionIdArgs = {
  input: UpdateMessageRevisionByRevisionIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationArgs = {
  input: UpdateOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationByNodeIdArgs = {
  input: UpdateOrganizationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationBySlugArgs = {
  input: UpdateOrganizationBySlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpaceArgs = {
  input: UpdateSpaceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpaceByNodeIdArgs = {
  input: UpdateSpaceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpaceByOrganizationIdAndSlugArgs = {
  input: UpdateSpaceByOrganizationIdAndSlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpaceItemArgs = {
  input: UpdateSpaceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpaceItemByNodeIdArgs = {
  input: UpdateSpaceItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpaceSubmissionReviewArgs = {
  input: UpdateSpaceSubmissionReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpaceSubmissionReviewByNodeIdArgs = {
  input: UpdateSpaceSubmissionReviewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpaceSubscriptionArgs = {
  input: UpdateSpaceSubscriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpaceSubscriptionByNodeIdArgs = {
  input: UpdateSpaceSubscriptionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpaceSubscriptionBySubscriberIdAndSpaceIdArgs = {
  input: UpdateSpaceSubscriptionBySubscriberIdAndSpaceIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByUsernameArgs = {
  input: UpdateUserByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationVerifyEmailArgs = {
  input: VerifyEmailInput;
};

/** All input for the `acceptInvitationToOrganization` mutation. */
export type AcceptInvitationToOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  invitationId: Scalars['UUID']['input'];
};

/** The output of our `acceptInvitationToOrganization` mutation. */
export type AcceptInvitationToOrganizationPayload = {
  __typename?: 'AcceptInvitationToOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `changePassword` mutation. */
export type ChangePasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  newPassword: Scalars['String']['input'];
  oldPassword: Scalars['String']['input'];
};

/** The output of our `changePassword` mutation. */
export type ChangePasswordPayload = {
  __typename?: 'ChangePasswordPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `confirmAccountDeletion` mutation. */
export type ConfirmAccountDeletionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
};

/** The output of our `confirmAccountDeletion` mutation. */
export type ConfirmAccountDeletionPayload = {
  __typename?: 'ConfirmAccountDeletionPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ActiveMessageRevision` mutation. */
export type CreateActiveMessageRevisionInput = {
  /** The `ActiveMessageRevision` to be created by this mutation. */
  activeMessageRevision: ActiveMessageRevisionInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** An input for mutations affecting `ActiveMessageRevision` */
export type ActiveMessageRevisionInput = {
  body?: InputMaybe<Scalars['JSON']['input']>;
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  parentRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  updateComment?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ActiveMessageRevision` mutation. */
export type CreateActiveMessageRevisionPayload = {
  __typename?: 'CreateActiveMessageRevisionPayload';
  /** The `ActiveMessageRevision` that was created by this mutation. */
  activeMessageRevision: Maybe<ActiveMessageRevision>;
  /** An edge for our `ActiveMessageRevision`. May be used by Relay 1. */
  activeMessageRevisionEdge: Maybe<ActiveMessageRevisionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `ActiveMessageRevision` mutation. */
export type CreateActiveMessageRevisionPayloadActiveMessageRevisionEdgeArgs = {
  orderBy?: Array<ActiveMessageRevisionsOrderBy>;
};

/** All input for the create `CurrentMessageRevision` mutation. */
export type CreateCurrentMessageRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `CurrentMessageRevision` to be created by this mutation. */
  currentMessageRevision: CurrentMessageRevisionInput;
};

/** An input for mutations affecting `CurrentMessageRevision` */
export type CurrentMessageRevisionInput = {
  body?: InputMaybe<Scalars['JSON']['input']>;
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  parentRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  updateComment?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CurrentMessageRevision` mutation. */
export type CreateCurrentMessageRevisionPayload = {
  __typename?: 'CreateCurrentMessageRevisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `CurrentMessageRevision` that was created by this mutation. */
  currentMessageRevision: Maybe<CurrentMessageRevision>;
  /** An edge for our `CurrentMessageRevision`. May be used by Relay 1. */
  currentMessageRevisionEdge: Maybe<CurrentMessageRevisionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `CurrentMessageRevision` mutation. */
export type CreateCurrentMessageRevisionPayloadCurrentMessageRevisionEdgeArgs = {
  orderBy?: Array<CurrentMessageRevisionsOrderBy>;
};

/** All input for the create `FileRevision` mutation. */
export type CreateFileRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FileRevision` to be created by this mutation. */
  fileRevision: FileRevisionInput;
};

/** An input for mutations affecting `FileRevision` */
export type FileRevisionInput = {
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mimeType?: InputMaybe<Scalars['String']['input']>;
  parentRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  revisionId?: InputMaybe<Scalars['UUID']['input']>;
  totalBytes?: InputMaybe<Scalars['Int']['input']>;
  uploadedBytes?: InputMaybe<Scalars['Int']['input']>;
};

/** The output of our create `FileRevision` mutation. */
export type CreateFileRevisionPayload = {
  __typename?: 'CreateFileRevisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `FileRevision`. */
  editor: Maybe<User>;
  /** The `FileRevision` that was created by this mutation. */
  fileRevision: Maybe<FileRevision>;
  /** An edge for our `FileRevision`. May be used by Relay 1. */
  fileRevisionEdge: Maybe<FileRevisionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `FileRevision` mutation. */
export type CreateFileRevisionPayloadFileRevisionEdgeArgs = {
  orderBy?: Array<FileRevisionsOrderBy>;
};

/** All input for the create `MessageRevision` mutation. */
export type CreateMessageRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `MessageRevision` to be created by this mutation. */
  messageRevision: MessageRevisionInput;
};

/** An input for mutations affecting `MessageRevision` */
export type MessageRevisionInput = {
  body?: InputMaybe<Scalars['JSON']['input']>;
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  parentRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  revisionId?: InputMaybe<Scalars['UUID']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  updateComment?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `MessageRevision` mutation. */
export type CreateMessageRevisionPayload = {
  __typename?: 'CreateMessageRevisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `MessageRevision`. */
  editor: Maybe<User>;
  /** The `MessageRevision` that was created by this mutation. */
  messageRevision: Maybe<MessageRevision>;
  /** An edge for our `MessageRevision`. May be used by Relay 1. */
  messageRevisionEdge: Maybe<MessageRevisionsEdge>;
  /** Reads a single `MessageRevision` that is related to this `MessageRevision`. */
  parentRevision: Maybe<MessageRevision>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `MessageRevision` mutation. */
export type CreateMessageRevisionPayloadMessageRevisionEdgeArgs = {
  orderBy?: Array<MessageRevisionsOrderBy>;
};

/** All input for the `createOrganization` mutation. */
export type CreateOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  slug: Scalars['String']['input'];
};

/** The output of our `createOrganization` mutation. */
export type CreateOrganizationPayload = {
  __typename?: 'CreateOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our `createOrganization` mutation. */
export type CreateOrganizationPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** All input for the create `Space` mutation. */
export type CreateSpaceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Space` to be created by this mutation. */
  space: SpaceInput;
};

/** An input for mutations affecting `Space` */
export type SpaceInput = {
  creatorId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  slug: Scalars['String']['input'];
};

/** The output of our create `Space` mutation. */
export type CreateSpacePayload = {
  __typename?: 'CreateSpacePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `Space`. */
  creator: Maybe<User>;
  /** Reads a single `Organization` that is related to this `Space`. */
  organization: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Space` that was created by this mutation. */
  space: Maybe<Space>;
  /** An edge for our `Space`. May be used by Relay 1. */
  spaceEdge: Maybe<SpacesEdge>;
};


/** The output of our create `Space` mutation. */
export type CreateSpacePayloadSpaceEdgeArgs = {
  orderBy?: Array<SpacesOrderBy>;
};

/** All input for the create `SpaceItem` mutation. */
export type CreateSpaceItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SpaceItem` to be created by this mutation. */
  spaceItem: SpaceItemInput;
};

/** An input for mutations affecting `SpaceItem` */
export type SpaceItemInput = {
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  fileId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  messageId?: InputMaybe<Scalars['UUID']['input']>;
  revisionId: Scalars['UUID']['input'];
  spaceId: Scalars['UUID']['input'];
};

/** The output of our create `SpaceItem` mutation. */
export type CreateSpaceItemPayload = {
  __typename?: 'CreateSpaceItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `SpaceItem`. */
  editor: Maybe<User>;
  /** Reads a single `FileRevision` that is related to this `SpaceItem`. */
  fileRevision: Maybe<FileRevision>;
  /** Reads a single `MessageRevision` that is related to this `SpaceItem`. */
  messageRevision: Maybe<MessageRevision>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Space` that is related to this `SpaceItem`. */
  space: Maybe<Space>;
  /** The `SpaceItem` that was created by this mutation. */
  spaceItem: Maybe<SpaceItem>;
  /** An edge for our `SpaceItem`. May be used by Relay 1. */
  spaceItemEdge: Maybe<SpaceItemsEdge>;
};


/** The output of our create `SpaceItem` mutation. */
export type CreateSpaceItemPayloadSpaceItemEdgeArgs = {
  orderBy?: Array<SpaceItemsOrderBy>;
};

/** All input for the create `SpaceSubmission` mutation. */
export type CreateSpaceSubmissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SpaceSubmission` to be created by this mutation. */
  spaceSubmission: SpaceSubmissionInput;
};

/** An input for mutations affecting `SpaceSubmission` */
export type SpaceSubmissionInput = {
  fileId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  messageId?: InputMaybe<Scalars['UUID']['input']>;
  revisionId: Scalars['UUID']['input'];
  spaceItemId: Scalars['UUID']['input'];
  submitterId?: InputMaybe<Scalars['UUID']['input']>;
};

/** The output of our create `SpaceSubmission` mutation. */
export type CreateSpaceSubmissionPayload = {
  __typename?: 'CreateSpaceSubmissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `FileRevision` that is related to this `SpaceSubmission`. */
  fileRevision: Maybe<FileRevision>;
  /** Reads a single `MessageRevision` that is related to this `SpaceSubmission`. */
  messageRevision: Maybe<MessageRevision>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `SpaceItem` that is related to this `SpaceSubmission`. */
  spaceItem: Maybe<SpaceItem>;
  /** The `SpaceSubmission` that was created by this mutation. */
  spaceSubmission: Maybe<SpaceSubmission>;
  /** An edge for our `SpaceSubmission`. May be used by Relay 1. */
  spaceSubmissionEdge: Maybe<SpaceSubmissionsEdge>;
  /** Reads a single `User` that is related to this `SpaceSubmission`. */
  submitter: Maybe<User>;
};


/** The output of our create `SpaceSubmission` mutation. */
export type CreateSpaceSubmissionPayloadSpaceSubmissionEdgeArgs = {
  orderBy?: Array<SpaceSubmissionsOrderBy>;
};

/** All input for the create `SpaceSubmissionReview` mutation. */
export type CreateSpaceSubmissionReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SpaceSubmissionReview` to be created by this mutation. */
  spaceSubmissionReview: SpaceSubmissionReviewInput;
};

/** An input for mutations affecting `SpaceSubmissionReview` */
export type SpaceSubmissionReviewInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  result: ReviewResult;
  reviewerId?: InputMaybe<Scalars['UUID']['input']>;
  spaceSubmissionId: Scalars['UUID']['input'];
};

/** The output of our create `SpaceSubmissionReview` mutation. */
export type CreateSpaceSubmissionReviewPayload = {
  __typename?: 'CreateSpaceSubmissionReviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `SpaceSubmissionReview`. */
  reviewer: Maybe<User>;
  /** Reads a single `SpaceSubmission` that is related to this `SpaceSubmissionReview`. */
  spaceSubmission: Maybe<SpaceSubmission>;
  /** The `SpaceSubmissionReview` that was created by this mutation. */
  spaceSubmissionReview: Maybe<SpaceSubmissionReview>;
  /** An edge for our `SpaceSubmissionReview`. May be used by Relay 1. */
  spaceSubmissionReviewEdge: Maybe<SpaceSubmissionReviewsEdge>;
};


/** The output of our create `SpaceSubmissionReview` mutation. */
export type CreateSpaceSubmissionReviewPayloadSpaceSubmissionReviewEdgeArgs = {
  orderBy?: Array<SpaceSubmissionReviewsOrderBy>;
};

/** All input for the create `SpaceSubscription` mutation. */
export type CreateSpaceSubscriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SpaceSubscription` to be created by this mutation. */
  spaceSubscription: SpaceSubscriptionInput;
};

/** An input for mutations affecting `SpaceSubscription` */
export type SpaceSubscriptionInput = {
  abilities?: InputMaybe<Array<InputMaybe<Ability>>>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isReceivingNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  lastVisitAt?: InputMaybe<Scalars['Datetime']['input']>;
  spaceId?: InputMaybe<Scalars['UUID']['input']>;
  subscriberId?: InputMaybe<Scalars['UUID']['input']>;
};

/** The output of our create `SpaceSubscription` mutation. */
export type CreateSpaceSubscriptionPayload = {
  __typename?: 'CreateSpaceSubscriptionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Space` that is related to this `SpaceSubscription`. */
  space: Maybe<Space>;
  /** The `SpaceSubscription` that was created by this mutation. */
  spaceSubscription: Maybe<SpaceSubscription>;
  /** An edge for our `SpaceSubscription`. May be used by Relay 1. */
  spaceSubscriptionEdge: Maybe<SpaceSubscriptionsEdge>;
  /** Reads a single `User` that is related to this `SpaceSubscription`. */
  subscriber: Maybe<User>;
};


/** The output of our create `SpaceSubscription` mutation. */
export type CreateSpaceSubscriptionPayloadSpaceSubscriptionEdgeArgs = {
  orderBy?: Array<SpaceSubscriptionsOrderBy>;
};

/** All input for the create `UserEmail` mutation. */
export type CreateUserEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserEmail` to be created by this mutation. */
  userEmail: UserEmailInput;
};

/** An input for mutations affecting `UserEmail` */
export type UserEmailInput = {
  /** The users email address, in `a@b.c` format. */
  email: Scalars['String']['input'];
};

/** The output of our create `UserEmail` mutation. */
export type CreateUserEmailPayload = {
  __typename?: 'CreateUserEmailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  /** The `UserEmail` that was created by this mutation. */
  userEmail: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  userEmailEdge: Maybe<UserEmailsEdge>;
};


/** The output of our create `UserEmail` mutation. */
export type CreateUserEmailPayloadUserEmailEdgeArgs = {
  orderBy?: Array<UserEmailsOrderBy>;
};

/** All input for the `deleteActiveMessageRevision` mutation. */
export type DeleteActiveMessageRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  revisionId: Scalars['UUID']['input'];
};

/** The output of our delete `ActiveMessageRevision` mutation. */
export type DeleteActiveMessageRevisionPayload = {
  __typename?: 'DeleteActiveMessageRevisionPayload';
  /** The `ActiveMessageRevision` that was deleted by this mutation. */
  activeMessageRevision: Maybe<ActiveMessageRevision>;
  /** An edge for our `ActiveMessageRevision`. May be used by Relay 1. */
  activeMessageRevisionEdge: Maybe<ActiveMessageRevisionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedActiveMessageRevisionNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `ActiveMessageRevision` mutation. */
export type DeleteActiveMessageRevisionPayloadActiveMessageRevisionEdgeArgs = {
  orderBy?: Array<ActiveMessageRevisionsOrderBy>;
};

/** All input for the `deleteActiveMessageRevisionByNodeId` mutation. */
export type DeleteActiveMessageRevisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActiveMessageRevision` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteCurrentMessageRevision` mutation. */
export type DeleteCurrentMessageRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `CurrentMessageRevision` mutation. */
export type DeleteCurrentMessageRevisionPayload = {
  __typename?: 'DeleteCurrentMessageRevisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `CurrentMessageRevision` that was deleted by this mutation. */
  currentMessageRevision: Maybe<CurrentMessageRevision>;
  /** An edge for our `CurrentMessageRevision`. May be used by Relay 1. */
  currentMessageRevisionEdge: Maybe<CurrentMessageRevisionsEdge>;
  deletedCurrentMessageRevisionNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `CurrentMessageRevision` mutation. */
export type DeleteCurrentMessageRevisionPayloadCurrentMessageRevisionEdgeArgs = {
  orderBy?: Array<CurrentMessageRevisionsOrderBy>;
};

/** All input for the `deleteCurrentMessageRevisionByNodeId` mutation. */
export type DeleteCurrentMessageRevisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CurrentMessageRevision` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFileRevision` mutation. */
export type DeleteFileRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  revisionId: Scalars['UUID']['input'];
};

/** The output of our delete `FileRevision` mutation. */
export type DeleteFileRevisionPayload = {
  __typename?: 'DeleteFileRevisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedFileRevisionNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `User` that is related to this `FileRevision`. */
  editor: Maybe<User>;
  /** The `FileRevision` that was deleted by this mutation. */
  fileRevision: Maybe<FileRevision>;
  /** An edge for our `FileRevision`. May be used by Relay 1. */
  fileRevisionEdge: Maybe<FileRevisionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `FileRevision` mutation. */
export type DeleteFileRevisionPayloadFileRevisionEdgeArgs = {
  orderBy?: Array<FileRevisionsOrderBy>;
};

/** All input for the `deleteFileRevisionByNodeId` mutation. */
export type DeleteFileRevisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FileRevision` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFileRevisionByRevisionId` mutation. */
export type DeleteFileRevisionByRevisionIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  revisionId: Scalars['UUID']['input'];
};

/** All input for the `deleteMessageRevision` mutation. */
export type DeleteMessageRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  revisionId: Scalars['UUID']['input'];
};

/** The output of our delete `MessageRevision` mutation. */
export type DeleteMessageRevisionPayload = {
  __typename?: 'DeleteMessageRevisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedMessageRevisionNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `User` that is related to this `MessageRevision`. */
  editor: Maybe<User>;
  /** The `MessageRevision` that was deleted by this mutation. */
  messageRevision: Maybe<MessageRevision>;
  /** An edge for our `MessageRevision`. May be used by Relay 1. */
  messageRevisionEdge: Maybe<MessageRevisionsEdge>;
  /** Reads a single `MessageRevision` that is related to this `MessageRevision`. */
  parentRevision: Maybe<MessageRevision>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `MessageRevision` mutation. */
export type DeleteMessageRevisionPayloadMessageRevisionEdgeArgs = {
  orderBy?: Array<MessageRevisionsOrderBy>;
};

/** All input for the `deleteMessageRevisionByNodeId` mutation. */
export type DeleteMessageRevisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `MessageRevision` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteMessageRevisionByRevisionId` mutation. */
export type DeleteMessageRevisionByRevisionIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  revisionId: Scalars['UUID']['input'];
};

/** All input for the `deleteOrganization` mutation. */
export type DeleteOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
};

/** The output of our `deleteOrganization` mutation. */
export type DeleteOrganizationPayload = {
  __typename?: 'DeleteOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteSpace` mutation. */
export type DeleteSpaceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Space` mutation. */
export type DeleteSpacePayload = {
  __typename?: 'DeleteSpacePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `Space`. */
  creator: Maybe<User>;
  deletedSpaceNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `Space`. */
  organization: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Space` that was deleted by this mutation. */
  space: Maybe<Space>;
  /** An edge for our `Space`. May be used by Relay 1. */
  spaceEdge: Maybe<SpacesEdge>;
};


/** The output of our delete `Space` mutation. */
export type DeleteSpacePayloadSpaceEdgeArgs = {
  orderBy?: Array<SpacesOrderBy>;
};

/** All input for the `deleteSpaceByNodeId` mutation. */
export type DeleteSpaceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Space` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSpaceByOrganizationIdAndSlug` mutation. */
export type DeleteSpaceByOrganizationIdAndSlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  slug: Scalars['String']['input'];
};

/** All input for the `deleteSpaceItem` mutation. */
export type DeleteSpaceItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `SpaceItem` mutation. */
export type DeleteSpaceItemPayload = {
  __typename?: 'DeleteSpaceItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedSpaceItemNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `User` that is related to this `SpaceItem`. */
  editor: Maybe<User>;
  /** Reads a single `FileRevision` that is related to this `SpaceItem`. */
  fileRevision: Maybe<FileRevision>;
  /** Reads a single `MessageRevision` that is related to this `SpaceItem`. */
  messageRevision: Maybe<MessageRevision>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Space` that is related to this `SpaceItem`. */
  space: Maybe<Space>;
  /** The `SpaceItem` that was deleted by this mutation. */
  spaceItem: Maybe<SpaceItem>;
  /** An edge for our `SpaceItem`. May be used by Relay 1. */
  spaceItemEdge: Maybe<SpaceItemsEdge>;
};


/** The output of our delete `SpaceItem` mutation. */
export type DeleteSpaceItemPayloadSpaceItemEdgeArgs = {
  orderBy?: Array<SpaceItemsOrderBy>;
};

/** All input for the `deleteSpaceItemByNodeId` mutation. */
export type DeleteSpaceItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SpaceItem` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSpaceSubmission` mutation. */
export type DeleteSpaceSubmissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `SpaceSubmission` mutation. */
export type DeleteSpaceSubmissionPayload = {
  __typename?: 'DeleteSpaceSubmissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedSpaceSubmissionNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `FileRevision` that is related to this `SpaceSubmission`. */
  fileRevision: Maybe<FileRevision>;
  /** Reads a single `MessageRevision` that is related to this `SpaceSubmission`. */
  messageRevision: Maybe<MessageRevision>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `SpaceItem` that is related to this `SpaceSubmission`. */
  spaceItem: Maybe<SpaceItem>;
  /** The `SpaceSubmission` that was deleted by this mutation. */
  spaceSubmission: Maybe<SpaceSubmission>;
  /** An edge for our `SpaceSubmission`. May be used by Relay 1. */
  spaceSubmissionEdge: Maybe<SpaceSubmissionsEdge>;
  /** Reads a single `User` that is related to this `SpaceSubmission`. */
  submitter: Maybe<User>;
};


/** The output of our delete `SpaceSubmission` mutation. */
export type DeleteSpaceSubmissionPayloadSpaceSubmissionEdgeArgs = {
  orderBy?: Array<SpaceSubmissionsOrderBy>;
};

/** All input for the `deleteSpaceSubmissionByNodeId` mutation. */
export type DeleteSpaceSubmissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SpaceSubmission` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSpaceSubmissionReview` mutation. */
export type DeleteSpaceSubmissionReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  spaceSubmissionId: Scalars['UUID']['input'];
};

/** The output of our delete `SpaceSubmissionReview` mutation. */
export type DeleteSpaceSubmissionReviewPayload = {
  __typename?: 'DeleteSpaceSubmissionReviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedSpaceSubmissionReviewNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `SpaceSubmissionReview`. */
  reviewer: Maybe<User>;
  /** Reads a single `SpaceSubmission` that is related to this `SpaceSubmissionReview`. */
  spaceSubmission: Maybe<SpaceSubmission>;
  /** The `SpaceSubmissionReview` that was deleted by this mutation. */
  spaceSubmissionReview: Maybe<SpaceSubmissionReview>;
  /** An edge for our `SpaceSubmissionReview`. May be used by Relay 1. */
  spaceSubmissionReviewEdge: Maybe<SpaceSubmissionReviewsEdge>;
};


/** The output of our delete `SpaceSubmissionReview` mutation. */
export type DeleteSpaceSubmissionReviewPayloadSpaceSubmissionReviewEdgeArgs = {
  orderBy?: Array<SpaceSubmissionReviewsOrderBy>;
};

/** All input for the `deleteSpaceSubmissionReviewByNodeId` mutation. */
export type DeleteSpaceSubmissionReviewByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SpaceSubmissionReview` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSpaceSubscription` mutation. */
export type DeleteSpaceSubscriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `SpaceSubscription` mutation. */
export type DeleteSpaceSubscriptionPayload = {
  __typename?: 'DeleteSpaceSubscriptionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedSpaceSubscriptionNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Space` that is related to this `SpaceSubscription`. */
  space: Maybe<Space>;
  /** The `SpaceSubscription` that was deleted by this mutation. */
  spaceSubscription: Maybe<SpaceSubscription>;
  /** An edge for our `SpaceSubscription`. May be used by Relay 1. */
  spaceSubscriptionEdge: Maybe<SpaceSubscriptionsEdge>;
  /** Reads a single `User` that is related to this `SpaceSubscription`. */
  subscriber: Maybe<User>;
};


/** The output of our delete `SpaceSubscription` mutation. */
export type DeleteSpaceSubscriptionPayloadSpaceSubscriptionEdgeArgs = {
  orderBy?: Array<SpaceSubscriptionsOrderBy>;
};

/** All input for the `deleteSpaceSubscriptionByNodeId` mutation. */
export type DeleteSpaceSubscriptionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SpaceSubscription` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSpaceSubscriptionBySubscriberIdAndSpaceId` mutation. */
export type DeleteSpaceSubscriptionBySubscriberIdAndSpaceIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  spaceId: Scalars['UUID']['input'];
  subscriberId: Scalars['UUID']['input'];
};

/** All input for the `deleteUserAuthentication` mutation. */
export type DeleteUserAuthenticationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `UserAuthentication` mutation. */
export type DeleteUserAuthenticationPayload = {
  __typename?: 'DeleteUserAuthenticationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedUserAuthenticationNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserAuthentication`. */
  user: Maybe<User>;
  /** The `UserAuthentication` that was deleted by this mutation. */
  userAuthentication: Maybe<UserAuthentication>;
  /** An edge for our `UserAuthentication`. May be used by Relay 1. */
  userAuthenticationEdge: Maybe<UserAuthenticationsEdge>;
};


/** The output of our delete `UserAuthentication` mutation. */
export type DeleteUserAuthenticationPayloadUserAuthenticationEdgeArgs = {
  orderBy?: Array<UserAuthenticationsOrderBy>;
};

/** All input for the `deleteUserAuthenticationByNodeId` mutation. */
export type DeleteUserAuthenticationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserAuthentication` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserAuthenticationByServiceAndIdentifier` mutation. */
export type DeleteUserAuthenticationByServiceAndIdentifierInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the user within the login service. */
  identifier: Scalars['String']['input'];
  /** The login service used, e.g. `twitter` or `github`. */
  service: Scalars['String']['input'];
};

/** All input for the `deleteUserEmail` mutation. */
export type DeleteUserEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `UserEmail` mutation. */
export type DeleteUserEmailPayload = {
  __typename?: 'DeleteUserEmailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedUserEmailNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  /** The `UserEmail` that was deleted by this mutation. */
  userEmail: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  userEmailEdge: Maybe<UserEmailsEdge>;
};


/** The output of our delete `UserEmail` mutation. */
export type DeleteUserEmailPayloadUserEmailEdgeArgs = {
  orderBy?: Array<UserEmailsOrderBy>;
};

/** All input for the `deleteUserEmailByNodeId` mutation. */
export type DeleteUserEmailByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserEmail` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserEmailByUserIdAndEmail` mutation. */
export type DeleteUserEmailByUserIdAndEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The users email address, in `a@b.c` format. */
  email: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};

/** All input for the `forgotPassword` mutation. */
export type ForgotPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
};

/** The output of our `forgotPassword` mutation. */
export type ForgotPasswordPayload = {
  __typename?: 'ForgotPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `inviteToOrganization` mutation. */
export type InviteToOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  username?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `inviteToOrganization` mutation. */
export type InviteToOrganizationPayload = {
  __typename?: 'InviteToOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type LoginInput = {
  password: Scalars['String']['input'];
  username: Scalars['String']['input'];
};

export type LoginPayload = {
  __typename?: 'LoginPayload';
  user: User;
};

export type LogoutPayload = {
  __typename?: 'LogoutPayload';
  success: Maybe<Scalars['Boolean']['output']>;
};

/** All input for the `makeEmailPrimary` mutation. */
export type MakeEmailPrimaryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  emailId: Scalars['UUID']['input'];
};

/** The output of our `makeEmailPrimary` mutation. */
export type MakeEmailPrimaryPayload = {
  __typename?: 'MakeEmailPrimaryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  userEmail: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  userEmailEdge: Maybe<UserEmailsEdge>;
};


/** The output of our `makeEmailPrimary` mutation. */
export type MakeEmailPrimaryPayloadUserEmailEdgeArgs = {
  orderBy?: Array<UserEmailsOrderBy>;
};

export type RegisterInput = {
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  password: Scalars['String']['input'];
  username: Scalars['String']['input'];
};

export type RegisterPayload = {
  __typename?: 'RegisterPayload';
  user: User;
};

/** All input for the `removeFromOrganization` mutation. */
export type RemoveFromOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** The output of our `removeFromOrganization` mutation. */
export type RemoveFromOrganizationPayload = {
  __typename?: 'RemoveFromOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `requestAccountDeletion` mutation. */
export type RequestAccountDeletionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `requestAccountDeletion` mutation. */
export type RequestAccountDeletionPayload = {
  __typename?: 'RequestAccountDeletionPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `resendEmailVerificationCode` mutation. */
export type ResendEmailVerificationCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  emailId: Scalars['UUID']['input'];
};

/** The output of our `resendEmailVerificationCode` mutation. */
export type ResendEmailVerificationCodePayload = {
  __typename?: 'ResendEmailVerificationCodePayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `resetPassword` mutation. */
export type ResetPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  newPassword: Scalars['String']['input'];
  resetToken: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};

/** The output of our `resetPassword` mutation. */
export type ResetPasswordPayload = {
  __typename?: 'ResetPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  success: Maybe<Scalars['Boolean']['output']>;
};

/** All input for the `transferOrganizationBillingContact` mutation. */
export type TransferOrganizationBillingContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** The output of our `transferOrganizationBillingContact` mutation. */
export type TransferOrganizationBillingContactPayload = {
  __typename?: 'TransferOrganizationBillingContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our `transferOrganizationBillingContact` mutation. */
export type TransferOrganizationBillingContactPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** All input for the `transferOrganizationOwnership` mutation. */
export type TransferOrganizationOwnershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** The output of our `transferOrganizationOwnership` mutation. */
export type TransferOrganizationOwnershipPayload = {
  __typename?: 'TransferOrganizationOwnershipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our `transferOrganizationOwnership` mutation. */
export type TransferOrganizationOwnershipPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** All input for the `updateActiveMessageRevision` mutation. */
export type UpdateActiveMessageRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `ActiveMessageRevision` being updated. */
  patch: ActiveMessageRevisionPatch;
  revisionId: Scalars['UUID']['input'];
};

/** Represents an update to a `ActiveMessageRevision`. Fields that are set will be updated. */
export type ActiveMessageRevisionPatch = {
  body?: InputMaybe<Scalars['JSON']['input']>;
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  updateComment?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `ActiveMessageRevision` mutation. */
export type UpdateActiveMessageRevisionPayload = {
  __typename?: 'UpdateActiveMessageRevisionPayload';
  /** The `ActiveMessageRevision` that was updated by this mutation. */
  activeMessageRevision: Maybe<ActiveMessageRevision>;
  /** An edge for our `ActiveMessageRevision`. May be used by Relay 1. */
  activeMessageRevisionEdge: Maybe<ActiveMessageRevisionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `ActiveMessageRevision` mutation. */
export type UpdateActiveMessageRevisionPayloadActiveMessageRevisionEdgeArgs = {
  orderBy?: Array<ActiveMessageRevisionsOrderBy>;
};

/** All input for the `updateActiveMessageRevisionByNodeId` mutation. */
export type UpdateActiveMessageRevisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActiveMessageRevision` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ActiveMessageRevision` being updated. */
  patch: ActiveMessageRevisionPatch;
};

/** All input for the `updateCurrentMessageRevision` mutation. */
export type UpdateCurrentMessageRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `CurrentMessageRevision` being updated. */
  patch: CurrentMessageRevisionPatch;
};

/** Represents an update to a `CurrentMessageRevision`. Fields that are set will be updated. */
export type CurrentMessageRevisionPatch = {
  body?: InputMaybe<Scalars['JSON']['input']>;
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  updateComment?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `CurrentMessageRevision` mutation. */
export type UpdateCurrentMessageRevisionPayload = {
  __typename?: 'UpdateCurrentMessageRevisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `CurrentMessageRevision` that was updated by this mutation. */
  currentMessageRevision: Maybe<CurrentMessageRevision>;
  /** An edge for our `CurrentMessageRevision`. May be used by Relay 1. */
  currentMessageRevisionEdge: Maybe<CurrentMessageRevisionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `CurrentMessageRevision` mutation. */
export type UpdateCurrentMessageRevisionPayloadCurrentMessageRevisionEdgeArgs = {
  orderBy?: Array<CurrentMessageRevisionsOrderBy>;
};

/** All input for the `updateCurrentMessageRevisionByNodeId` mutation. */
export type UpdateCurrentMessageRevisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CurrentMessageRevision` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `CurrentMessageRevision` being updated. */
  patch: CurrentMessageRevisionPatch;
};

/** All input for the `updateFileRevision` mutation. */
export type UpdateFileRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `FileRevision` being updated. */
  patch: FileRevisionPatch;
  revisionId: Scalars['UUID']['input'];
};

/** Represents an update to a `FileRevision`. Fields that are set will be updated. */
export type FileRevisionPatch = {
  filename?: InputMaybe<Scalars['String']['input']>;
  mimeType?: InputMaybe<Scalars['String']['input']>;
  totalBytes?: InputMaybe<Scalars['Int']['input']>;
  uploadedBytes?: InputMaybe<Scalars['Int']['input']>;
};

/** The output of our update `FileRevision` mutation. */
export type UpdateFileRevisionPayload = {
  __typename?: 'UpdateFileRevisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `FileRevision`. */
  editor: Maybe<User>;
  /** The `FileRevision` that was updated by this mutation. */
  fileRevision: Maybe<FileRevision>;
  /** An edge for our `FileRevision`. May be used by Relay 1. */
  fileRevisionEdge: Maybe<FileRevisionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `FileRevision` mutation. */
export type UpdateFileRevisionPayloadFileRevisionEdgeArgs = {
  orderBy?: Array<FileRevisionsOrderBy>;
};

/** All input for the `updateFileRevisionByNodeId` mutation. */
export type UpdateFileRevisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FileRevision` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FileRevision` being updated. */
  patch: FileRevisionPatch;
};

/** All input for the `updateFileRevisionByRevisionId` mutation. */
export type UpdateFileRevisionByRevisionIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `FileRevision` being updated. */
  patch: FileRevisionPatch;
  revisionId: Scalars['UUID']['input'];
};

/** All input for the `updateMessageRevision` mutation. */
export type UpdateMessageRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `MessageRevision` being updated. */
  patch: MessageRevisionPatch;
  revisionId: Scalars['UUID']['input'];
};

/** Represents an update to a `MessageRevision`. Fields that are set will be updated. */
export type MessageRevisionPatch = {
  body?: InputMaybe<Scalars['JSON']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  updateComment?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `MessageRevision` mutation. */
export type UpdateMessageRevisionPayload = {
  __typename?: 'UpdateMessageRevisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `MessageRevision`. */
  editor: Maybe<User>;
  /** The `MessageRevision` that was updated by this mutation. */
  messageRevision: Maybe<MessageRevision>;
  /** An edge for our `MessageRevision`. May be used by Relay 1. */
  messageRevisionEdge: Maybe<MessageRevisionsEdge>;
  /** Reads a single `MessageRevision` that is related to this `MessageRevision`. */
  parentRevision: Maybe<MessageRevision>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `MessageRevision` mutation. */
export type UpdateMessageRevisionPayloadMessageRevisionEdgeArgs = {
  orderBy?: Array<MessageRevisionsOrderBy>;
};

/** All input for the `updateMessageRevisionByNodeId` mutation. */
export type UpdateMessageRevisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `MessageRevision` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `MessageRevision` being updated. */
  patch: MessageRevisionPatch;
};

/** All input for the `updateMessageRevisionByRevisionId` mutation. */
export type UpdateMessageRevisionByRevisionIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `MessageRevision` being updated. */
  patch: MessageRevisionPatch;
  revisionId: Scalars['UUID']['input'];
};

/** All input for the `updateOrganization` mutation. */
export type UpdateOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Organization` being updated. */
  patch: OrganizationPatch;
};

/** Represents an update to a `Organization`. Fields that are set will be updated. */
export type OrganizationPatch = {
  name?: InputMaybe<Scalars['String']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `Organization` mutation. */
export type UpdateOrganizationPayload = {
  __typename?: 'UpdateOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Organization` that was updated by this mutation. */
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Organization` mutation. */
export type UpdateOrganizationPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** All input for the `updateOrganizationByNodeId` mutation. */
export type UpdateOrganizationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Organization` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Organization` being updated. */
  patch: OrganizationPatch;
};

/** All input for the `updateOrganizationBySlug` mutation. */
export type UpdateOrganizationBySlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Organization` being updated. */
  patch: OrganizationPatch;
  slug: Scalars['String']['input'];
};

/** All input for the `updateSpace` mutation. */
export type UpdateSpaceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Space` being updated. */
  patch: SpacePatch;
};

/** Represents an update to a `Space`. Fields that are set will be updated. */
export type SpacePatch = {
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `Space` mutation. */
export type UpdateSpacePayload = {
  __typename?: 'UpdateSpacePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `Space`. */
  creator: Maybe<User>;
  /** Reads a single `Organization` that is related to this `Space`. */
  organization: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Space` that was updated by this mutation. */
  space: Maybe<Space>;
  /** An edge for our `Space`. May be used by Relay 1. */
  spaceEdge: Maybe<SpacesEdge>;
};


/** The output of our update `Space` mutation. */
export type UpdateSpacePayloadSpaceEdgeArgs = {
  orderBy?: Array<SpacesOrderBy>;
};

/** All input for the `updateSpaceByNodeId` mutation. */
export type UpdateSpaceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Space` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Space` being updated. */
  patch: SpacePatch;
};

/** All input for the `updateSpaceByOrganizationIdAndSlug` mutation. */
export type UpdateSpaceByOrganizationIdAndSlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Space` being updated. */
  patch: SpacePatch;
  slug: Scalars['String']['input'];
};

/** All input for the `updateSpaceItem` mutation. */
export type UpdateSpaceItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `SpaceItem` being updated. */
  patch: SpaceItemPatch;
};

/** Represents an update to a `SpaceItem`. Fields that are set will be updated. */
export type SpaceItemPatch = {
  editorId?: InputMaybe<Scalars['UUID']['input']>;
  revisionId?: InputMaybe<Scalars['UUID']['input']>;
};

/** The output of our update `SpaceItem` mutation. */
export type UpdateSpaceItemPayload = {
  __typename?: 'UpdateSpaceItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `SpaceItem`. */
  editor: Maybe<User>;
  /** Reads a single `FileRevision` that is related to this `SpaceItem`. */
  fileRevision: Maybe<FileRevision>;
  /** Reads a single `MessageRevision` that is related to this `SpaceItem`. */
  messageRevision: Maybe<MessageRevision>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Space` that is related to this `SpaceItem`. */
  space: Maybe<Space>;
  /** The `SpaceItem` that was updated by this mutation. */
  spaceItem: Maybe<SpaceItem>;
  /** An edge for our `SpaceItem`. May be used by Relay 1. */
  spaceItemEdge: Maybe<SpaceItemsEdge>;
};


/** The output of our update `SpaceItem` mutation. */
export type UpdateSpaceItemPayloadSpaceItemEdgeArgs = {
  orderBy?: Array<SpaceItemsOrderBy>;
};

/** All input for the `updateSpaceItemByNodeId` mutation. */
export type UpdateSpaceItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SpaceItem` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SpaceItem` being updated. */
  patch: SpaceItemPatch;
};

/** All input for the `updateSpaceSubmissionReview` mutation. */
export type UpdateSpaceSubmissionReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `SpaceSubmissionReview` being updated. */
  patch: SpaceSubmissionReviewPatch;
  spaceSubmissionId: Scalars['UUID']['input'];
};

/** Represents an update to a `SpaceSubmissionReview`. Fields that are set will be updated. */
export type SpaceSubmissionReviewPatch = {
  comment?: InputMaybe<Scalars['String']['input']>;
  result?: InputMaybe<ReviewResult>;
  reviewerId?: InputMaybe<Scalars['UUID']['input']>;
};

/** The output of our update `SpaceSubmissionReview` mutation. */
export type UpdateSpaceSubmissionReviewPayload = {
  __typename?: 'UpdateSpaceSubmissionReviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `SpaceSubmissionReview`. */
  reviewer: Maybe<User>;
  /** Reads a single `SpaceSubmission` that is related to this `SpaceSubmissionReview`. */
  spaceSubmission: Maybe<SpaceSubmission>;
  /** The `SpaceSubmissionReview` that was updated by this mutation. */
  spaceSubmissionReview: Maybe<SpaceSubmissionReview>;
  /** An edge for our `SpaceSubmissionReview`. May be used by Relay 1. */
  spaceSubmissionReviewEdge: Maybe<SpaceSubmissionReviewsEdge>;
};


/** The output of our update `SpaceSubmissionReview` mutation. */
export type UpdateSpaceSubmissionReviewPayloadSpaceSubmissionReviewEdgeArgs = {
  orderBy?: Array<SpaceSubmissionReviewsOrderBy>;
};

/** All input for the `updateSpaceSubmissionReviewByNodeId` mutation. */
export type UpdateSpaceSubmissionReviewByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SpaceSubmissionReview` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SpaceSubmissionReview` being updated. */
  patch: SpaceSubmissionReviewPatch;
};

/** All input for the `updateSpaceSubscription` mutation. */
export type UpdateSpaceSubscriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `SpaceSubscription` being updated. */
  patch: SpaceSubscriptionPatch;
};

/** Represents an update to a `SpaceSubscription`. Fields that are set will be updated. */
export type SpaceSubscriptionPatch = {
  abilities?: InputMaybe<Array<InputMaybe<Ability>>>;
  isReceivingNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  lastVisitAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The output of our update `SpaceSubscription` mutation. */
export type UpdateSpaceSubscriptionPayload = {
  __typename?: 'UpdateSpaceSubscriptionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Space` that is related to this `SpaceSubscription`. */
  space: Maybe<Space>;
  /** The `SpaceSubscription` that was updated by this mutation. */
  spaceSubscription: Maybe<SpaceSubscription>;
  /** An edge for our `SpaceSubscription`. May be used by Relay 1. */
  spaceSubscriptionEdge: Maybe<SpaceSubscriptionsEdge>;
  /** Reads a single `User` that is related to this `SpaceSubscription`. */
  subscriber: Maybe<User>;
};


/** The output of our update `SpaceSubscription` mutation. */
export type UpdateSpaceSubscriptionPayloadSpaceSubscriptionEdgeArgs = {
  orderBy?: Array<SpaceSubscriptionsOrderBy>;
};

/** All input for the `updateSpaceSubscriptionByNodeId` mutation. */
export type UpdateSpaceSubscriptionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SpaceSubscription` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SpaceSubscription` being updated. */
  patch: SpaceSubscriptionPatch;
};

/** All input for the `updateSpaceSubscriptionBySubscriberIdAndSpaceId` mutation. */
export type UpdateSpaceSubscriptionBySubscriberIdAndSpaceIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `SpaceSubscription` being updated. */
  patch: SpaceSubscriptionPatch;
  spaceId: Scalars['UUID']['input'];
  subscriberId: Scalars['UUID']['input'];
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the user. */
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  /** Optional avatar URL. */
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  /** Public-facing name (or pseudonym) of the user. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Public-facing username (or 'handle') of the user. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `User` that was updated by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: Array<UsersOrderBy>;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserByUsername` mutation. */
export type UpdateUserByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  /** Public-facing username (or 'handle') of the user. */
  username: Scalars['String']['input'];
};

/** All input for the `verifyEmail` mutation. */
export type VerifyEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
  userEmailId: Scalars['UUID']['input'];
};

/** The output of our `verifyEmail` mutation. */
export type VerifyEmailPayload = {
  __typename?: 'VerifyEmailPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type ChangePasswordMutationVariables = Exact<{
  oldPassword: Scalars['String']['input'];
  newPassword: Scalars['String']['input'];
}>;


export type ChangePasswordMutation = { __typename?: 'Mutation', changePassword: { __typename?: 'ChangePasswordPayload', success: boolean | null } | null };

export type CreateMessageRevisionMutationVariables = Exact<{
  payload: MessageRevisionInput;
}>;


export type CreateMessageRevisionMutation = { __typename?: 'Mutation', createMessageRevision: { __typename?: 'CreateMessageRevisionPayload', messageRevision: { __typename?: 'MessageRevision', id: string, revisionId: string, createdAt: string } | null } | null };

export type CreateSpaceItemMutationVariables = Exact<{
  payload: SpaceItemInput;
}>;


export type CreateSpaceItemMutation = { __typename?: 'Mutation', createSpaceItem: { __typename?: 'CreateSpaceItemPayload', space: { __typename?: 'Space', id: string } | null, spaceItem: { __typename?: 'SpaceItem', id: string, createdAt: string, fileId: string | null, messageId: string | null, revisionId: string } | null } | null };

export type CreateSpaceSubmissionReviewMutationVariables = Exact<{
  payload: SpaceSubmissionReviewInput;
}>;


export type CreateSpaceSubmissionReviewMutation = { __typename?: 'Mutation', createSpaceSubmissionReview: { __typename?: 'CreateSpaceSubmissionReviewPayload', spaceSubmissionReview: { __typename?: 'SpaceSubmissionReview', spaceSubmissionId: string, result: ReviewResult, createdAt: string, spaceSubmission: { __typename?: 'SpaceSubmission', id: string } | null } | null } | null };

export type CreateSpaceSubmissionMutationVariables = Exact<{
  payload: SpaceSubmissionInput;
}>;


export type CreateSpaceSubmissionMutation = { __typename?: 'Mutation', createSpaceSubmission: { __typename?: 'CreateSpaceSubmissionPayload', spaceItem: { __typename?: 'SpaceItem', id: string } | null, spaceSubmission: { __typename?: 'SpaceSubmission', id: string, fileId: string | null, messageId: string | null, revisionId: string, submittedAt: string } | null } | null };

export type CreateSpaceMutationVariables = Exact<{
  space: SpaceInput;
}>;


export type CreateSpaceMutation = { __typename?: 'Mutation', createSpace: { __typename?: 'CreateSpacePayload', space: { __typename?: 'Space', id: string } | null } | null };

export type CurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUserQuery = { __typename?: 'Query', currentUser: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null };

export type DeleteFileRevisionMutationVariables = Exact<{
  id: Scalars['UUID']['input'];
  revisionId: Scalars['UUID']['input'];
}>;


export type DeleteFileRevisionMutation = { __typename?: 'Mutation', deleteFileRevision: { __typename?: 'DeleteFileRevisionPayload', fileRevision: { __typename?: 'FileRevision', id: string } | null } | null };

export type DeleteMessageRevisionMutationVariables = Exact<{
  id: Scalars['UUID']['input'];
  revisionId: Scalars['UUID']['input'];
}>;


export type DeleteMessageRevisionMutation = { __typename?: 'Mutation', deleteMessageRevision: { __typename?: 'DeleteMessageRevisionPayload', messageRevision: { __typename?: 'MessageRevision', id: string } | null, parentRevision: { __typename?: 'MessageRevision', id: string } | null } | null };

export type DeleteSpaceItemMutationVariables = Exact<{
  id: Scalars['UUID']['input'];
}>;


export type DeleteSpaceItemMutation = { __typename?: 'Mutation', deleteSpaceItem: { __typename?: 'DeleteSpaceItemPayload', space: { __typename?: 'Space', id: string } | null, messageRevision: { __typename?: 'MessageRevision', id: string, revisionId: string } | null } | null };

export type DeleteSpaceSubmissionReviewMutationVariables = Exact<{
  spaceSubmissionId: Scalars['UUID']['input'];
}>;


export type DeleteSpaceSubmissionReviewMutation = { __typename?: 'Mutation', deleteSpaceSubmissionReview: { __typename?: 'DeleteSpaceSubmissionReviewPayload', spaceSubmission: { __typename?: 'SpaceSubmission', id: string } | null } | null };

export type DeleteSpaceSubmissionMutationVariables = Exact<{
  id: Scalars['UUID']['input'];
}>;


export type DeleteSpaceSubmissionMutation = { __typename?: 'Mutation', deleteSpaceSubmission: { __typename?: 'DeleteSpaceSubmissionPayload', spaceItem: { __typename?: 'SpaceItem', id: string } | null, messageRevision: { __typename?: 'MessageRevision', id: string, revisionId: string } | null } | null };

export type FetchSpacesQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SpaceCondition>;
  filter?: InputMaybe<SpaceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SpacesOrderBy> | SpacesOrderBy>;
}>;


export type FetchSpacesQuery = { __typename?: 'Query', spaces: { __typename?: 'SpacesConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor: any | null, endCursor: any | null }, nodes: Array<{ __typename?: 'Space', id: string, name: string, createdAt: string, isPublic: boolean }> } | null };

export type GetCurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCurrentUserQuery = { __typename?: 'Query', currentUser: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null, userEmails: { __typename?: 'UserEmailsConnection', nodes: Array<{ __typename?: 'UserEmail', id: string, isPrimary: boolean, email: string }> } } | null };

export type GetFileRevisionByRevisionIdQueryVariables = Exact<{
  revisionId: Scalars['UUID']['input'];
}>;


export type GetFileRevisionByRevisionIdQuery = { __typename?: 'Query', fileRevisionByRevisionId: { __typename?: 'FileRevision', id: string, revisionId: string, createdAt: string, updatedAt: string } | null };

export type GetSpaceQueryVariables = Exact<{
  id: Scalars['UUID']['input'];
}>;


export type GetSpaceQuery = { __typename?: 'Query', space: { __typename?: 'Space', id: string, name: string, isPublic: boolean, items: { __typename?: 'SpaceItemsConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean }, nodes: Array<{ __typename?: 'SpaceItem', id: string, messageId: string | null, revisionId: string, fileId: string | null, isSubmitted: boolean | null, latestReviewResult: ReviewResult | null, createdAt: string, times: { __typename?: 'SpaceItemSubmissionAndApprovalTime', currentApprovalSince: string | null } | null, latestActiveSubmission: { __typename?: 'SpaceSubmission', id: string } | null, editor: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null, messageRevision: { __typename?: 'MessageRevision', id: string, body: any | null, editor: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null } | null, fileRevision: { __typename?: 'FileRevision', id: string, revisionId: string, mimeType: string | null } | null }> }, mySubscription: { __typename?: 'SpaceSubscription', id: string, allAbilities: Array<Ability | null> | null } | null, subscriptions: { __typename?: 'SpaceSubscriptionsConnection', totalCount: number, nodes: Array<{ __typename?: 'SpaceSubscription', id: string, createdAt: string, subscriber: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null }> } } | null };

export type GetUserByUsernameQueryVariables = Exact<{
  username: Scalars['String']['input'];
}>;


export type GetUserByUsernameQuery = { __typename?: 'Query', userByUsername: { __typename?: 'User', id: string, username: string } | null };

export type LoginMutationVariables = Exact<{
  username: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type LoginMutation = { __typename?: 'Mutation', login: { __typename?: 'LoginPayload', user: { __typename?: 'User', id: string, username: string } } | null };

export type LogoutMutationVariables = Exact<{ [key: string]: never; }>;


export type LogoutMutation = { __typename?: 'Mutation', logout: { __typename?: 'LogoutPayload', success: boolean | null } | null };

export type RegisterUserMutationVariables = Exact<{
  form: RegisterInput;
}>;


export type RegisterUserMutation = { __typename?: 'Mutation', register: { __typename?: 'RegisterPayload', user: { __typename?: 'User', id: string, username: string, createdAt: string } } | null };

export type ForgotPasswordMutationVariables = Exact<{
  email: Scalars['String']['input'];
}>;


export type ForgotPasswordMutation = { __typename?: 'Mutation', forgotPassword: { __typename?: 'ForgotPasswordPayload', clientMutationId: string | null } | null };

export type ResetPasswordMutationVariables = Exact<{
  id: Scalars['UUID']['input'];
  token: Scalars['String']['input'];
  newPassword: Scalars['String']['input'];
}>;


export type ResetPasswordMutation = { __typename?: 'Mutation', resetPassword: { __typename?: 'ResetPasswordPayload', success: boolean | null } | null };

export type ShortProfileFragment = { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null };

export type VerifyEmailMutationVariables = Exact<{
  id: Scalars['UUID']['input'];
  token: Scalars['String']['input'];
}>;


export type VerifyEmailMutation = { __typename?: 'Mutation', verifyEmail: { __typename?: 'VerifyEmailPayload', success: boolean | null, query: { __typename?: 'Query', currentUser: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null } | null } | null };

export const ShortProfile = gql`
    fragment ShortProfile on User {
  id
  isAdmin
  isVerified
  username
  avatarUrl
}
    `;
export const ChangePassword = gql`
    mutation ChangePassword($oldPassword: String!, $newPassword: String!) {
  changePassword(input: {oldPassword: $oldPassword, newPassword: $newPassword}) {
    success: boolean
  }
}
    `;
export const CreateMessageRevision = gql`
    mutation CreateMessageRevision($payload: MessageRevisionInput!) {
  createMessageRevision(input: {messageRevision: $payload}) {
    messageRevision {
      id
      revisionId
      createdAt
    }
  }
}
    `;
export const CreateSpaceItem = gql`
    mutation CreateSpaceItem($payload: SpaceItemInput!) {
  createSpaceItem(input: {spaceItem: $payload}) {
    space {
      id
    }
    spaceItem {
      id
      createdAt
      fileId
      messageId
      revisionId
    }
  }
}
    `;
export const CreateSpaceSubmissionReview = gql`
    mutation CreateSpaceSubmissionReview($payload: SpaceSubmissionReviewInput!) {
  createSpaceSubmissionReview(input: {spaceSubmissionReview: $payload}) {
    spaceSubmissionReview {
      spaceSubmissionId
      result
      createdAt
      spaceSubmission {
        id
      }
    }
  }
}
    `;
export const CreateSpaceSubmission = gql`
    mutation CreateSpaceSubmission($payload: SpaceSubmissionInput!) {
  createSpaceSubmission(input: {spaceSubmission: $payload}) {
    spaceItem {
      id
    }
    spaceSubmission {
      id
      fileId
      messageId
      revisionId
      submittedAt
    }
  }
}
    `;
export const CreateSpace = gql`
    mutation CreateSpace($space: SpaceInput!) {
  createSpace(input: {space: $space}) {
    space {
      id
    }
  }
}
    `;
export const CurrentUser = gql`
    query CurrentUser {
  currentUser {
    id
    ...ShortProfile
  }
}
    ${ShortProfile}`;
export const DeleteFileRevision = gql`
    mutation DeleteFileRevision($id: UUID!, $revisionId: UUID!) {
  deleteFileRevision(input: {id: $id, revisionId: $revisionId}) {
    fileRevision {
      id
    }
  }
}
    `;
export const DeleteMessageRevision = gql`
    mutation DeleteMessageRevision($id: UUID!, $revisionId: UUID!) {
  deleteMessageRevision(input: {id: $id, revisionId: $revisionId}) {
    messageRevision {
      id
    }
    parentRevision {
      id
    }
  }
}
    `;
export const DeleteSpaceItem = gql`
    mutation DeleteSpaceItem($id: UUID!) {
  deleteSpaceItem(input: {id: $id}) {
    space {
      id
    }
    messageRevision {
      id
      revisionId
    }
  }
}
    `;
export const DeleteSpaceSubmissionReview = gql`
    mutation DeleteSpaceSubmissionReview($spaceSubmissionId: UUID!) {
  deleteSpaceSubmissionReview(input: {spaceSubmissionId: $spaceSubmissionId}) {
    spaceSubmission {
      id
    }
  }
}
    `;
export const DeleteSpaceSubmission = gql`
    mutation DeleteSpaceSubmission($id: UUID!) {
  deleteSpaceSubmission(input: {id: $id}) {
    spaceItem {
      id
    }
    messageRevision {
      id
      revisionId
    }
  }
}
    `;
export const FetchSpaces = gql`
    query FetchSpaces($after: Cursor, $before: Cursor, $condition: SpaceCondition, $filter: SpaceFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [SpacesOrderBy!]) {
  spaces(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    nodes {
      id
      name
      createdAt
      isPublic
    }
  }
}
    `;
export const GetCurrentUser = gql`
    query GetCurrentUser {
  currentUser {
    id
    ...ShortProfile
    userEmails {
      nodes {
        id
        isPrimary
        email
      }
    }
  }
}
    ${ShortProfile}`;
export const GetFileRevisionByRevisionId = gql`
    query GetFileRevisionByRevisionId($revisionId: UUID!) {
  fileRevisionByRevisionId(revisionId: $revisionId) {
    id
    revisionId
    createdAt
    updatedAt
  }
}
    `;
export const GetSpace = gql`
    query GetSpace($id: UUID!) {
  space(id: $id) {
    id
    name
    isPublic
    items(orderBy: [CREATED_AT_ASC]) {
      pageInfo {
        hasNextPage
      }
      nodes {
        times {
          currentApprovalSince
        }
        id
        messageId
        revisionId
        fileId
        isSubmitted
        latestActiveSubmission {
          id
        }
        latestReviewResult
        createdAt
        editor {
          id
          ...ShortProfile
        }
        messageRevision {
          id
          editor {
            id
            ...ShortProfile
          }
          body
        }
        fileRevision {
          id
          revisionId
          mimeType
        }
      }
    }
    mySubscription {
      id
      allAbilities
    }
    subscriptions {
      totalCount
      nodes {
        id
        createdAt
        subscriber {
          id
          ...ShortProfile
        }
      }
    }
  }
}
    ${ShortProfile}`;
export const GetUserByUsername = gql`
    query GetUserByUsername($username: String!) {
  userByUsername(username: $username) {
    id
    username
  }
}
    `;
export const Login = gql`
    mutation Login($username: String!, $password: String!) {
  login(input: {username: $username, password: $password}) {
    user {
      id
      username
    }
  }
}
    `;
export const Logout = gql`
    mutation Logout {
  logout {
    success
  }
}
    `;
export const RegisterUser = gql`
    mutation RegisterUser($form: RegisterInput!) {
  register(input: $form) {
    user {
      id
      username
      createdAt
    }
  }
}
    `;
export const ForgotPassword = gql`
    mutation ForgotPassword($email: String!) {
  forgotPassword(input: {email: $email}) {
    clientMutationId
  }
}
    `;
export const ResetPassword = gql`
    mutation ResetPassword($id: UUID!, $token: String!, $newPassword: String!) {
  resetPassword(input: {userId: $id, resetToken: $token, newPassword: $newPassword}) {
    success
  }
}
    `;
export const VerifyEmail = gql`
    mutation VerifyEmail($id: UUID!, $token: String!) {
  verifyEmail(input: {userEmailId: $id, token: $token}) {
    success: boolean
    query {
      currentUser {
        id
        ...ShortProfile
      }
    }
  }
}
    ${ShortProfile}`;
export const ShortProfileFragmentDoc = gql`
    fragment ShortProfile on User {
  id
  isAdmin
  isVerified
  username
  avatarUrl
}
    `;
export const ChangePasswordDocument = gql`
    mutation ChangePassword($oldPassword: String!, $newPassword: String!) {
  changePassword(input: {oldPassword: $oldPassword, newPassword: $newPassword}) {
    success: boolean
  }
}
    `;

export function useChangePasswordMutation() {
  return Urql.useMutation<ChangePasswordMutation, ChangePasswordMutationVariables>(ChangePasswordDocument);
};
export const CreateMessageRevisionDocument = gql`
    mutation CreateMessageRevision($payload: MessageRevisionInput!) {
  createMessageRevision(input: {messageRevision: $payload}) {
    messageRevision {
      id
      revisionId
      createdAt
    }
  }
}
    `;

export function useCreateMessageRevisionMutation() {
  return Urql.useMutation<CreateMessageRevisionMutation, CreateMessageRevisionMutationVariables>(CreateMessageRevisionDocument);
};
export const CreateSpaceItemDocument = gql`
    mutation CreateSpaceItem($payload: SpaceItemInput!) {
  createSpaceItem(input: {spaceItem: $payload}) {
    space {
      id
    }
    spaceItem {
      id
      createdAt
      fileId
      messageId
      revisionId
    }
  }
}
    `;

export function useCreateSpaceItemMutation() {
  return Urql.useMutation<CreateSpaceItemMutation, CreateSpaceItemMutationVariables>(CreateSpaceItemDocument);
};
export const CreateSpaceSubmissionReviewDocument = gql`
    mutation CreateSpaceSubmissionReview($payload: SpaceSubmissionReviewInput!) {
  createSpaceSubmissionReview(input: {spaceSubmissionReview: $payload}) {
    spaceSubmissionReview {
      spaceSubmissionId
      result
      createdAt
      spaceSubmission {
        id
      }
    }
  }
}
    `;

export function useCreateSpaceSubmissionReviewMutation() {
  return Urql.useMutation<CreateSpaceSubmissionReviewMutation, CreateSpaceSubmissionReviewMutationVariables>(CreateSpaceSubmissionReviewDocument);
};
export const CreateSpaceSubmissionDocument = gql`
    mutation CreateSpaceSubmission($payload: SpaceSubmissionInput!) {
  createSpaceSubmission(input: {spaceSubmission: $payload}) {
    spaceItem {
      id
    }
    spaceSubmission {
      id
      fileId
      messageId
      revisionId
      submittedAt
    }
  }
}
    `;

export function useCreateSpaceSubmissionMutation() {
  return Urql.useMutation<CreateSpaceSubmissionMutation, CreateSpaceSubmissionMutationVariables>(CreateSpaceSubmissionDocument);
};
export const CreateSpaceDocument = gql`
    mutation CreateSpace($space: SpaceInput!) {
  createSpace(input: {space: $space}) {
    space {
      id
    }
  }
}
    `;

export function useCreateSpaceMutation() {
  return Urql.useMutation<CreateSpaceMutation, CreateSpaceMutationVariables>(CreateSpaceDocument);
};
export const CurrentUserDocument = gql`
    query CurrentUser {
  currentUser {
    id
    ...ShortProfile
  }
}
    ${ShortProfileFragmentDoc}`;

export function useCurrentUserQuery(options: Omit<Urql.UseQueryArgs<never, CurrentUserQueryVariables>, 'query'>) {
  return Urql.useQuery<CurrentUserQuery, CurrentUserQueryVariables>({ query: CurrentUserDocument, ...options });
};
export const DeleteFileRevisionDocument = gql`
    mutation DeleteFileRevision($id: UUID!, $revisionId: UUID!) {
  deleteFileRevision(input: {id: $id, revisionId: $revisionId}) {
    fileRevision {
      id
    }
  }
}
    `;

export function useDeleteFileRevisionMutation() {
  return Urql.useMutation<DeleteFileRevisionMutation, DeleteFileRevisionMutationVariables>(DeleteFileRevisionDocument);
};
export const DeleteMessageRevisionDocument = gql`
    mutation DeleteMessageRevision($id: UUID!, $revisionId: UUID!) {
  deleteMessageRevision(input: {id: $id, revisionId: $revisionId}) {
    messageRevision {
      id
    }
    parentRevision {
      id
    }
  }
}
    `;

export function useDeleteMessageRevisionMutation() {
  return Urql.useMutation<DeleteMessageRevisionMutation, DeleteMessageRevisionMutationVariables>(DeleteMessageRevisionDocument);
};
export const DeleteSpaceItemDocument = gql`
    mutation DeleteSpaceItem($id: UUID!) {
  deleteSpaceItem(input: {id: $id}) {
    space {
      id
    }
    messageRevision {
      id
      revisionId
    }
  }
}
    `;

export function useDeleteSpaceItemMutation() {
  return Urql.useMutation<DeleteSpaceItemMutation, DeleteSpaceItemMutationVariables>(DeleteSpaceItemDocument);
};
export const DeleteSpaceSubmissionReviewDocument = gql`
    mutation DeleteSpaceSubmissionReview($spaceSubmissionId: UUID!) {
  deleteSpaceSubmissionReview(input: {spaceSubmissionId: $spaceSubmissionId}) {
    spaceSubmission {
      id
    }
  }
}
    `;

export function useDeleteSpaceSubmissionReviewMutation() {
  return Urql.useMutation<DeleteSpaceSubmissionReviewMutation, DeleteSpaceSubmissionReviewMutationVariables>(DeleteSpaceSubmissionReviewDocument);
};
export const DeleteSpaceSubmissionDocument = gql`
    mutation DeleteSpaceSubmission($id: UUID!) {
  deleteSpaceSubmission(input: {id: $id}) {
    spaceItem {
      id
    }
    messageRevision {
      id
      revisionId
    }
  }
}
    `;

export function useDeleteSpaceSubmissionMutation() {
  return Urql.useMutation<DeleteSpaceSubmissionMutation, DeleteSpaceSubmissionMutationVariables>(DeleteSpaceSubmissionDocument);
};
export const FetchSpacesDocument = gql`
    query FetchSpaces($after: Cursor, $before: Cursor, $condition: SpaceCondition, $filter: SpaceFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [SpacesOrderBy!]) {
  spaces(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    nodes {
      id
      name
      createdAt
      isPublic
    }
  }
}
    `;

export function useFetchSpacesQuery(options: Omit<Urql.UseQueryArgs<never, FetchSpacesQueryVariables>, 'query'>) {
  return Urql.useQuery<FetchSpacesQuery, FetchSpacesQueryVariables>({ query: FetchSpacesDocument, ...options });
};
export const GetCurrentUserDocument = gql`
    query GetCurrentUser {
  currentUser {
    id
    ...ShortProfile
    userEmails {
      nodes {
        id
        isPrimary
        email
      }
    }
  }
}
    ${ShortProfileFragmentDoc}`;

export function useGetCurrentUserQuery(options: Omit<Urql.UseQueryArgs<never, GetCurrentUserQueryVariables>, 'query'>) {
  return Urql.useQuery<GetCurrentUserQuery, GetCurrentUserQueryVariables>({ query: GetCurrentUserDocument, ...options });
};
export const GetFileRevisionByRevisionIdDocument = gql`
    query GetFileRevisionByRevisionId($revisionId: UUID!) {
  fileRevisionByRevisionId(revisionId: $revisionId) {
    id
    revisionId
    createdAt
    updatedAt
  }
}
    `;

export function useGetFileRevisionByRevisionIdQuery(options: Omit<Urql.UseQueryArgs<never, GetFileRevisionByRevisionIdQueryVariables>, 'query'>) {
  return Urql.useQuery<GetFileRevisionByRevisionIdQuery, GetFileRevisionByRevisionIdQueryVariables>({ query: GetFileRevisionByRevisionIdDocument, ...options });
};
export const GetSpaceDocument = gql`
    query GetSpace($id: UUID!) {
  space(id: $id) {
    id
    name
    isPublic
    items(orderBy: [CREATED_AT_ASC]) {
      pageInfo {
        hasNextPage
      }
      nodes {
        times {
          currentApprovalSince
        }
        id
        messageId
        revisionId
        fileId
        isSubmitted
        latestActiveSubmission {
          id
        }
        latestReviewResult
        createdAt
        editor {
          id
          ...ShortProfile
        }
        messageRevision {
          id
          editor {
            id
            ...ShortProfile
          }
          body
        }
        fileRevision {
          id
          revisionId
          mimeType
        }
      }
    }
    mySubscription {
      id
      allAbilities
    }
    subscriptions {
      totalCount
      nodes {
        id
        createdAt
        subscriber {
          id
          ...ShortProfile
        }
      }
    }
  }
}
    ${ShortProfileFragmentDoc}`;

export function useGetSpaceQuery(options: Omit<Urql.UseQueryArgs<never, GetSpaceQueryVariables>, 'query'>) {
  return Urql.useQuery<GetSpaceQuery, GetSpaceQueryVariables>({ query: GetSpaceDocument, ...options });
};
export const GetUserByUsernameDocument = gql`
    query GetUserByUsername($username: String!) {
  userByUsername(username: $username) {
    id
    username
  }
}
    `;

export function useGetUserByUsernameQuery(options: Omit<Urql.UseQueryArgs<never, GetUserByUsernameQueryVariables>, 'query'>) {
  return Urql.useQuery<GetUserByUsernameQuery, GetUserByUsernameQueryVariables>({ query: GetUserByUsernameDocument, ...options });
};
export const LoginDocument = gql`
    mutation Login($username: String!, $password: String!) {
  login(input: {username: $username, password: $password}) {
    user {
      id
      username
    }
  }
}
    `;

export function useLoginMutation() {
  return Urql.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument);
};
export const LogoutDocument = gql`
    mutation Logout {
  logout {
    success
  }
}
    `;

export function useLogoutMutation() {
  return Urql.useMutation<LogoutMutation, LogoutMutationVariables>(LogoutDocument);
};
export const RegisterUserDocument = gql`
    mutation RegisterUser($form: RegisterInput!) {
  register(input: $form) {
    user {
      id
      username
      createdAt
    }
  }
}
    `;

export function useRegisterUserMutation() {
  return Urql.useMutation<RegisterUserMutation, RegisterUserMutationVariables>(RegisterUserDocument);
};
export const ForgotPasswordDocument = gql`
    mutation ForgotPassword($email: String!) {
  forgotPassword(input: {email: $email}) {
    clientMutationId
  }
}
    `;

export function useForgotPasswordMutation() {
  return Urql.useMutation<ForgotPasswordMutation, ForgotPasswordMutationVariables>(ForgotPasswordDocument);
};
export const ResetPasswordDocument = gql`
    mutation ResetPassword($id: UUID!, $token: String!, $newPassword: String!) {
  resetPassword(input: {userId: $id, resetToken: $token, newPassword: $newPassword}) {
    success
  }
}
    `;

export function useResetPasswordMutation() {
  return Urql.useMutation<ResetPasswordMutation, ResetPasswordMutationVariables>(ResetPasswordDocument);
};
export const VerifyEmailDocument = gql`
    mutation VerifyEmail($id: UUID!, $token: String!) {
  verifyEmail(input: {userEmailId: $id, token: $token}) {
    success: boolean
    query {
      currentUser {
        id
        ...ShortProfile
      }
    }
  }
}
    ${ShortProfileFragmentDoc}`;

export function useVerifyEmailMutation() {
  return Urql.useMutation<VerifyEmailMutation, VerifyEmailMutationVariables>(VerifyEmailDocument);
};