/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
import gql from 'graphql-tag';
import * as Urql from '@urql/vue';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: { input: string; output: string; }
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: { input: any; output: any; }
  /** Represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { input: any; output: any; }
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) and, if it has a timezone, [RFC
   * 3339](https://datatracker.ietf.org/doc/html/rfc3339) standards. Input values
   * that do not conform to both ISO 8601 and RFC 3339 may be coerced, which may lead
   * to unexpected results.
   */
  Datetime: { input: string; output: string; }
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: { input: any; output: any; }
  /** The exact time of day, does not include the date. May or may not have a timezone offset. */
  Time: { input: any; output: any; }
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /** Handy method to get the current session ID. */
  currentSessionId: Maybe<Scalars['UUID']['output']>;
  /** The currently logged in user (or null if not logged in). */
  currentUser: Maybe<User>;
  currentUserFirstOwnedOrganizationId: Maybe<Scalars['UUID']['output']>;
  /** Handy method to get the current user ID for use in RLS policies, etc; in GraphQL, use `currentUser{id}` instead. */
  currentUserId: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `Uuid`. */
  currentUserInvitedOrganizationIds: Maybe<CurrentUserInvitedOrganizationIdsConnection>;
  /** Reads and enables pagination through a set of `Uuid`. */
  currentUserMemberOrganizationIds: Maybe<CurrentUserMemberOrganizationIdsConnection>;
  fetchDraftInRoom: Maybe<RoomMessage>;
  /** Get a single `File`. */
  file: Maybe<File>;
  /** Reads a single `File` using its globally unique `ID`. */
  fileByNodeId: Maybe<File>;
  /** Reads and enables pagination through a set of `File`. */
  files: Maybe<FilesConnection>;
  /** Reads and enables pagination through a set of `TextsearchMatch`. */
  globalSearch: Maybe<TextsearchMatchesConnection>;
  /** Reads and enables pagination through a set of `RoomSubscription`. */
  myRoomSubscriptions: Maybe<RoomSubscriptionsConnection>;
  /** Reads and enables pagination through a set of `Uuid`. */
  mySubscribedRoomIds: Maybe<MySubscribedRoomIdsConnection>;
  /** Fetches an object given its globally unique `ID`. */
  node: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']['output'];
  /** Get a single `Organization`. */
  organization: Maybe<Organization>;
  /** Reads a single `Organization` using its globally unique `ID`. */
  organizationByNodeId: Maybe<Organization>;
  /** Get a single `Organization`. */
  organizationBySlug: Maybe<Organization>;
  organizationForInvitation: Maybe<Organization>;
  /** Get a single `OrganizationMembership`. */
  organizationMembership: Maybe<OrganizationMembership>;
  /** Reads a single `OrganizationMembership` using its globally unique `ID`. */
  organizationMembershipByNodeId: Maybe<OrganizationMembership>;
  /** Get a single `OrganizationMembership`. */
  organizationMembershipByOrganizationIdAndUserId: Maybe<OrganizationMembership>;
  /** Reads and enables pagination through a set of `OrganizationMembership`. */
  organizationMemberships: Maybe<OrganizationMembershipsConnection>;
  /** Reads and enables pagination through a set of `Organization`. */
  organizations: Maybe<OrganizationsConnection>;
  /** Get a single `PdfFile`. */
  pdfFile: Maybe<PdfFile>;
  /** Reads a single `PdfFile` using its globally unique `ID`. */
  pdfFileByNodeId: Maybe<PdfFile>;
  /** Reads and enables pagination through a set of `PdfFile`. */
  pdfFiles: Maybe<PdfFilesConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** Get a single `Room`. */
  room: Maybe<Room>;
  /** Reads a single `Room` using its globally unique `ID`. */
  roomByNodeId: Maybe<Room>;
  /** Get a single `RoomItem`. */
  roomItem: Maybe<RoomItem>;
  /** Get a single `RoomItemAttachment`. */
  roomItemAttachment: Maybe<RoomItemAttachment>;
  /** Reads a single `RoomItemAttachment` using its globally unique `ID`. */
  roomItemAttachmentByNodeId: Maybe<RoomItemAttachment>;
  /** Reads and enables pagination through a set of `RoomItemAttachment`. */
  roomItemAttachments: Maybe<RoomItemAttachmentsConnection>;
  /** Reads a single `RoomItem` using its globally unique `ID`. */
  roomItemByNodeId: Maybe<RoomItem>;
  /** Reads and enables pagination through a set of `RoomItem`. */
  roomItems: Maybe<RoomItemsConnection>;
  /** Get a single `RoomMessage`. */
  roomMessage: Maybe<RoomMessage>;
  /** Get a single `RoomMessageAttachment`. */
  roomMessageAttachment: Maybe<RoomMessageAttachment>;
  /** Reads a single `RoomMessageAttachment` using its globally unique `ID`. */
  roomMessageAttachmentByNodeId: Maybe<RoomMessageAttachment>;
  /** Get a single `RoomMessageAttachment`. */
  roomMessageAttachmentByTopicIdAndRoomMessageId: Maybe<RoomMessageAttachment>;
  /** Reads and enables pagination through a set of `RoomMessageAttachment`. */
  roomMessageAttachments: Maybe<RoomMessageAttachmentsConnection>;
  /** Reads a single `RoomMessage` using its globally unique `ID`. */
  roomMessageByNodeId: Maybe<RoomMessage>;
  /** Reads and enables pagination through a set of `RoomMessage`. */
  roomMessages: Maybe<RoomMessagesConnection>;
  /** Reads and enables pagination through a set of `Room`. */
  rooms: Maybe<RoomsConnection>;
  /** Get a single `RoomSubscription`. */
  roomSubscription: Maybe<RoomSubscription>;
  /** Reads a single `RoomSubscription` using its globally unique `ID`. */
  roomSubscriptionByNodeId: Maybe<RoomSubscription>;
  /** Get a single `RoomSubscription`. */
  roomSubscriptionBySubscriberIdAndRoomId: Maybe<RoomSubscription>;
  /** Reads and enables pagination through a set of `RoomSubscription`. */
  roomSubscriptions: Maybe<RoomSubscriptionsConnection>;
  /** Get a single `Topic`. */
  topic: Maybe<Topic>;
  /** Reads a single `Topic` using its globally unique `ID`. */
  topicByNodeId: Maybe<Topic>;
  /** Get a single `Topic`. */
  topicBySlugAndOrganizationId: Maybe<Topic>;
  /** Reads and enables pagination through a set of `Topic`. */
  topics: Maybe<TopicsConnection>;
  /** Get a single `User`. */
  user: Maybe<User>;
  /** Get a single `UserAuthentication`. */
  userAuthentication: Maybe<UserAuthentication>;
  /** Reads a single `UserAuthentication` using its globally unique `ID`. */
  userAuthenticationByNodeId: Maybe<UserAuthentication>;
  /** Get a single `UserAuthentication`. */
  userAuthenticationByServiceAndIdentifier: Maybe<UserAuthentication>;
  /** Reads and enables pagination through a set of `UserAuthentication`. */
  userAuthentications: Maybe<UserAuthenticationsConnection>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId: Maybe<User>;
  /** Get a single `User`. */
  userByUsername: Maybe<User>;
  /** Get a single `UserEmail`. */
  userEmail: Maybe<UserEmail>;
  /** Reads a single `UserEmail` using its globally unique `ID`. */
  userEmailByNodeId: Maybe<UserEmail>;
  /** Get a single `UserEmail`. */
  userEmailByUserIdAndEmail: Maybe<UserEmail>;
  /** Reads and enables pagination through a set of `UserEmail`. */
  userEmails: Maybe<UserEmailsConnection>;
  /** Reads and enables pagination through a set of `User`. */
  users: Maybe<UsersConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentUserInvitedOrganizationIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<UuidFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentUserMemberOrganizationIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<UuidFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFetchDraftInRoomArgs = {
  roomId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFileArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFileByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGlobalSearchArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TextsearchMatchCondition>;
  entities?: InputMaybe<Array<InputMaybe<TextsearchableEntity>>>;
  filter?: InputMaybe<TextsearchMatchFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TextsearchMatchesOrderBy>>;
  term: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMyRoomSubscriptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<RoomSubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minimumRole?: InputMaybe<RoomRole>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMySubscribedRoomIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<UuidFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  minimumRole?: InputMaybe<RoomRole>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationBySlugArgs = {
  slug: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationForInvitationArgs = {
  code?: InputMaybe<Scalars['String']['input']>;
  invitationId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationMembershipArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationMembershipByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationMembershipByOrganizationIdAndUserIdArgs = {
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationMembershipsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationMembershipCondition>;
  filter?: InputMaybe<OrganizationMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationMembershipsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPdfFileArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPdfFileByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPdfFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PdfFileCondition>;
  filter?: InputMaybe<PdfFileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PdfFilesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomItemArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomItemAttachmentArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomItemAttachmentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomItemAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomItemAttachmentCondition>;
  filter?: InputMaybe<RoomItemAttachmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomItemAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomItemByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomItemCondition>;
  filter?: InputMaybe<RoomItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomMessageArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomMessageAttachmentArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomMessageAttachmentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomMessageAttachmentByTopicIdAndRoomMessageIdArgs = {
  roomMessageId: Scalars['UUID']['input'];
  topicId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomMessageAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomMessageAttachmentCondition>;
  filter?: InputMaybe<RoomMessageAttachmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomMessageAttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomMessageByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomMessageCondition>;
  filter?: InputMaybe<RoomMessageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomMessagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomCondition>;
  filter?: InputMaybe<RoomFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomSubscriptionArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomSubscriptionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomSubscriptionBySubscriberIdAndRoomIdArgs = {
  roomId: Scalars['UUID']['input'];
  subscriberId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoomSubscriptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomSubscriptionCondition>;
  filter?: InputMaybe<RoomSubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomSubscriptionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicBySlugAndOrganizationIdArgs = {
  organizationId: Scalars['UUID']['input'];
  slug: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTopicsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TopicCondition>;
  filter?: InputMaybe<TopicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TopicsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationByServiceAndIdentifierArgs = {
  identifier: Scalars['String']['input'];
  service: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserAuthenticationCondition>;
  filter?: InputMaybe<UserAuthenticationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserAuthenticationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByUsernameArgs = {
  username: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserEmailArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserEmailByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserEmailByUserIdAndEmailArgs = {
  email: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserEmailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserEmailCondition>;
  filter?: InputMaybe<UserEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** A user who can log in to the application. */
export type User = Node & {
  __typename?: 'User';
  /** Reads and enables pagination through a set of `Topic`. */
  authoredTopics: TopicsConnection;
  /** Optional avatar URL. */
  avatarUrl: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Users can be notified about activities in the rooms they have subscribed to. This is the default setting. You can change it for each room. */
  defaultHandlingOfNotifications: NotificationSetting;
  /** Reads and enables pagination through a set of `File`. */
  filesByContributorId: FilesConnection;
  hasPassword: Maybe<Scalars['Boolean']['output']>;
  /** Unique identifier for the user. */
  id: Scalars['UUID']['output'];
  /** If true, the user has elevated privileges. */
  isAdmin: Scalars['Boolean']['output'];
  isVerified: Scalars['Boolean']['output'];
  /** Public-facing name (or pseudonym) of the user. */
  name: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `OrganizationMembership`. */
  organizationMemberships: OrganizationMembershipsConnection;
  /** Reads and enables pagination through a set of `RoomItem`. */
  roomItems: RoomItemsConnection;
  /** Reads and enables pagination through a set of `RoomMessage`. */
  roomMessagesBySenderId: RoomMessagesConnection;
  /** Reads and enables pagination through a set of `RoomSubscription`. */
  roomSubscriptionsBySubscriberId: RoomSubscriptionsConnection;
  /** If there are any delayed notifications, they are sent at this time every day. */
  sendingTimeForDeferredNotifications: Scalars['Time']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `UserAuthentication`. */
  userAuthentications: UserAuthenticationsConnection;
  /** Reads and enables pagination through a set of `UserEmail`. */
  userEmails: UserEmailsConnection;
  /** Public-facing username (or 'handle') of the user. */
  username: Scalars['String']['output'];
};


/** A user who can log in to the application. */
export type UserAuthoredTopicsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TopicCondition>;
  filter?: InputMaybe<TopicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TopicsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserFilesByContributorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};


/** A user who can log in to the application. */
export type UserOrganizationMembershipsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationMembershipCondition>;
  filter?: InputMaybe<OrganizationMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationMembershipsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserRoomItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomItemCondition>;
  filter?: InputMaybe<RoomItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomItemsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserRoomMessagesBySenderIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomMessageCondition>;
  filter?: InputMaybe<RoomMessageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomMessagesOrderBy>>;
};


/** A user who can log in to the application. */
export type UserRoomSubscriptionsBySubscriberIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomSubscriptionCondition>;
  filter?: InputMaybe<RoomSubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomSubscriptionsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserUserAuthenticationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserAuthenticationCondition>;
  filter?: InputMaybe<UserAuthenticationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserAuthenticationsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserUserEmailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserEmailCondition>;
  filter?: InputMaybe<UserEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailsOrderBy>>;
};

/** A condition to be used against `Topic` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TopicCondition = {
  /** Checks for equality with the object’s `authorId` field. */
  authorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `contentAsPlainText` field. */
  contentAsPlainText?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contentPreview` field. */
  contentPreview?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isVisibleFor` field. */
  isVisibleFor?: InputMaybe<TopicVisibility>;
  /** Checks for equality with the object’s `license` field. */
  license?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tags` field. */
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type TopicVisibility =
  | 'ORGANIZATION_MEMBERS'
  | 'PUBLIC'
  | 'SIGNED_IN_USERS';

/** A filter to be used against `Topic` object types. All fields are combined with a logical ‘and.’ */
export type TopicFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TopicFilter>>;
  /** Filter by the object’s `author` relation. */
  author?: InputMaybe<UserFilter>;
  /** A related `author` exists. */
  authorExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `authorId` field. */
  authorId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `content` field. */
  content?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `contentAsPlainText` field. */
  contentAsPlainText?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contentPreview` field. */
  contentPreview?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isVisibleFor` field. */
  isVisibleFor?: InputMaybe<TopicVisibilityFilter>;
  /** Filter by the object’s `license` field. */
  license?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TopicFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TopicFilter>>;
  /** Filter by the object’s `organization` relation. */
  organization?: InputMaybe<OrganizationFilter>;
  /** A related `organization` exists. */
  organizationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `roomItemAttachments` relation. */
  roomItemAttachments?: InputMaybe<TopicToManyRoomItemAttachmentFilter>;
  /** Some related `roomItemAttachments` exist. */
  roomItemAttachmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `roomItems` relation. */
  roomItems?: InputMaybe<TopicToManyRoomItemFilter>;
  /** Some related `roomItems` exist. */
  roomItemsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `roomMessageAttachments` relation. */
  roomMessageAttachments?: InputMaybe<TopicToManyRoomMessageAttachmentFilter>;
  /** Some related `roomMessageAttachments` exist. */
  roomMessageAttachmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `slug` field. */
  slug?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tags` field. */
  tags?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `authoredTopics` relation. */
  authoredTopics?: InputMaybe<UserToManyTopicFilter>;
  /** Some related `authoredTopics` exist. */
  authoredTopicsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `avatarUrl` field. */
  avatarUrl?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `defaultHandlingOfNotifications` field. */
  defaultHandlingOfNotifications?: InputMaybe<NotificationSettingFilter>;
  /** Filter by the object’s `filesByContributorId` relation. */
  filesByContributorId?: InputMaybe<UserToManyFileFilter>;
  /** Some related `filesByContributorId` exist. */
  filesByContributorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `hasPassword` field. */
  hasPassword?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isVerified` field. */
  isVerified?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `organizationMemberships` relation. */
  organizationMemberships?: InputMaybe<UserToManyOrganizationMembershipFilter>;
  /** Some related `organizationMemberships` exist. */
  organizationMembershipsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `roomItems` relation. */
  roomItems?: InputMaybe<UserToManyRoomItemFilter>;
  /** Some related `roomItems` exist. */
  roomItemsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `roomMessagesBySenderId` relation. */
  roomMessagesBySenderId?: InputMaybe<UserToManyRoomMessageFilter>;
  /** Some related `roomMessagesBySenderId` exist. */
  roomMessagesBySenderIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `roomSubscriptionsBySubscriberId` relation. */
  roomSubscriptionsBySubscriberId?: InputMaybe<UserToManyRoomSubscriptionFilter>;
  /** Some related `roomSubscriptionsBySubscriberId` exist. */
  roomSubscriptionsBySubscriberIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sendingTimeForDeferredNotifications` field. */
  sendingTimeForDeferredNotifications?: InputMaybe<TimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userAuthentications` relation. */
  userAuthentications?: InputMaybe<UserToManyUserAuthenticationFilter>;
  /** Some related `userAuthentications` exist. */
  userAuthenticationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userEmails` relation. */
  userEmails?: InputMaybe<UserToManyUserEmailFilter>;
  /** Some related `userEmails` exist. */
  userEmailsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
};

/** A filter to be used against many `Topic` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyTopicFilter = {
  /** Every related `Topic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TopicFilter>;
  /** No related `Topic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TopicFilter>;
  /** Some related `Topic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TopicFilter>;
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']['input']>>;
};

/** A filter to be used against NotificationSetting fields. All fields are combined with a logical ‘and.’ */
export type NotificationSettingFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<NotificationSetting>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<NotificationSetting>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<NotificationSetting>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<NotificationSetting>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<NotificationSetting>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<NotificationSetting>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<NotificationSetting>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<NotificationSetting>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<NotificationSetting>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<NotificationSetting>>;
};

export type NotificationSetting =
  | 'DEFAULT'
  | 'DEFERRED'
  | 'IMMEDIATE'
  | 'SILENCED';

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileFilter>;
};

/** A filter to be used against `File` object types. All fields are combined with a logical ‘and.’ */
export type FileFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FileFilter>>;
  /** Filter by the object’s `contributor` relation. */
  contributor?: InputMaybe<UserFilter>;
  /** A related `contributor` exists. */
  contributorExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `contributorId` field. */
  contributorId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `filename` field. */
  filename?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `mimeType` field. */
  mimeType?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FileFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FileFilter>>;
  /** Filter by the object’s `pathOnStorage` field. */
  pathOnStorage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pdfFile` relation. */
  pdfFile?: InputMaybe<PdfFileFilter>;
  /** A related `pdfFile` exists. */
  pdfFileExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `pdfFilesByThumbnailId` relation. */
  pdfFilesByThumbnailId?: InputMaybe<FileToManyPdfFileFilter>;
  /** Some related `pdfFilesByThumbnailId` exist. */
  pdfFilesByThumbnailIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `roomItemAttachments` relation. */
  roomItemAttachments?: InputMaybe<FileToManyRoomItemAttachmentFilter>;
  /** Some related `roomItemAttachments` exist. */
  roomItemAttachmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sha256` field. */
  sha256?: InputMaybe<StringFilter>;
  /** Filter by the object’s `totalBytes` field. */
  totalBytes?: InputMaybe<IntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uploadedBytes` field. */
  uploadedBytes?: InputMaybe<IntFilter>;
};

/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['UUID']['input']>>;
};

/** A filter to be used against `PdfFile` object types. All fields are combined with a logical ‘and.’ */
export type PdfFileFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PdfFileFilter>>;
  /** Filter by the object’s `contentAsPlainText` field. */
  contentAsPlainText?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `file` relation. */
  file?: InputMaybe<FileFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `metadata` field. */
  metadata?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PdfFileFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PdfFileFilter>>;
  /** Filter by the object’s `pages` field. */
  pages?: InputMaybe<IntFilter>;
  /** Filter by the object’s `thumbnail` relation. */
  thumbnail?: InputMaybe<FileFilter>;
  /** A related `thumbnail` exists. */
  thumbnailExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `thumbnailId` field. */
  thumbnailId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Contained by the specified JSON. */
  containedBy?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains the specified JSON. */
  contains?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified key. */
  containsKey?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['JSON']['input']>>;
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** A filter to be used against many `PdfFile` object types. All fields are combined with a logical ‘and.’ */
export type FileToManyPdfFileFilter = {
  /** Every related `PdfFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PdfFileFilter>;
  /** No related `PdfFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PdfFileFilter>;
  /** Some related `PdfFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PdfFileFilter>;
};

/** A filter to be used against many `RoomItemAttachment` object types. All fields are combined with a logical ‘and.’ */
export type FileToManyRoomItemAttachmentFilter = {
  /** Every related `RoomItemAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomItemAttachmentFilter>;
  /** No related `RoomItemAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomItemAttachmentFilter>;
  /** Some related `RoomItemAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomItemAttachmentFilter>;
};

/** A filter to be used against `RoomItemAttachment` object types. All fields are combined with a logical ‘and.’ */
export type RoomItemAttachmentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoomItemAttachmentFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `file` relation. */
  file?: InputMaybe<FileFilter>;
  /** A related `file` exists. */
  fileExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `fileId` field. */
  fileId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RoomItemAttachmentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoomItemAttachmentFilter>>;
  /** Filter by the object’s `roomItem` relation. */
  roomItem?: InputMaybe<RoomItemFilter>;
  /** Filter by the object’s `roomItemId` field. */
  roomItemId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `topic` relation. */
  topic?: InputMaybe<TopicFilter>;
  /** A related `topic` exists. */
  topicExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `topicId` field. */
  topicId?: InputMaybe<UuidFilter>;
};

/** A filter to be used against `RoomItem` object types. All fields are combined with a logical ‘and.’ */
export type RoomItemFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoomItemFilter>>;
  /** Filter by the object’s `children` relation. */
  children?: InputMaybe<RoomItemToManyRoomItemFilter>;
  /** Some related `children` exist. */
  childrenExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `contributedAt` field. */
  contributedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `contributor` relation. */
  contributor?: InputMaybe<UserFilter>;
  /** A related `contributor` exists. */
  contributorExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `contributorId` field. */
  contributorId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isVisibleFor` field. */
  isVisibleFor?: InputMaybe<RoomRoleFilter>;
  /** Filter by the object’s `isVisibleSince` field. */
  isVisibleSince?: InputMaybe<RoomHistoryVisibilityFilter>;
  /** Filter by the object’s `isVisibleSinceDate` field. */
  isVisibleSinceDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `messageBody` field. */
  messageBody?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RoomItemFilter>;
  /** Filter by the object’s `nthItemSinceLastVisit` field. */
  nthItemSinceLastVisit?: InputMaybe<BigIntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoomItemFilter>>;
  /** Filter by the object’s `order` field. */
  order?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `parent` relation. */
  parent?: InputMaybe<RoomItemFilter>;
  /** A related `parent` exists. */
  parentExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `parentId` field. */
  parentId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `room` relation. */
  room?: InputMaybe<RoomFilter>;
  /** Filter by the object’s `roomId` field. */
  roomId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `roomItemAttachments` relation. */
  roomItemAttachments?: InputMaybe<RoomItemToManyRoomItemAttachmentFilter>;
  /** Some related `roomItemAttachments` exist. */
  roomItemAttachmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `topic` relation. */
  topic?: InputMaybe<TopicFilter>;
  /** A related `topic` exists. */
  topicExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `topicId` field. */
  topicId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<RoomItemTypeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against many `RoomItem` object types. All fields are combined with a logical ‘and.’ */
export type RoomItemToManyRoomItemFilter = {
  /** Every related `RoomItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomItemFilter>;
  /** No related `RoomItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomItemFilter>;
  /** Some related `RoomItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomItemFilter>;
};

/** A filter to be used against RoomRole fields. All fields are combined with a logical ‘and.’ */
export type RoomRoleFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<RoomRole>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<RoomRole>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<RoomRole>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<RoomRole>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<RoomRole>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<RoomRole>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<RoomRole>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<RoomRole>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<RoomRole>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<RoomRole>>;
};

export type RoomRole =
  | 'ADMIN'
  | 'BANNED'
  | 'MEMBER'
  | 'MODERATOR'
  | 'PROSPECT'
  | 'PUBLIC';

/** A filter to be used against RoomHistoryVisibility fields. All fields are combined with a logical ‘and.’ */
export type RoomHistoryVisibilityFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<RoomHistoryVisibility>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<RoomHistoryVisibility>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<RoomHistoryVisibility>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<RoomHistoryVisibility>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<RoomHistoryVisibility>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<RoomHistoryVisibility>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<RoomHistoryVisibility>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<RoomHistoryVisibility>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<RoomHistoryVisibility>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<RoomHistoryVisibility>>;
};

export type RoomHistoryVisibility =
  | 'ALWAYS'
  | 'INVITATION'
  | 'SPECIFIED_DATE'
  | 'SUBSCRIPTION';

/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigInt']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigInt']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */
export type FloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Float']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Float']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Float']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Float']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Float']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Float']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Float']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Float']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

/** A filter to be used against `Room` object types. All fields are combined with a logical ‘and.’ */
export type RoomFilter = {
  /** Filter by the object’s `abstract` field. */
  abstract?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoomFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `draftItemsAreVisibleFor` field. */
  draftItemsAreVisibleFor?: InputMaybe<RoomRoleFilter>;
  /** Filter by the object’s `extendVisibilityOfItemsBy` field. */
  extendVisibilityOfItemsBy?: InputMaybe<IntervalFilter>;
  /** Filter by the object’s `hasSubscriptions` field. */
  hasSubscriptions?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isAnonymousPostingAllowed` field. */
  isAnonymousPostingAllowed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isVisibleFor` field. */
  isVisibleFor?: InputMaybe<RoomVisibilityFilter>;
  /** Filter by the object’s `items` relation. */
  items?: InputMaybe<RoomToManyRoomItemFilter>;
  /** Filter by the object’s `itemsAreVisibleFor` field. */
  itemsAreVisibleFor?: InputMaybe<RoomRoleFilter>;
  /** Filter by the object’s `itemsAreVisibleSince` field. */
  itemsAreVisibleSince?: InputMaybe<RoomHistoryVisibilityFilter>;
  /** Filter by the object’s `itemsAreVisibleSinceDate` field. */
  itemsAreVisibleSinceDate?: InputMaybe<DatetimeFilter>;
  /** Some related `items` exist. */
  itemsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `latestActivityAt` field. */
  latestActivityAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `latestItemContributedAt` field. */
  latestItemContributedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `messages` relation. */
  messages?: InputMaybe<RoomToManyRoomMessageFilter>;
  /** Some related `messages` exist. */
  messagesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `myFirstInteraction` field. */
  myFirstInteraction?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `mySubscriptionId` field. */
  mySubscriptionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `nItems` field. */
  nItems?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `nItemsSinceLastVisit` field. */
  nItemsSinceLastVisit?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RoomFilter>;
  /** Filter by the object’s `nSubscriptions` field. */
  nSubscriptions?: InputMaybe<BigIntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoomFilter>>;
  /** Filter by the object’s `organization` relation. */
  organization?: InputMaybe<OrganizationFilter>;
  /** A related `organization` exists. */
  organizationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `subscriptions` relation. */
  subscriptions?: InputMaybe<RoomToManyRoomSubscriptionFilter>;
  /** Some related `subscriptions` exist. */
  subscriptionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against Interval fields. All fields are combined with a logical ‘and.’ */
export type IntervalFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<IntervalInput>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<IntervalInput>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<IntervalInput>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<IntervalInput>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<IntervalInput>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<IntervalInput>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<IntervalInput>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<IntervalInput>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<IntervalInput>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<IntervalInput>>;
};

/** An interval of time that has passed where the smallest distinct unit is a second. */
export type IntervalInput = {
  /** A quantity of days. */
  days?: InputMaybe<Scalars['Int']['input']>;
  /** A quantity of hours. */
  hours?: InputMaybe<Scalars['Int']['input']>;
  /** A quantity of minutes. */
  minutes?: InputMaybe<Scalars['Int']['input']>;
  /** A quantity of months. */
  months?: InputMaybe<Scalars['Int']['input']>;
  /**
   * A quantity of seconds. This is the only non-integer field, as all the other
   * fields will dump their overflow into a smaller unit of time. Intervals don’t
   * have a smaller unit than seconds.
   */
  seconds?: InputMaybe<Scalars['Float']['input']>;
  /** A quantity of years. */
  years?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

/** A filter to be used against RoomVisibility fields. All fields are combined with a logical ‘and.’ */
export type RoomVisibilityFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<RoomVisibility>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<RoomVisibility>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<RoomVisibility>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<RoomVisibility>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<RoomVisibility>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<RoomVisibility>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<RoomVisibility>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<RoomVisibility>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<RoomVisibility>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<RoomVisibility>>;
};

export type RoomVisibility =
  | 'ORGANIZATION_MEMBERS'
  | 'PUBLIC'
  | 'SIGNED_IN_USERS'
  | 'SUBSCRIBERS';

/** A filter to be used against many `RoomItem` object types. All fields are combined with a logical ‘and.’ */
export type RoomToManyRoomItemFilter = {
  /** Every related `RoomItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomItemFilter>;
  /** No related `RoomItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomItemFilter>;
  /** Some related `RoomItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomItemFilter>;
};

/** A filter to be used against many `RoomMessage` object types. All fields are combined with a logical ‘and.’ */
export type RoomToManyRoomMessageFilter = {
  /** Every related `RoomMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomMessageFilter>;
  /** No related `RoomMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomMessageFilter>;
  /** Some related `RoomMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomMessageFilter>;
};

/** A filter to be used against `RoomMessage` object types. All fields are combined with a logical ‘and.’ */
export type RoomMessageFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoomMessageFilter>>;
  /** Filter by the object’s `answeredMessage` relation. */
  answeredMessage?: InputMaybe<RoomMessageFilter>;
  /** A related `answeredMessage` exists. */
  answeredMessageExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `answeredMessageId` field. */
  answeredMessageId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `answers` relation. */
  answers?: InputMaybe<RoomMessageToManyRoomMessageFilter>;
  /** Some related `answers` exist. */
  answersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `attachments` relation. */
  attachments?: InputMaybe<RoomMessageToManyRoomMessageAttachmentFilter>;
  /** Some related `attachments` exist. */
  attachmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `language` field. */
  language?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RoomMessageFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoomMessageFilter>>;
  /** Filter by the object’s `room` relation. */
  room?: InputMaybe<RoomFilter>;
  /** Filter by the object’s `roomId` field. */
  roomId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `sender` relation. */
  sender?: InputMaybe<UserFilter>;
  /** A related `sender` exists. */
  senderExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `senderId` field. */
  senderId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `sentAt` field. */
  sentAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against many `RoomMessage` object types. All fields are combined with a logical ‘and.’ */
export type RoomMessageToManyRoomMessageFilter = {
  /** Every related `RoomMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomMessageFilter>;
  /** No related `RoomMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomMessageFilter>;
  /** Some related `RoomMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomMessageFilter>;
};

/** A filter to be used against many `RoomMessageAttachment` object types. All fields are combined with a logical ‘and.’ */
export type RoomMessageToManyRoomMessageAttachmentFilter = {
  /** Every related `RoomMessageAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomMessageAttachmentFilter>;
  /** No related `RoomMessageAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomMessageAttachmentFilter>;
  /** Some related `RoomMessageAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomMessageAttachmentFilter>;
};

/** A filter to be used against `RoomMessageAttachment` object types. All fields are combined with a logical ‘and.’ */
export type RoomMessageAttachmentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoomMessageAttachmentFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `message` relation. */
  message?: InputMaybe<RoomMessageFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RoomMessageAttachmentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoomMessageAttachmentFilter>>;
  /** Filter by the object’s `roomMessageId` field. */
  roomMessageId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `topic` relation. */
  topic?: InputMaybe<TopicFilter>;
  /** Filter by the object’s `topicId` field. */
  topicId?: InputMaybe<UuidFilter>;
};

/** A filter to be used against `Organization` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganizationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currentUserIsBillingContact` field. */
  currentUserIsBillingContact?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `currentUserIsOwner` field. */
  currentUserIsOwner?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganizationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganizationFilter>>;
  /** Filter by the object’s `organizationMemberships` relation. */
  organizationMemberships?: InputMaybe<OrganizationToManyOrganizationMembershipFilter>;
  /** Some related `organizationMemberships` exist. */
  organizationMembershipsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `rooms` relation. */
  rooms?: InputMaybe<OrganizationToManyRoomFilter>;
  /** Some related `rooms` exist. */
  roomsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `slug` field. */
  slug?: InputMaybe<StringFilter>;
  /** Filter by the object’s `topics` relation. */
  topics?: InputMaybe<OrganizationToManyTopicFilter>;
  /** Some related `topics` exist. */
  topicsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A filter to be used against many `OrganizationMembership` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationToManyOrganizationMembershipFilter = {
  /** Every related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OrganizationMembershipFilter>;
  /** No related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OrganizationMembershipFilter>;
  /** Some related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OrganizationMembershipFilter>;
};

/** A filter to be used against `OrganizationMembership` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationMembershipFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganizationMembershipFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isBillingContact` field. */
  isBillingContact?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isOwner` field. */
  isOwner?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganizationMembershipFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganizationMembershipFilter>>;
  /** Filter by the object’s `organization` relation. */
  organization?: InputMaybe<OrganizationFilter>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** A filter to be used against many `Room` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationToManyRoomFilter = {
  /** Every related `Room` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomFilter>;
  /** No related `Room` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomFilter>;
  /** Some related `Room` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomFilter>;
};

/** A filter to be used against many `Topic` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationToManyTopicFilter = {
  /** Every related `Topic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TopicFilter>;
  /** No related `Topic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TopicFilter>;
  /** Some related `Topic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TopicFilter>;
};

/** A filter to be used against many `RoomSubscription` object types. All fields are combined with a logical ‘and.’ */
export type RoomToManyRoomSubscriptionFilter = {
  /** Every related `RoomSubscription` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomSubscriptionFilter>;
  /** No related `RoomSubscription` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomSubscriptionFilter>;
  /** Some related `RoomSubscription` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomSubscriptionFilter>;
};

/** A filter to be used against `RoomSubscription` object types. All fields are combined with a logical ‘and.’ */
export type RoomSubscriptionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoomSubscriptionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isStarred` field. */
  isStarred?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `lastNotificationAt` field. */
  lastNotificationAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `lastVisitAt` field. */
  lastVisitAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RoomSubscriptionFilter>;
  /** Filter by the object’s `notifications` field. */
  notifications?: InputMaybe<NotificationSettingFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoomSubscriptionFilter>>;
  /** Filter by the object’s `role` field. */
  role?: InputMaybe<RoomRoleFilter>;
  /** Filter by the object’s `room` relation. */
  room?: InputMaybe<RoomFilter>;
  /** Filter by the object’s `roomId` field. */
  roomId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `subscriber` relation. */
  subscriber?: InputMaybe<UserFilter>;
  /** Filter by the object’s `subscriberId` field. */
  subscriberId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A filter to be used against many `RoomItemAttachment` object types. All fields are combined with a logical ‘and.’ */
export type RoomItemToManyRoomItemAttachmentFilter = {
  /** Every related `RoomItemAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomItemAttachmentFilter>;
  /** No related `RoomItemAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomItemAttachmentFilter>;
  /** Some related `RoomItemAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomItemAttachmentFilter>;
};

/** A filter to be used against RoomItemType fields. All fields are combined with a logical ‘and.’ */
export type RoomItemTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<RoomItemType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<RoomItemType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<RoomItemType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<RoomItemType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<RoomItemType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<RoomItemType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<RoomItemType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<RoomItemType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<RoomItemType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<RoomItemType>>;
};

export type RoomItemType =
  | 'MESSAGE'
  | 'TOPIC';

/** A filter to be used against many `OrganizationMembership` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyOrganizationMembershipFilter = {
  /** Every related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OrganizationMembershipFilter>;
  /** No related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OrganizationMembershipFilter>;
  /** Some related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OrganizationMembershipFilter>;
};

/** A filter to be used against many `RoomItem` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyRoomItemFilter = {
  /** Every related `RoomItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomItemFilter>;
  /** No related `RoomItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomItemFilter>;
  /** Some related `RoomItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomItemFilter>;
};

/** A filter to be used against many `RoomMessage` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyRoomMessageFilter = {
  /** Every related `RoomMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomMessageFilter>;
  /** No related `RoomMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomMessageFilter>;
  /** Some related `RoomMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomMessageFilter>;
};

/** A filter to be used against many `RoomSubscription` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyRoomSubscriptionFilter = {
  /** Every related `RoomSubscription` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomSubscriptionFilter>;
  /** No related `RoomSubscription` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomSubscriptionFilter>;
  /** Some related `RoomSubscription` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomSubscriptionFilter>;
};

/** A filter to be used against Time fields. All fields are combined with a logical ‘and.’ */
export type TimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Time']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Time']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Time']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Time']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Time']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Time']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Time']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Time']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/** A filter to be used against many `UserAuthentication` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserAuthenticationFilter = {
  /** Every related `UserAuthentication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserAuthenticationFilter>;
  /** No related `UserAuthentication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserAuthenticationFilter>;
  /** Some related `UserAuthentication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserAuthenticationFilter>;
};

/** A filter to be used against `UserAuthentication` object types. All fields are combined with a logical ‘and.’ */
export type UserAuthenticationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserAuthenticationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `details` field. */
  details?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `identifier` field. */
  identifier?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserAuthenticationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserAuthenticationFilter>>;
  /** Filter by the object’s `service` field. */
  service?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** A filter to be used against many `UserEmail` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserEmailFilter = {
  /** Every related `UserEmail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserEmailFilter>;
  /** No related `UserEmail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserEmailFilter>;
  /** Some related `UserEmail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserEmailFilter>;
};

/** A filter to be used against `UserEmail` object types. All fields are combined with a logical ‘and.’ */
export type UserEmailFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserEmailFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isPrimary` field. */
  isPrimary?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isVerified` field. */
  isVerified?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserEmailFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserEmailFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** A filter to be used against TopicVisibility fields. All fields are combined with a logical ‘and.’ */
export type TopicVisibilityFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<TopicVisibility>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<TopicVisibility>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<TopicVisibility>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<TopicVisibility>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<TopicVisibility>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<TopicVisibility>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<TopicVisibility>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<TopicVisibility>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<TopicVisibility>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<TopicVisibility>>;
};

/** A filter to be used against many `RoomItemAttachment` object types. All fields are combined with a logical ‘and.’ */
export type TopicToManyRoomItemAttachmentFilter = {
  /** Every related `RoomItemAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomItemAttachmentFilter>;
  /** No related `RoomItemAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomItemAttachmentFilter>;
  /** Some related `RoomItemAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomItemAttachmentFilter>;
};

/** A filter to be used against many `RoomItem` object types. All fields are combined with a logical ‘and.’ */
export type TopicToManyRoomItemFilter = {
  /** Every related `RoomItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomItemFilter>;
  /** No related `RoomItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomItemFilter>;
  /** Some related `RoomItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomItemFilter>;
};

/** A filter to be used against many `RoomMessageAttachment` object types. All fields are combined with a logical ‘and.’ */
export type TopicToManyRoomMessageAttachmentFilter = {
  /** Every related `RoomMessageAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RoomMessageAttachmentFilter>;
  /** No related `RoomMessageAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RoomMessageAttachmentFilter>;
  /** Some related `RoomMessageAttachment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RoomMessageAttachmentFilter>;
};

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Methods to use when ordering `Topic`. */
export type TopicsOrderBy =
  | 'AUTHOR_ID_ASC'
  | 'AUTHOR_ID_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_VISIBLE_FOR_ASC'
  | 'IS_VISIBLE_FOR_DESC'
  | 'LICENSE_ASC'
  | 'LICENSE_DESC'
  | 'NATURAL'
  | 'ORGANIZATION_ID_ASC'
  | 'ORGANIZATION_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SLUG_ASC'
  | 'SLUG_DESC'
  | 'TITLE_ASC'
  | 'TITLE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `Topic` values. */
export type TopicsConnection = {
  __typename?: 'TopicsConnection';
  /** A list of edges which contains the `Topic` and cursor to aid in pagination. */
  edges: Array<TopicsEdge>;
  /** A list of `Topic` objects. */
  nodes: Array<Topic>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Topic` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Topic` edge in the connection. */
export type TopicsEdge = {
  __typename?: 'TopicsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Topic` at the end of the edge. */
  node: Topic;
};

/** A topic is a short text about something. Most topics should have the scope of a micro learning unit. */
export type Topic = Node & {
  __typename?: 'Topic';
  /** Each topic has an author. The field might be null when the original author has unregistered from the application. */
  author: Maybe<User>;
  authorId: Maybe<Scalars['UUID']['output']>;
  /** The topics contents as JSON. Can be converted to HTML with https://tiptap.dev/api/utilities/html */
  content: Scalars['JSON']['output'];
  contentAsPlainText: Maybe<Scalars['String']['output']>;
  contentPreview: Maybe<Scalars['JSON']['output']>;
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  /** Topics can be visible to anyone (`public`), to all signed-in users (`signed_in_users`), or within an organization (`organization_members`). */
  isVisibleFor: TopicVisibility;
  /** Each topic can optionally be licensed. Hyperlinks are allowed. */
  license: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Topic`. */
  organization: Maybe<Organization>;
  organizationId: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `RoomItemAttachment`. */
  roomItemAttachments: RoomItemAttachmentsConnection;
  /** Reads and enables pagination through a set of `RoomItem`. */
  roomItems: RoomItemsConnection;
  /** Reads and enables pagination through a set of `RoomMessageAttachment`. */
  roomMessageAttachments: RoomMessageAttachmentsConnection;
  /** Each topic has a slug (a name made up of lowercase letters, digits, and hypens) to be addressed with. */
  slug: Scalars['String']['output'];
  /** Each topic can be categorized using tags. */
  tags: Array<Maybe<Scalars['String']['output']>>;
  /** Each topic has an optional title. In case of an article, this would be the headline. */
  title: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
};


/** A topic is a short text about something. Most topics should have the scope of a micro learning unit. */
export type TopicContentPreviewArgs = {
  nFirstItems?: InputMaybe<Scalars['Int']['input']>;
};


/** A topic is a short text about something. Most topics should have the scope of a micro learning unit. */
export type TopicRoomItemAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomItemAttachmentCondition>;
  filter?: InputMaybe<RoomItemAttachmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomItemAttachmentsOrderBy>>;
};


/** A topic is a short text about something. Most topics should have the scope of a micro learning unit. */
export type TopicRoomItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomItemCondition>;
  filter?: InputMaybe<RoomItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomItemsOrderBy>>;
};


/** A topic is a short text about something. Most topics should have the scope of a micro learning unit. */
export type TopicRoomMessageAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomMessageAttachmentCondition>;
  filter?: InputMaybe<RoomMessageAttachmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomMessageAttachmentsOrderBy>>;
};

export type Organization = Node & {
  __typename?: 'Organization';
  createdAt: Scalars['Datetime']['output'];
  currentUserIsBillingContact: Maybe<Scalars['Boolean']['output']>;
  currentUserIsOwner: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `OrganizationMembership`. */
  organizationMemberships: OrganizationMembershipsConnection;
  /** Reads and enables pagination through a set of `Room`. */
  rooms: RoomsConnection;
  slug: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Topic`. */
  topics: TopicsConnection;
};


export type OrganizationOrganizationMembershipsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationMembershipCondition>;
  filter?: InputMaybe<OrganizationMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationMembershipsOrderBy>>;
};


export type OrganizationRoomsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomCondition>;
  filter?: InputMaybe<RoomFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomsOrderBy>>;
};


export type OrganizationTopicsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TopicCondition>;
  filter?: InputMaybe<TopicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TopicsOrderBy>>;
};

/**
 * A condition to be used against `OrganizationMembership` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type OrganizationMembershipCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isBillingContact` field. */
  isBillingContact?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isOwner` field. */
  isOwner?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Methods to use when ordering `OrganizationMembership`. */
export type OrganizationMembershipsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_BILLING_CONTACT_ASC'
  | 'IS_BILLING_CONTACT_DESC'
  | 'IS_OWNER_ASC'
  | 'IS_OWNER_DESC'
  | 'NATURAL'
  | 'ORGANIZATION_ID_ASC'
  | 'ORGANIZATION_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** A connection to a list of `OrganizationMembership` values. */
export type OrganizationMembershipsConnection = {
  __typename?: 'OrganizationMembershipsConnection';
  /** A list of edges which contains the `OrganizationMembership` and cursor to aid in pagination. */
  edges: Array<OrganizationMembershipsEdge>;
  /** A list of `OrganizationMembership` objects. */
  nodes: Array<OrganizationMembership>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrganizationMembership` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `OrganizationMembership` edge in the connection. */
export type OrganizationMembershipsEdge = {
  __typename?: 'OrganizationMembershipsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `OrganizationMembership` at the end of the edge. */
  node: OrganizationMembership;
};

export type OrganizationMembership = Node & {
  __typename?: 'OrganizationMembership';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  isBillingContact: Scalars['Boolean']['output'];
  isOwner: Scalars['Boolean']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `OrganizationMembership`. */
  organization: Maybe<Organization>;
  organizationId: Scalars['UUID']['output'];
  /** Reads a single `User` that is related to this `OrganizationMembership`. */
  user: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']['output']>;
};

/** A condition to be used against `Room` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RoomCondition = {
  /** Checks for equality with the object’s `abstract` field. */
  abstract?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `draftItemsAreVisibleFor` field. */
  draftItemsAreVisibleFor?: InputMaybe<RoomRole>;
  /** Checks for equality with the object’s `extendVisibilityOfItemsBy` field. */
  extendVisibilityOfItemsBy?: InputMaybe<IntervalInput>;
  /** Checks for equality with the object’s `hasSubscriptions` field. */
  hasSubscriptions?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isAnonymousPostingAllowed` field. */
  isAnonymousPostingAllowed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isVisibleFor` field. */
  isVisibleFor?: InputMaybe<RoomVisibility>;
  /** Checks for equality with the object’s `itemsAreVisibleFor` field. */
  itemsAreVisibleFor?: InputMaybe<RoomRole>;
  /** Checks for equality with the object’s `itemsAreVisibleSince` field. */
  itemsAreVisibleSince?: InputMaybe<RoomHistoryVisibility>;
  /** Checks for equality with the object’s `itemsAreVisibleSinceDate` field. */
  itemsAreVisibleSinceDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `latestActivityAt` field. */
  latestActivityAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `latestItemContributedAt` field. */
  latestItemContributedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `myFirstInteraction` field. */
  myFirstInteraction?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `mySubscriptionId` field. */
  mySubscriptionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `nItems` field. */
  nItems?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `nItemsSinceLastVisit` field. */
  nItemsSinceLastVisit?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `nSubscriptions` field. */
  nSubscriptions?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `Room`. */
export type RoomsOrderBy =
  | 'ABSTRACT_ASC'
  | 'ABSTRACT_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'DRAFT_ITEMS_ARE_VISIBLE_FOR_ASC'
  | 'DRAFT_ITEMS_ARE_VISIBLE_FOR_DESC'
  | 'EXTEND_VISIBILITY_OF_ITEMS_BY_ASC'
  | 'EXTEND_VISIBILITY_OF_ITEMS_BY_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_ANONYMOUS_POSTING_ALLOWED_ASC'
  | 'IS_ANONYMOUS_POSTING_ALLOWED_DESC'
  | 'IS_VISIBLE_FOR_ASC'
  | 'IS_VISIBLE_FOR_DESC'
  | 'ITEMS_ARE_VISIBLE_FOR_ASC'
  | 'ITEMS_ARE_VISIBLE_FOR_DESC'
  | 'ITEMS_ARE_VISIBLE_SINCE_ASC'
  | 'ITEMS_ARE_VISIBLE_SINCE_DATE_ASC'
  | 'ITEMS_ARE_VISIBLE_SINCE_DATE_DESC'
  | 'ITEMS_ARE_VISIBLE_SINCE_DESC'
  | 'LATEST_ACTIVITY_AT_ASC'
  | 'LATEST_ACTIVITY_AT_DESC'
  | 'LATEST_ITEM_CONTRIBUTED_AT_ASC'
  | 'LATEST_ITEM_CONTRIBUTED_AT_DESC'
  | 'N_ITEMS_ASC'
  | 'N_ITEMS_DESC'
  | 'N_ITEMS_SINCE_LAST_VISIT_ASC'
  | 'N_ITEMS_SINCE_LAST_VISIT_DESC'
  | 'N_SUBSCRIPTIONS_ASC'
  | 'N_SUBSCRIPTIONS_DESC'
  | 'NATURAL'
  | 'ORGANIZATION_ID_ASC'
  | 'ORGANIZATION_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TITLE_ASC'
  | 'TITLE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `Room` values. */
export type RoomsConnection = {
  __typename?: 'RoomsConnection';
  /** A list of edges which contains the `Room` and cursor to aid in pagination. */
  edges: Array<RoomsEdge>;
  /** A list of `Room` objects. */
  nodes: Array<Room>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Room` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Room` edge in the connection. */
export type RoomsEdge = {
  __typename?: 'RoomsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Room` at the end of the edge. */
  node: Room;
};

/** A room is a place where users meet. At the same time, it is a container for messages and handed-out materials. */
export type Room = Node & {
  __typename?: 'Room';
  /** Each room has an optional abstract. */
  abstract: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  draftItemsAreVisibleFor: Maybe<RoomRole>;
  extendVisibilityOfItemsBy: Interval;
  hasSubscriptions: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['UUID']['output'];
  isAnonymousPostingAllowed: Scalars['Boolean']['output'];
  /** Rooms can be visible for their subscribers only (`subscribers`), to all members of the room's organisation (`organization_members`), for all currently signed-in users (`signed_in_users`), or general in `public`. */
  isVisibleFor: RoomVisibility;
  /** Reads and enables pagination through a set of `RoomItem`. */
  items: RoomItemsConnection;
  itemsAreVisibleFor: RoomRole;
  /** Sometimes you want to hide items of the room from users who join later. `since_subscription` allows subscribers to see items that were added *after* their subscription. Similarly, `since_invitation` allows subscribers to see items that were added *after* they had been invited to the room. `since_specified_date` allows all subscribers to see items after `items_are_visible_since_date`. Finally, `always` means that all items are visible for the room's audience. */
  itemsAreVisibleSince: RoomHistoryVisibility;
  itemsAreVisibleSinceDate: Scalars['Datetime']['output'];
  latestActivityAt: Maybe<Scalars['Datetime']['output']>;
  latestItem: Maybe<RoomItem>;
  latestItemContributedAt: Maybe<Scalars['Datetime']['output']>;
  latestMessage: Maybe<RoomMessage>;
  /** Reads and enables pagination through a set of `RoomMessage`. */
  messages: RoomMessagesConnection;
  /**
   *
   * Date of subscription or first sent message, whatever is earlier.
   *
   */
  myFirstInteraction: Maybe<Scalars['Datetime']['output']>;
  mySubscription: Maybe<RoomSubscription>;
  mySubscriptionId: Maybe<Scalars['UUID']['output']>;
  nItems: Maybe<Scalars['BigInt']['output']>;
  nItemsSince: Maybe<Scalars['BigInt']['output']>;
  nItemsSinceDate: Maybe<Scalars['BigInt']['output']>;
  nItemsSinceLastVisit: Maybe<Scalars['BigInt']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  nSubscriptions: Maybe<Scalars['BigInt']['output']>;
  /** Each room can optionally belong to an organization. */
  organization: Maybe<Organization>;
  organizationId: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `RoomSubscription`. */
  subscriptions: RoomSubscriptionsConnection;
  /** Each room has an optional title. */
  title: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
};


/** A room is a place where users meet. At the same time, it is a container for messages and handed-out materials. */
export type RoomHasSubscriptionsArgs = {
  minRole?: InputMaybe<RoomRole>;
};


/** A room is a place where users meet. At the same time, it is a container for messages and handed-out materials. */
export type RoomItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomItemCondition>;
  filter?: InputMaybe<RoomItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomItemsOrderBy>>;
};


/** A room is a place where users meet. At the same time, it is a container for messages and handed-out materials. */
export type RoomMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomMessageCondition>;
  filter?: InputMaybe<RoomMessageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomMessagesOrderBy>>;
};


/** A room is a place where users meet. At the same time, it is a container for messages and handed-out materials. */
export type RoomNItemsSinceArgs = {
  interval: IntervalInput;
};


/** A room is a place where users meet. At the same time, it is a container for messages and handed-out materials. */
export type RoomNItemsSinceDateArgs = {
  date: Scalars['Datetime']['input'];
};


/** A room is a place where users meet. At the same time, it is a container for messages and handed-out materials. */
export type RoomNSubscriptionsArgs = {
  minRole?: InputMaybe<RoomRole>;
};


/** A room is a place where users meet. At the same time, it is a container for messages and handed-out materials. */
export type RoomSubscriptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomSubscriptionCondition>;
  filter?: InputMaybe<RoomSubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomSubscriptionsOrderBy>>;
};

/** An interval of time that has passed where the smallest distinct unit is a second. */
export type Interval = {
  __typename?: 'Interval';
  /** A quantity of days. */
  days: Maybe<Scalars['Int']['output']>;
  /** A quantity of hours. */
  hours: Maybe<Scalars['Int']['output']>;
  /** A quantity of minutes. */
  minutes: Maybe<Scalars['Int']['output']>;
  /** A quantity of months. */
  months: Maybe<Scalars['Int']['output']>;
  /**
   * A quantity of seconds. This is the only non-integer field, as all the other
   * fields will dump their overflow into a smaller unit of time. Intervals don’t
   * have a smaller unit than seconds.
   */
  seconds: Maybe<Scalars['Float']['output']>;
  /** A quantity of years. */
  years: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `RoomItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RoomItemCondition = {
  /** Checks for equality with the object’s `contributedAt` field. */
  contributedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `contributorId` field. */
  contributorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isVisibleFor` field. */
  isVisibleFor?: InputMaybe<RoomRole>;
  /** Checks for equality with the object’s `isVisibleSince` field. */
  isVisibleSince?: InputMaybe<RoomHistoryVisibility>;
  /** Checks for equality with the object’s `isVisibleSinceDate` field. */
  isVisibleSinceDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `messageBody` field. */
  messageBody?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `nthItemSinceLastVisit` field. */
  nthItemSinceLastVisit?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `order` field. */
  order?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `roomId` field. */
  roomId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `topicId` field. */
  topicId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<RoomItemType>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `RoomItem`. */
export type RoomItemsOrderBy =
  | 'CONTRIBUTED_AT_ASC'
  | 'CONTRIBUTED_AT_DESC'
  | 'CONTRIBUTOR_ID_ASC'
  | 'CONTRIBUTOR_ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_VISIBLE_FOR_ASC'
  | 'IS_VISIBLE_FOR_DESC'
  | 'IS_VISIBLE_SINCE_ASC'
  | 'IS_VISIBLE_SINCE_DATE_ASC'
  | 'IS_VISIBLE_SINCE_DATE_DESC'
  | 'IS_VISIBLE_SINCE_DESC'
  | 'MESSAGE_BODY_ASC'
  | 'MESSAGE_BODY_DESC'
  | 'NATURAL'
  | 'NTH_ITEM_SINCE_LAST_VISIT_ASC'
  | 'NTH_ITEM_SINCE_LAST_VISIT_DESC'
  | 'ORDER_ASC'
  | 'ORDER_DESC'
  | 'PARENT_ID_ASC'
  | 'PARENT_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_ID_ASC'
  | 'ROOM_ID_DESC'
  | 'TOPIC_ID_ASC'
  | 'TOPIC_ID_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `RoomItem` values. */
export type RoomItemsConnection = {
  __typename?: 'RoomItemsConnection';
  /** A list of edges which contains the `RoomItem` and cursor to aid in pagination. */
  edges: Array<RoomItemsEdge>;
  /** A list of `RoomItem` objects. */
  nodes: Array<RoomItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoomItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RoomItem` edge in the connection. */
export type RoomItemsEdge = {
  __typename?: 'RoomItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `RoomItem` at the end of the edge. */
  node: RoomItem;
};

/** Room items are messages or materials, that are accessible within a certain room. */
export type RoomItem = Node & {
  __typename?: 'RoomItem';
  /** Reads and enables pagination through a set of `RoomItem`. */
  children: RoomItemsConnection;
  contributedAt: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `RoomItem`. */
  contributor: Maybe<User>;
  /** The id of a user who contributed the room item. */
  contributorId: Maybe<Scalars['UUID']['output']>;
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  /** Decides which role can see the room item. This also applies to more powerful roles. If the value is not set, the default settings of the room will be used. */
  isVisibleFor: Maybe<RoomRole>;
  /** Decides if room items are always visible or only to users who subscribed before they were added. If the value is not set, the default settings of the room will be used. */
  isVisibleSince: Maybe<RoomHistoryVisibility>;
  isVisibleSinceDate: Maybe<Scalars['Datetime']['output']>;
  messageBody: Maybe<Scalars['JSON']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  nthItemSinceLastVisit: Maybe<Scalars['BigInt']['output']>;
  /** The default order is 0, but you can change it to different values to sort the items. */
  order: Scalars['Float']['output'];
  /** Room items can be related in trees. */
  parent: Maybe<RoomItem>;
  /** The items in a room can be connected to each other, basically forming one or multiple trees. For example, you can use this to keep track of conversations. */
  parentId: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `Room` that is related to this `RoomItem`. */
  room: Maybe<Room>;
  roomId: Scalars['UUID']['output'];
  /** Reads and enables pagination through a set of `RoomItemAttachment`. */
  roomItemAttachments: RoomItemAttachmentsConnection;
  /** Reads a single `Topic` that is related to this `RoomItem`. */
  topic: Maybe<Topic>;
  topicId: Maybe<Scalars['UUID']['output']>;
  /** The kind of room item. There are messages, pages, files, and so on. */
  type: RoomItemType;
  updatedAt: Scalars['Datetime']['output'];
};


/** Room items are messages or materials, that are accessible within a certain room. */
export type RoomItemChildrenArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomItemCondition>;
  filter?: InputMaybe<RoomItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomItemsOrderBy>>;
};


/** Room items are messages or materials, that are accessible within a certain room. */
export type RoomItemRoomItemAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomItemAttachmentCondition>;
  filter?: InputMaybe<RoomItemAttachmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomItemAttachmentsOrderBy>>;
};

/**
 * A condition to be used against `RoomItemAttachment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type RoomItemAttachmentCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `fileId` field. */
  fileId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `roomItemId` field. */
  roomItemId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `topicId` field. */
  topicId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Methods to use when ordering `RoomItemAttachment`. */
export type RoomItemAttachmentsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'FILE_ID_ASC'
  | 'FILE_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_ITEM_ID_ASC'
  | 'ROOM_ITEM_ID_DESC'
  | 'TOPIC_ID_ASC'
  | 'TOPIC_ID_DESC';

/** A connection to a list of `RoomItemAttachment` values. */
export type RoomItemAttachmentsConnection = {
  __typename?: 'RoomItemAttachmentsConnection';
  /** A list of edges which contains the `RoomItemAttachment` and cursor to aid in pagination. */
  edges: Array<RoomItemAttachmentsEdge>;
  /** A list of `RoomItemAttachment` objects. */
  nodes: Array<RoomItemAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoomItemAttachment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RoomItemAttachment` edge in the connection. */
export type RoomItemAttachmentsEdge = {
  __typename?: 'RoomItemAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `RoomItemAttachment` at the end of the edge. */
  node: RoomItemAttachment;
};

export type RoomItemAttachment = Node & {
  __typename?: 'RoomItemAttachment';
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `File` that is related to this `RoomItemAttachment`. */
  file: Maybe<File>;
  fileId: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `RoomItem` that is related to this `RoomItemAttachment`. */
  roomItem: Maybe<RoomItem>;
  roomItemId: Scalars['UUID']['output'];
  /** Reads a single `Topic` that is related to this `RoomItemAttachment`. */
  topic: Maybe<Topic>;
  topicId: Maybe<Scalars['UUID']['output']>;
};

export type File = Node & {
  __typename?: 'File';
  /** Reads a single `User` that is related to this `File`. */
  contributor: Maybe<User>;
  contributorId: Maybe<Scalars['UUID']['output']>;
  createdAt: Scalars['Datetime']['output'];
  filename: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  mimeType: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  pathOnStorage: Maybe<Scalars['String']['output']>;
  /** Reads a single `PdfFile` that is related to this `File`. */
  pdfFile: Maybe<PdfFile>;
  /** Reads and enables pagination through a set of `PdfFile`. */
  pdfFilesByThumbnailId: PdfFilesConnection;
  /** Reads and enables pagination through a set of `RoomItemAttachment`. */
  roomItemAttachments: RoomItemAttachmentsConnection;
  sha256: Maybe<Scalars['String']['output']>;
  totalBytes: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['Datetime']['output'];
  uploadedBytes: Maybe<Scalars['Int']['output']>;
};


export type FilePdfFilesByThumbnailIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PdfFileCondition>;
  filter?: InputMaybe<PdfFileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PdfFilesOrderBy>>;
};


export type FileRoomItemAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomItemAttachmentCondition>;
  filter?: InputMaybe<RoomItemAttachmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomItemAttachmentsOrderBy>>;
};

export type PdfFile = Node & {
  __typename?: 'PdfFile';
  contentAsPlainText: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `File` that is related to this `PdfFile`. */
  file: Maybe<File>;
  id: Scalars['UUID']['output'];
  metadata: Maybe<Scalars['JSON']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  pages: Scalars['Int']['output'];
  /** Reads a single `File` that is related to this `PdfFile`. */
  thumbnail: Maybe<File>;
  thumbnailId: Maybe<Scalars['UUID']['output']>;
  title: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Datetime']['output'];
};

/** A condition to be used against `PdfFile` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PdfFileCondition = {
  /** Checks for equality with the object’s `contentAsPlainText` field. */
  contentAsPlainText?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `metadata` field. */
  metadata?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `pages` field. */
  pages?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `thumbnailId` field. */
  thumbnailId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `PdfFile`. */
export type PdfFilesOrderBy =
  | 'CONTENT_AS_PLAIN_TEXT_ASC'
  | 'CONTENT_AS_PLAIN_TEXT_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'METADATA_ASC'
  | 'METADATA_DESC'
  | 'NATURAL'
  | 'PAGES_ASC'
  | 'PAGES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'THUMBNAIL_ID_ASC'
  | 'THUMBNAIL_ID_DESC'
  | 'TITLE_ASC'
  | 'TITLE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `PdfFile` values. */
export type PdfFilesConnection = {
  __typename?: 'PdfFilesConnection';
  /** A list of edges which contains the `PdfFile` and cursor to aid in pagination. */
  edges: Array<PdfFilesEdge>;
  /** A list of `PdfFile` objects. */
  nodes: Array<PdfFile>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PdfFile` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PdfFile` edge in the connection. */
export type PdfFilesEdge = {
  __typename?: 'PdfFilesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `PdfFile` at the end of the edge. */
  node: PdfFile;
};

export type RoomMessage = Node & {
  __typename?: 'RoomMessage';
  /** Reads a single `RoomMessage` that is related to this `RoomMessage`. */
  answeredMessage: Maybe<RoomMessage>;
  answeredMessageId: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `RoomMessage`. */
  answers: RoomMessagesConnection;
  /** Reads and enables pagination through a set of `RoomMessageAttachment`. */
  attachments: RoomMessageAttachmentsConnection;
  body: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  language: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Room` that is related to this `RoomMessage`. */
  room: Maybe<Room>;
  roomId: Scalars['UUID']['output'];
  /** Reads a single `User` that is related to this `RoomMessage`. */
  sender: Maybe<User>;
  senderId: Maybe<Scalars['UUID']['output']>;
  sentAt: Maybe<Scalars['Datetime']['output']>;
  updatedAt: Scalars['Datetime']['output'];
};


export type RoomMessageAnswersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomMessageCondition>;
  filter?: InputMaybe<RoomMessageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomMessagesOrderBy>>;
};


export type RoomMessageAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomMessageAttachmentCondition>;
  filter?: InputMaybe<RoomMessageAttachmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomMessageAttachmentsOrderBy>>;
};

/**
 * A condition to be used against `RoomMessage` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RoomMessageCondition = {
  /** Checks for equality with the object’s `answeredMessageId` field. */
  answeredMessageId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `language` field. */
  language?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `roomId` field. */
  roomId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `senderId` field. */
  senderId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `sentAt` field. */
  sentAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `RoomMessage`. */
export type RoomMessagesOrderBy =
  | 'ANSWERED_MESSAGE_ID_ASC'
  | 'ANSWERED_MESSAGE_ID_DESC'
  | 'BODY_ASC'
  | 'BODY_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LANGUAGE_ASC'
  | 'LANGUAGE_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_ID_ASC'
  | 'ROOM_ID_DESC'
  | 'SENDER_ID_ASC'
  | 'SENDER_ID_DESC'
  | 'SENT_AT_ASC'
  | 'SENT_AT_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `RoomMessage` values. */
export type RoomMessagesConnection = {
  __typename?: 'RoomMessagesConnection';
  /** A list of edges which contains the `RoomMessage` and cursor to aid in pagination. */
  edges: Array<RoomMessagesEdge>;
  /** A list of `RoomMessage` objects. */
  nodes: Array<RoomMessage>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoomMessage` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RoomMessage` edge in the connection. */
export type RoomMessagesEdge = {
  __typename?: 'RoomMessagesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `RoomMessage` at the end of the edge. */
  node: RoomMessage;
};

/**
 * A condition to be used against `RoomMessageAttachment` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type RoomMessageAttachmentCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `roomMessageId` field. */
  roomMessageId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `topicId` field. */
  topicId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Methods to use when ordering `RoomMessageAttachment`. */
export type RoomMessageAttachmentsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROOM_MESSAGE_ID_ASC'
  | 'ROOM_MESSAGE_ID_DESC'
  | 'TOPIC_ID_ASC'
  | 'TOPIC_ID_DESC';

/** A connection to a list of `RoomMessageAttachment` values. */
export type RoomMessageAttachmentsConnection = {
  __typename?: 'RoomMessageAttachmentsConnection';
  /** A list of edges which contains the `RoomMessageAttachment` and cursor to aid in pagination. */
  edges: Array<RoomMessageAttachmentsEdge>;
  /** A list of `RoomMessageAttachment` objects. */
  nodes: Array<RoomMessageAttachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoomMessageAttachment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RoomMessageAttachment` edge in the connection. */
export type RoomMessageAttachmentsEdge = {
  __typename?: 'RoomMessageAttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `RoomMessageAttachment` at the end of the edge. */
  node: RoomMessageAttachment;
};

export type RoomMessageAttachment = Node & {
  __typename?: 'RoomMessageAttachment';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  /** Reads a single `RoomMessage` that is related to this `RoomMessageAttachment`. */
  message: Maybe<RoomMessage>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  roomMessageId: Scalars['UUID']['output'];
  /** Reads a single `Topic` that is related to this `RoomMessageAttachment`. */
  topic: Maybe<Topic>;
  topicId: Scalars['UUID']['output'];
};

/** Users can be subscribed to rooms. */
export type RoomSubscription = Node & {
  __typename?: 'RoomSubscription';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  isStarred: Scalars['Boolean']['output'];
  lastNotificationAt: Maybe<Scalars['Datetime']['output']>;
  lastVisitAt: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  notifications: NotificationSetting;
  /** Maintainers can manage subscriptions and delete the room. */
  role: RoomRole;
  /** Reads a single `Room` that is related to this `RoomSubscription`. */
  room: Maybe<Room>;
  roomId: Scalars['UUID']['output'];
  /** Reads a single `User` that is related to this `RoomSubscription`. */
  subscriber: Maybe<User>;
  /** The subscribing user. */
  subscriberId: Scalars['UUID']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `RoomSubscription` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type RoomSubscriptionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isStarred` field. */
  isStarred?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `lastNotificationAt` field. */
  lastNotificationAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `lastVisitAt` field. */
  lastVisitAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `notifications` field. */
  notifications?: InputMaybe<NotificationSetting>;
  /** Checks for equality with the object’s `role` field. */
  role?: InputMaybe<RoomRole>;
  /** Checks for equality with the object’s `roomId` field. */
  roomId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `subscriberId` field. */
  subscriberId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `RoomSubscription`. */
export type RoomSubscriptionsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_STARRED_ASC'
  | 'IS_STARRED_DESC'
  | 'LAST_NOTIFICATION_AT_ASC'
  | 'LAST_NOTIFICATION_AT_DESC'
  | 'LAST_VISIT_AT_ASC'
  | 'LAST_VISIT_AT_DESC'
  | 'NATURAL'
  | 'NOTIFICATIONS_ASC'
  | 'NOTIFICATIONS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROLE_ASC'
  | 'ROLE_DESC'
  | 'ROOM_ID_ASC'
  | 'ROOM_ID_DESC'
  | 'SUBSCRIBER_ID_ASC'
  | 'SUBSCRIBER_ID_DESC'
  | 'SUBSCRIBERS_USERNAME_ASC'
  | 'SUBSCRIBERS_USERNAME_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A connection to a list of `RoomSubscription` values. */
export type RoomSubscriptionsConnection = {
  __typename?: 'RoomSubscriptionsConnection';
  /** A list of edges which contains the `RoomSubscription` and cursor to aid in pagination. */
  edges: Array<RoomSubscriptionsEdge>;
  /** A list of `RoomSubscription` objects. */
  nodes: Array<RoomSubscription>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoomSubscription` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RoomSubscription` edge in the connection. */
export type RoomSubscriptionsEdge = {
  __typename?: 'RoomSubscriptionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `RoomSubscription` at the end of the edge. */
  node: RoomSubscription;
};

/** A condition to be used against `File` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FileCondition = {
  /** Checks for equality with the object’s `contributorId` field. */
  contributorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `filename` field. */
  filename?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `mimeType` field. */
  mimeType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pathOnStorage` field. */
  pathOnStorage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sha256` field. */
  sha256?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `totalBytes` field. */
  totalBytes?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uploadedBytes` field. */
  uploadedBytes?: InputMaybe<Scalars['Int']['input']>;
};

/** Methods to use when ordering `File`. */
export type FilesOrderBy =
  | 'CONTRIBUTOR_ID_ASC'
  | 'CONTRIBUTOR_ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'FILENAME_ASC'
  | 'FILENAME_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'MIME_TYPE_ASC'
  | 'MIME_TYPE_DESC'
  | 'NATURAL'
  | 'PATH_ON_STORAGE_ASC'
  | 'PATH_ON_STORAGE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SHA256_ASC'
  | 'SHA256_DESC'
  | 'TOTAL_BYTES_ASC'
  | 'TOTAL_BYTES_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'UPLOADED_BYTES_ASC'
  | 'UPLOADED_BYTES_DESC';

/** A connection to a list of `File` values. */
export type FilesConnection = {
  __typename?: 'FilesConnection';
  /** A list of edges which contains the `File` and cursor to aid in pagination. */
  edges: Array<FilesEdge>;
  /** A list of `File` objects. */
  nodes: Array<File>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `File` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `File` edge in the connection. */
export type FilesEdge = {
  __typename?: 'FilesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `File` at the end of the edge. */
  node: File;
};

/**
 * A condition to be used against `UserAuthentication` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UserAuthenticationCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `details` field. */
  details?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `identifier` field. */
  identifier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `service` field. */
  service?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Methods to use when ordering `UserAuthentication`. */
export type UserAuthenticationsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'DETAILS_ASC'
  | 'DETAILS_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IDENTIFIER_ASC'
  | 'IDENTIFIER_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SERVICE_ASC'
  | 'SERVICE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** A connection to a list of `UserAuthentication` values. */
export type UserAuthenticationsConnection = {
  __typename?: 'UserAuthenticationsConnection';
  /** A list of edges which contains the `UserAuthentication` and cursor to aid in pagination. */
  edges: Array<UserAuthenticationsEdge>;
  /** A list of `UserAuthentication` objects. */
  nodes: Array<UserAuthentication>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserAuthentication` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserAuthentication` edge in the connection. */
export type UserAuthenticationsEdge = {
  __typename?: 'UserAuthenticationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UserAuthentication` at the end of the edge. */
  node: UserAuthentication;
};

/** Contains information about the login providers this user has used, so that they may disconnect them should they wish. */
export type UserAuthentication = Node & {
  __typename?: 'UserAuthentication';
  createdAt: Scalars['Datetime']['output'];
  /** Additional profile details extracted from this login method */
  details: Scalars['JSON']['output'];
  id: Scalars['UUID']['output'];
  /** A unique identifier for the user within the login service. */
  identifier: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** The login service used, e.g. `twitter` or `github`. */
  service: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `UserAuthentication`. */
  user: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `UserEmail` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserEmailCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isPrimary` field. */
  isPrimary?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isVerified` field. */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Methods to use when ordering `UserEmail`. */
export type UserEmailsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_PRIMARY_ASC'
  | 'IS_PRIMARY_DESC'
  | 'IS_VERIFIED_ASC'
  | 'IS_VERIFIED_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** A connection to a list of `UserEmail` values. */
export type UserEmailsConnection = {
  __typename?: 'UserEmailsConnection';
  /** A list of edges which contains the `UserEmail` and cursor to aid in pagination. */
  edges: Array<UserEmailsEdge>;
  /** A list of `UserEmail` objects. */
  nodes: Array<UserEmail>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserEmail` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserEmail` edge in the connection. */
export type UserEmailsEdge = {
  __typename?: 'UserEmailsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UserEmail` at the end of the edge. */
  node: UserEmail;
};

/** Information about a user's email address. */
export type UserEmail = Node & {
  __typename?: 'UserEmail';
  createdAt: Scalars['Datetime']['output'];
  /** The users email address, in `a@b.c` format. */
  email: Scalars['String']['output'];
  id: Scalars['UUID']['output'];
  isPrimary: Scalars['Boolean']['output'];
  /** True if the user has is_verified their email address (by clicking the link in the email we sent them, or logging in with a social login provider), false otherwise. */
  isVerified: Scalars['Boolean']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/** A connection to a list of `UUID` values. */
export type CurrentUserInvitedOrganizationIdsConnection = {
  __typename?: 'CurrentUserInvitedOrganizationIdsConnection';
  /** A list of edges which contains the `UUID` and cursor to aid in pagination. */
  edges: Array<Maybe<CurrentUserInvitedOrganizationIdsEdge>>;
  /** A list of `UUID` objects. */
  nodes: Array<Maybe<Scalars['UUID']['output']>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UUID` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UUID` edge in the connection. */
export type CurrentUserInvitedOrganizationIdsEdge = {
  __typename?: 'CurrentUserInvitedOrganizationIdsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UUID` at the end of the edge. */
  node: Maybe<Scalars['UUID']['output']>;
};

/** A connection to a list of `UUID` values. */
export type CurrentUserMemberOrganizationIdsConnection = {
  __typename?: 'CurrentUserMemberOrganizationIdsConnection';
  /** A list of edges which contains the `UUID` and cursor to aid in pagination. */
  edges: Array<Maybe<CurrentUserMemberOrganizationIdsEdge>>;
  /** A list of `UUID` objects. */
  nodes: Array<Maybe<Scalars['UUID']['output']>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UUID` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UUID` edge in the connection. */
export type CurrentUserMemberOrganizationIdsEdge = {
  __typename?: 'CurrentUserMemberOrganizationIdsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UUID` at the end of the edge. */
  node: Maybe<Scalars['UUID']['output']>;
};

/**
 * A condition to be used against `TextsearchMatch` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TextsearchMatchCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `rankOrSimilarity` field. */
  rankOrSimilarity?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `roomId` field. */
  roomId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `snippet` field. */
  snippet?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topicId` field. */
  topicId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<TextsearchableEntity>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

export type TextsearchableEntity =
  | 'DOCUMENT'
  | 'FILE'
  | 'ROOM'
  | 'TOPIC'
  | 'USER';

/** A filter to be used against `TextsearchMatch` object types. All fields are combined with a logical ‘and.’ */
export type TextsearchMatchFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TextsearchMatchFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TextsearchMatchFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TextsearchMatchFilter>>;
  /** Filter by the object’s `rankOrSimilarity` field. */
  rankOrSimilarity?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `roomId` field. */
  roomId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `snippet` field. */
  snippet?: InputMaybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `topicId` field. */
  topicId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<TextsearchableEntityFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** A filter to be used against TextsearchableEntity fields. All fields are combined with a logical ‘and.’ */
export type TextsearchableEntityFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<TextsearchableEntity>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<TextsearchableEntity>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<TextsearchableEntity>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<TextsearchableEntity>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<TextsearchableEntity>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<TextsearchableEntity>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<TextsearchableEntity>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<TextsearchableEntity>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<TextsearchableEntity>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<TextsearchableEntity>>;
};

/** Methods to use when ordering `TextsearchMatch`. */
export type TextsearchMatchesOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'RANK_OR_SIMILARITY_ASC'
  | 'RANK_OR_SIMILARITY_DESC'
  | 'ROOM_ID_ASC'
  | 'ROOM_ID_DESC'
  | 'SNIPPET_ASC'
  | 'SNIPPET_DESC'
  | 'TITLE_ASC'
  | 'TITLE_DESC'
  | 'TOPIC_ID_ASC'
  | 'TOPIC_ID_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** A connection to a list of `TextsearchMatch` values. */
export type TextsearchMatchesConnection = {
  __typename?: 'TextsearchMatchesConnection';
  /** A list of edges which contains the `TextsearchMatch` and cursor to aid in pagination. */
  edges: Array<TextsearchMatchesEdge>;
  /** A list of `TextsearchMatch` objects. */
  nodes: Array<TextsearchMatch>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TextsearchMatch` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TextsearchMatch` edge in the connection. */
export type TextsearchMatchesEdge = {
  __typename?: 'TextsearchMatchesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `TextsearchMatch` at the end of the edge. */
  node: TextsearchMatch;
};

export type TextsearchMatch = {
  __typename?: 'TextsearchMatch';
  id: Scalars['UUID']['output'];
  rankOrSimilarity: Scalars['Float']['output'];
  /** Reads a single `Room` that is related to this `TextsearchMatch`. */
  room: Maybe<Room>;
  roomId: Maybe<Scalars['UUID']['output']>;
  snippet: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  /** Reads a single `Topic` that is related to this `TextsearchMatch`. */
  topic: Maybe<Topic>;
  topicId: Maybe<Scalars['UUID']['output']>;
  type: TextsearchableEntity;
  /** Reads a single `User` that is related to this `TextsearchMatch`. */
  user: Maybe<User>;
  userId: Maybe<Scalars['UUID']['output']>;
};

/** A connection to a list of `UUID` values. */
export type MySubscribedRoomIdsConnection = {
  __typename?: 'MySubscribedRoomIdsConnection';
  /** A list of edges which contains the `UUID` and cursor to aid in pagination. */
  edges: Array<Maybe<MySubscribedRoomIdsEdge>>;
  /** A list of `UUID` objects. */
  nodes: Array<Maybe<Scalars['UUID']['output']>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UUID` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UUID` edge in the connection. */
export type MySubscribedRoomIdsEdge = {
  __typename?: 'MySubscribedRoomIdsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UUID` at the end of the edge. */
  node: Maybe<Scalars['UUID']['output']>;
};

/**
 * A condition to be used against `Organization` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OrganizationCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `currentUserIsBillingContact` field. */
  currentUserIsBillingContact?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `currentUserIsOwner` field. */
  currentUserIsOwner?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: InputMaybe<Scalars['String']['input']>;
};

/** Methods to use when ordering `Organization`. */
export type OrganizationsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SLUG_ASC'
  | 'SLUG_DESC';

/** A connection to a list of `Organization` values. */
export type OrganizationsConnection = {
  __typename?: 'OrganizationsConnection';
  /** A list of edges which contains the `Organization` and cursor to aid in pagination. */
  edges: Array<OrganizationsEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection. */
export type OrganizationsEdge = {
  __typename?: 'OrganizationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `avatarUrl` field. */
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `defaultHandlingOfNotifications` field. */
  defaultHandlingOfNotifications?: InputMaybe<NotificationSetting>;
  /** Checks for equality with the object’s `hasPassword` field. */
  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isVerified` field. */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sendingTimeForDeferredNotifications` field. */
  sendingTimeForDeferredNotifications?: InputMaybe<Scalars['Time']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Methods to use when ordering `User`. */
export type UsersOrderBy =
  | 'AVATAR_URL_ASC'
  | 'AVATAR_URL_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'DEFAULT_HANDLING_OF_NOTIFICATIONS_ASC'
  | 'DEFAULT_HANDLING_OF_NOTIFICATIONS_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_ADMIN_ASC'
  | 'IS_ADMIN_DESC'
  | 'IS_VERIFIED_ASC'
  | 'IS_VERIFIED_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SENDING_TIME_FOR_DEFERRED_NOTIFICATIONS_ASC'
  | 'SENDING_TIME_FOR_DEFERRED_NOTIFICATIONS_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'USERNAME_ASC'
  | 'USERNAME_DESC';

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  acceptInvitationToOrganization: Maybe<AcceptInvitationToOrganizationPayload>;
  /** Enter your old password and a new password to change your password. */
  changePassword: Maybe<ChangePasswordPayload>;
  /** If you're certain you want to delete your account, use `requestAccountDeletion` to request an account deletion token, and then supply the token through this mutation to complete account deletion. */
  confirmAccountDeletion: Maybe<ConfirmAccountDeletionPayload>;
  /** Creates a single `File`. */
  createFile: Maybe<CreateFilePayload>;
  createOrganization: Maybe<CreateOrganizationPayload>;
  /** Creates a single `PdfFile`. */
  createPdfFile: Maybe<CreatePdfFilePayload>;
  /** Creates a single `Room`. */
  createRoom: Maybe<CreateRoomPayload>;
  /** Creates a single `RoomItem`. */
  createRoomItem: Maybe<CreateRoomItemPayload>;
  /** Creates a single `RoomItemAttachment`. */
  createRoomItemAttachment: Maybe<CreateRoomItemAttachmentPayload>;
  /** Creates a single `RoomMessage`. */
  createRoomMessage: Maybe<CreateRoomMessagePayload>;
  /** Creates a single `RoomMessageAttachment`. */
  createRoomMessageAttachment: Maybe<CreateRoomMessageAttachmentPayload>;
  /** Creates a single `RoomSubscription`. */
  createRoomSubscription: Maybe<CreateRoomSubscriptionPayload>;
  /** Creates a single `Topic`. */
  createTopic: Maybe<CreateTopicPayload>;
  /** Creates a single `User`. */
  createUser: Maybe<CreateUserPayload>;
  /** Creates a single `UserEmail`. */
  createUserEmail: Maybe<CreateUserEmailPayload>;
  /** Deletes a single `File` using a unique key. */
  deleteFile: Maybe<DeleteFilePayload>;
  /** Deletes a single `File` using its globally unique id. */
  deleteFileByNodeId: Maybe<DeleteFilePayload>;
  deleteOrganization: Maybe<DeleteOrganizationPayload>;
  /** Deletes a single `PdfFile` using a unique key. */
  deletePdfFile: Maybe<DeletePdfFilePayload>;
  /** Deletes a single `PdfFile` using its globally unique id. */
  deletePdfFileByNodeId: Maybe<DeletePdfFilePayload>;
  /** Deletes a single `Room` using a unique key. */
  deleteRoom: Maybe<DeleteRoomPayload>;
  /** Deletes a single `Room` using its globally unique id. */
  deleteRoomByNodeId: Maybe<DeleteRoomPayload>;
  /** Deletes a single `RoomItem` using a unique key. */
  deleteRoomItem: Maybe<DeleteRoomItemPayload>;
  /** Deletes a single `RoomItemAttachment` using a unique key. */
  deleteRoomItemAttachment: Maybe<DeleteRoomItemAttachmentPayload>;
  /** Deletes a single `RoomItemAttachment` using its globally unique id. */
  deleteRoomItemAttachmentByNodeId: Maybe<DeleteRoomItemAttachmentPayload>;
  /** Deletes a single `RoomItem` using its globally unique id. */
  deleteRoomItemByNodeId: Maybe<DeleteRoomItemPayload>;
  /** Deletes a single `RoomMessage` using a unique key. */
  deleteRoomMessage: Maybe<DeleteRoomMessagePayload>;
  /** Deletes a single `RoomMessageAttachment` using a unique key. */
  deleteRoomMessageAttachment: Maybe<DeleteRoomMessageAttachmentPayload>;
  /** Deletes a single `RoomMessageAttachment` using its globally unique id. */
  deleteRoomMessageAttachmentByNodeId: Maybe<DeleteRoomMessageAttachmentPayload>;
  /** Deletes a single `RoomMessageAttachment` using a unique key. */
  deleteRoomMessageAttachmentByTopicIdAndRoomMessageId: Maybe<DeleteRoomMessageAttachmentPayload>;
  /** Deletes a single `RoomMessage` using its globally unique id. */
  deleteRoomMessageByNodeId: Maybe<DeleteRoomMessagePayload>;
  /** Deletes a single `RoomSubscription` using a unique key. */
  deleteRoomSubscription: Maybe<DeleteRoomSubscriptionPayload>;
  /** Deletes a single `RoomSubscription` using its globally unique id. */
  deleteRoomSubscriptionByNodeId: Maybe<DeleteRoomSubscriptionPayload>;
  /** Deletes a single `RoomSubscription` using a unique key. */
  deleteRoomSubscriptionBySubscriberIdAndRoomId: Maybe<DeleteRoomSubscriptionPayload>;
  /** Deletes a single `Topic` using a unique key. */
  deleteTopic: Maybe<DeleteTopicPayload>;
  /** Deletes a single `Topic` using its globally unique id. */
  deleteTopicByNodeId: Maybe<DeleteTopicPayload>;
  /** Deletes a single `Topic` using a unique key. */
  deleteTopicBySlugAndOrganizationId: Maybe<DeleteTopicPayload>;
  /** Deletes a single `UserAuthentication` using a unique key. */
  deleteUserAuthentication: Maybe<DeleteUserAuthenticationPayload>;
  /** Deletes a single `UserAuthentication` using its globally unique id. */
  deleteUserAuthenticationByNodeId: Maybe<DeleteUserAuthenticationPayload>;
  /** Deletes a single `UserAuthentication` using a unique key. */
  deleteUserAuthenticationByServiceAndIdentifier: Maybe<DeleteUserAuthenticationPayload>;
  /** Deletes a single `UserEmail` using a unique key. */
  deleteUserEmail: Maybe<DeleteUserEmailPayload>;
  /** Deletes a single `UserEmail` using its globally unique id. */
  deleteUserEmailByNodeId: Maybe<DeleteUserEmailPayload>;
  /** Deletes a single `UserEmail` using a unique key. */
  deleteUserEmailByUserIdAndEmail: Maybe<DeleteUserEmailPayload>;
  /** If you've forgotten your password, give us one of your email addresses and we'll send you a reset token. Note this only works if you have added an email address! */
  forgotPassword: Maybe<ForgotPasswordPayload>;
  inviteToOrganization: Maybe<InviteToOrganizationPayload>;
  /** Use this mutation to log in to your account; this login uses sessions so you do not need to take further action. */
  login: Maybe<LoginPayload>;
  /** Use this mutation to logout from your account. Don't forget to clear the client state! */
  logout: Maybe<LogoutPayload>;
  /** Your primary email is where we'll notify of account events; other emails may be used for discovery or login. Use this when you're changing your email address. */
  makeEmailPrimary: Maybe<MakeEmailPrimaryPayload>;
  /** Use this mutation to create an account on our system. This may only be used if you are logged out. */
  register: Maybe<RegisterPayload>;
  removeFromOrganization: Maybe<RemoveFromOrganizationPayload>;
  /** Begin the account deletion flow by requesting the confirmation email */
  requestAccountDeletion: Maybe<RequestAccountDeletionPayload>;
  /** If you didn't receive the verification code for this email, we can resend it. We silently cap the rate of resends on the backend, so calls to this function may not result in another email being sent if it has been called recently. */
  resendEmailVerificationCode: Maybe<ResendEmailVerificationCodePayload>;
  /** After triggering forgotPassword, you'll be sent a reset token. Combine this with your user ID and a new password to reset your password. */
  resetPassword: Maybe<ResetPasswordPayload>;
  sendRoomMessage: Maybe<SendRoomMessagePayload>;
  transferOrganizationBillingContact: Maybe<TransferOrganizationBillingContactPayload>;
  transferOrganizationOwnership: Maybe<TransferOrganizationOwnershipPayload>;
  /** Updates a single `File` using a unique key and a patch. */
  updateFile: Maybe<UpdateFilePayload>;
  /** Updates a single `File` using its globally unique id and a patch. */
  updateFileByNodeId: Maybe<UpdateFilePayload>;
  /** Updates a single `Organization` using a unique key and a patch. */
  updateOrganization: Maybe<UpdateOrganizationPayload>;
  /** Updates a single `Organization` using its globally unique id and a patch. */
  updateOrganizationByNodeId: Maybe<UpdateOrganizationPayload>;
  /** Updates a single `Organization` using a unique key and a patch. */
  updateOrganizationBySlug: Maybe<UpdateOrganizationPayload>;
  /** Updates a single `PdfFile` using a unique key and a patch. */
  updatePdfFile: Maybe<UpdatePdfFilePayload>;
  /** Updates a single `PdfFile` using its globally unique id and a patch. */
  updatePdfFileByNodeId: Maybe<UpdatePdfFilePayload>;
  /** Updates a single `Room` using a unique key and a patch. */
  updateRoom: Maybe<UpdateRoomPayload>;
  /** Updates a single `Room` using its globally unique id and a patch. */
  updateRoomByNodeId: Maybe<UpdateRoomPayload>;
  /** Updates a single `RoomItem` using a unique key and a patch. */
  updateRoomItem: Maybe<UpdateRoomItemPayload>;
  /** Updates a single `RoomItem` using its globally unique id and a patch. */
  updateRoomItemByNodeId: Maybe<UpdateRoomItemPayload>;
  /** Updates a single `RoomMessage` using a unique key and a patch. */
  updateRoomMessage: Maybe<UpdateRoomMessagePayload>;
  /** Updates a single `RoomMessage` using its globally unique id and a patch. */
  updateRoomMessageByNodeId: Maybe<UpdateRoomMessagePayload>;
  /** Updates a single `RoomSubscription` using a unique key and a patch. */
  updateRoomSubscription: Maybe<UpdateRoomSubscriptionPayload>;
  /** Updates a single `RoomSubscription` using its globally unique id and a patch. */
  updateRoomSubscriptionByNodeId: Maybe<UpdateRoomSubscriptionPayload>;
  /** Updates a single `RoomSubscription` using a unique key and a patch. */
  updateRoomSubscriptionBySubscriberIdAndRoomId: Maybe<UpdateRoomSubscriptionPayload>;
  /** Updates a single `Topic` using a unique key and a patch. */
  updateTopic: Maybe<UpdateTopicPayload>;
  /** Updates a single `Topic` using its globally unique id and a patch. */
  updateTopicByNodeId: Maybe<UpdateTopicPayload>;
  /** Updates a single `Topic` using a unique key and a patch. */
  updateTopicBySlugAndOrganizationId: Maybe<UpdateTopicPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByUsername: Maybe<UpdateUserPayload>;
  /** Once you have received a verification token for your email, you may call this mutation with that token to make your email verified. */
  verifyEmail: Maybe<VerifyEmailPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationAcceptInvitationToOrganizationArgs = {
  input: AcceptInvitationToOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationChangePasswordArgs = {
  input: ChangePasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationConfirmAccountDeletionArgs = {
  input: ConfirmAccountDeletionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFileArgs = {
  input: CreateFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrganizationArgs = {
  input: CreateOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePdfFileArgs = {
  input: CreatePdfFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomArgs = {
  input: CreateRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomItemArgs = {
  input: CreateRoomItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomItemAttachmentArgs = {
  input: CreateRoomItemAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomMessageArgs = {
  input: CreateRoomMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomMessageAttachmentArgs = {
  input: CreateRoomMessageAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoomSubscriptionArgs = {
  input: CreateRoomSubscriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTopicArgs = {
  input: CreateTopicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserEmailArgs = {
  input: CreateUserEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileArgs = {
  input: DeleteFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileByNodeIdArgs = {
  input: DeleteFileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationArgs = {
  input: DeleteOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePdfFileArgs = {
  input: DeletePdfFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePdfFileByNodeIdArgs = {
  input: DeletePdfFileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomArgs = {
  input: DeleteRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomByNodeIdArgs = {
  input: DeleteRoomByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomItemArgs = {
  input: DeleteRoomItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomItemAttachmentArgs = {
  input: DeleteRoomItemAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomItemAttachmentByNodeIdArgs = {
  input: DeleteRoomItemAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomItemByNodeIdArgs = {
  input: DeleteRoomItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomMessageArgs = {
  input: DeleteRoomMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomMessageAttachmentArgs = {
  input: DeleteRoomMessageAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomMessageAttachmentByNodeIdArgs = {
  input: DeleteRoomMessageAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomMessageAttachmentByTopicIdAndRoomMessageIdArgs = {
  input: DeleteRoomMessageAttachmentByTopicIdAndRoomMessageIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomMessageByNodeIdArgs = {
  input: DeleteRoomMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomSubscriptionArgs = {
  input: DeleteRoomSubscriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomSubscriptionByNodeIdArgs = {
  input: DeleteRoomSubscriptionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoomSubscriptionBySubscriberIdAndRoomIdArgs = {
  input: DeleteRoomSubscriptionBySubscriberIdAndRoomIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTopicArgs = {
  input: DeleteTopicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTopicByNodeIdArgs = {
  input: DeleteTopicByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTopicBySlugAndOrganizationIdArgs = {
  input: DeleteTopicBySlugAndOrganizationIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserAuthenticationArgs = {
  input: DeleteUserAuthenticationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserAuthenticationByNodeIdArgs = {
  input: DeleteUserAuthenticationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserAuthenticationByServiceAndIdentifierArgs = {
  input: DeleteUserAuthenticationByServiceAndIdentifierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserEmailArgs = {
  input: DeleteUserEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserEmailByNodeIdArgs = {
  input: DeleteUserEmailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserEmailByUserIdAndEmailArgs = {
  input: DeleteUserEmailByUserIdAndEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationForgotPasswordArgs = {
  input: ForgotPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationInviteToOrganizationArgs = {
  input: InviteToOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLoginArgs = {
  input: LoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationMakeEmailPrimaryArgs = {
  input: MakeEmailPrimaryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRegisterArgs = {
  input: RegisterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRemoveFromOrganizationArgs = {
  input: RemoveFromOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRequestAccountDeletionArgs = {
  input: RequestAccountDeletionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResendEmailVerificationCodeArgs = {
  input: ResendEmailVerificationCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationSendRoomMessageArgs = {
  input: SendRoomMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationTransferOrganizationBillingContactArgs = {
  input: TransferOrganizationBillingContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationTransferOrganizationOwnershipArgs = {
  input: TransferOrganizationOwnershipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileArgs = {
  input: UpdateFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileByNodeIdArgs = {
  input: UpdateFileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationArgs = {
  input: UpdateOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationByNodeIdArgs = {
  input: UpdateOrganizationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationBySlugArgs = {
  input: UpdateOrganizationBySlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePdfFileArgs = {
  input: UpdatePdfFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePdfFileByNodeIdArgs = {
  input: UpdatePdfFileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomArgs = {
  input: UpdateRoomInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomByNodeIdArgs = {
  input: UpdateRoomByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomItemArgs = {
  input: UpdateRoomItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomItemByNodeIdArgs = {
  input: UpdateRoomItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomMessageArgs = {
  input: UpdateRoomMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomMessageByNodeIdArgs = {
  input: UpdateRoomMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomSubscriptionArgs = {
  input: UpdateRoomSubscriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomSubscriptionByNodeIdArgs = {
  input: UpdateRoomSubscriptionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoomSubscriptionBySubscriberIdAndRoomIdArgs = {
  input: UpdateRoomSubscriptionBySubscriberIdAndRoomIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTopicArgs = {
  input: UpdateTopicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTopicByNodeIdArgs = {
  input: UpdateTopicByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTopicBySlugAndOrganizationIdArgs = {
  input: UpdateTopicBySlugAndOrganizationIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByUsernameArgs = {
  input: UpdateUserByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationVerifyEmailArgs = {
  input: VerifyEmailInput;
};

/** All input for the `acceptInvitationToOrganization` mutation. */
export type AcceptInvitationToOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  invitationId: Scalars['UUID']['input'];
};

/** The output of our `acceptInvitationToOrganization` mutation. */
export type AcceptInvitationToOrganizationPayload = {
  __typename?: 'AcceptInvitationToOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `changePassword` mutation. */
export type ChangePasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  newPassword: Scalars['String']['input'];
  oldPassword: Scalars['String']['input'];
};

/** The output of our `changePassword` mutation. */
export type ChangePasswordPayload = {
  __typename?: 'ChangePasswordPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `confirmAccountDeletion` mutation. */
export type ConfirmAccountDeletionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
};

/** The output of our `confirmAccountDeletion` mutation. */
export type ConfirmAccountDeletionPayload = {
  __typename?: 'ConfirmAccountDeletionPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `File` mutation. */
export type CreateFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `File` to be created by this mutation. */
  file: FileInput;
};

/** An input for mutations affecting `File` */
export type FileInput = {
  contributorId?: InputMaybe<Scalars['UUID']['input']>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mimeType?: InputMaybe<Scalars['String']['input']>;
  totalBytes?: InputMaybe<Scalars['Int']['input']>;
  uploadedBytes?: InputMaybe<Scalars['Int']['input']>;
};

/** The output of our create `File` mutation. */
export type CreateFilePayload = {
  __typename?: 'CreateFilePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `File`. */
  contributor: Maybe<User>;
  /** The `File` that was created by this mutation. */
  file: Maybe<File>;
  /** An edge for our `File`. May be used by Relay 1. */
  fileEdge: Maybe<FilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `File` mutation. */
export type CreateFilePayloadFileEdgeArgs = {
  orderBy?: Array<FilesOrderBy>;
};

/** All input for the `createOrganization` mutation. */
export type CreateOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  slug: Scalars['String']['input'];
};

/** The output of our `createOrganization` mutation. */
export type CreateOrganizationPayload = {
  __typename?: 'CreateOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our `createOrganization` mutation. */
export type CreateOrganizationPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** All input for the create `PdfFile` mutation. */
export type CreatePdfFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PdfFile` to be created by this mutation. */
  pdfFile: PdfFileInput;
};

/** An input for mutations affecting `PdfFile` */
export type PdfFileInput = {
  contentAsPlainText?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  metadata?: InputMaybe<Scalars['JSON']['input']>;
  pages: Scalars['Int']['input'];
  thumbnailId?: InputMaybe<Scalars['UUID']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `PdfFile` mutation. */
export type CreatePdfFilePayload = {
  __typename?: 'CreatePdfFilePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `File` that is related to this `PdfFile`. */
  file: Maybe<File>;
  /** The `PdfFile` that was created by this mutation. */
  pdfFile: Maybe<PdfFile>;
  /** An edge for our `PdfFile`. May be used by Relay 1. */
  pdfFileEdge: Maybe<PdfFilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `File` that is related to this `PdfFile`. */
  thumbnail: Maybe<File>;
};


/** The output of our create `PdfFile` mutation. */
export type CreatePdfFilePayloadPdfFileEdgeArgs = {
  orderBy?: Array<PdfFilesOrderBy>;
};

/** All input for the create `Room` mutation. */
export type CreateRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Room` to be created by this mutation. */
  room: RoomInput;
};

/** An input for mutations affecting `Room` */
export type RoomInput = {
  /** Each room has an optional abstract. */
  abstract?: InputMaybe<Scalars['String']['input']>;
  isAnonymousPostingAllowed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Rooms can be visible for their subscribers only (`subscribers`), to all members of the room's organisation (`organization_members`), for all currently signed-in users (`signed_in_users`), or general in `public`. */
  isVisibleFor?: InputMaybe<RoomVisibility>;
  itemsAreVisibleFor?: InputMaybe<RoomRole>;
  /** Sometimes you want to hide items of the room from users who join later. `since_subscription` allows subscribers to see items that were added *after* their subscription. Similarly, `since_invitation` allows subscribers to see items that were added *after* they had been invited to the room. `since_specified_date` allows all subscribers to see items after `items_are_visible_since_date`. Finally, `always` means that all items are visible for the room's audience. */
  itemsAreVisibleSince?: InputMaybe<RoomHistoryVisibility>;
  /** Each room has an optional title. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Room` mutation. */
export type CreateRoomPayload = {
  __typename?: 'CreateRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Each room can optionally belong to an organization. */
  organization: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was created by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our create `Room` mutation. */
export type CreateRoomPayloadRoomEdgeArgs = {
  orderBy?: Array<RoomsOrderBy>;
};

/** All input for the create `RoomItem` mutation. */
export type CreateRoomItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RoomItem` to be created by this mutation. */
  roomItem: RoomItemInput;
};

/** An input for mutations affecting `RoomItem` */
export type RoomItemInput = {
  contributedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** The id of a user who contributed the room item. */
  contributorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Decides which role can see the room item. This also applies to more powerful roles. If the value is not set, the default settings of the room will be used. */
  isVisibleFor?: InputMaybe<RoomRole>;
  /** Decides if room items are always visible or only to users who subscribed before they were added. If the value is not set, the default settings of the room will be used. */
  isVisibleSince?: InputMaybe<RoomHistoryVisibility>;
  isVisibleSinceDate?: InputMaybe<Scalars['Datetime']['input']>;
  messageBody?: InputMaybe<Scalars['JSON']['input']>;
  /** The default order is 0, but you can change it to different values to sort the items. */
  order?: InputMaybe<Scalars['Float']['input']>;
  /** The items in a room can be connected to each other, basically forming one or multiple trees. For example, you can use this to keep track of conversations. */
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  roomId: Scalars['UUID']['input'];
  topicId?: InputMaybe<Scalars['UUID']['input']>;
  /** The kind of room item. There are messages, pages, files, and so on. */
  type?: InputMaybe<RoomItemType>;
};

/** The output of our create `RoomItem` mutation. */
export type CreateRoomItemPayload = {
  __typename?: 'CreateRoomItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `RoomItem`. */
  contributor: Maybe<User>;
  /** Room items can be related in trees. */
  parent: Maybe<RoomItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomItem`. */
  room: Maybe<Room>;
  /** The `RoomItem` that was created by this mutation. */
  roomItem: Maybe<RoomItem>;
  /** An edge for our `RoomItem`. May be used by Relay 1. */
  roomItemEdge: Maybe<RoomItemsEdge>;
  /** Reads a single `Topic` that is related to this `RoomItem`. */
  topic: Maybe<Topic>;
};


/** The output of our create `RoomItem` mutation. */
export type CreateRoomItemPayloadRoomItemEdgeArgs = {
  orderBy?: Array<RoomItemsOrderBy>;
};

/** All input for the create `RoomItemAttachment` mutation. */
export type CreateRoomItemAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RoomItemAttachment` to be created by this mutation. */
  roomItemAttachment: RoomItemAttachmentInput;
};

/** An input for mutations affecting `RoomItemAttachment` */
export type RoomItemAttachmentInput = {
  fileId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  roomItemId: Scalars['UUID']['input'];
  topicId?: InputMaybe<Scalars['UUID']['input']>;
};

/** The output of our create `RoomItemAttachment` mutation. */
export type CreateRoomItemAttachmentPayload = {
  __typename?: 'CreateRoomItemAttachmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `File` that is related to this `RoomItemAttachment`. */
  file: Maybe<File>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `RoomItem` that is related to this `RoomItemAttachment`. */
  roomItem: Maybe<RoomItem>;
  /** The `RoomItemAttachment` that was created by this mutation. */
  roomItemAttachment: Maybe<RoomItemAttachment>;
  /** An edge for our `RoomItemAttachment`. May be used by Relay 1. */
  roomItemAttachmentEdge: Maybe<RoomItemAttachmentsEdge>;
  /** Reads a single `Topic` that is related to this `RoomItemAttachment`. */
  topic: Maybe<Topic>;
};


/** The output of our create `RoomItemAttachment` mutation. */
export type CreateRoomItemAttachmentPayloadRoomItemAttachmentEdgeArgs = {
  orderBy?: Array<RoomItemAttachmentsOrderBy>;
};

/** All input for the create `RoomMessage` mutation. */
export type CreateRoomMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RoomMessage` to be created by this mutation. */
  roomMessage: RoomMessageInput;
};

/** An input for mutations affecting `RoomMessage` */
export type RoomMessageInput = {
  answeredMessageId?: InputMaybe<Scalars['UUID']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  language?: InputMaybe<Scalars['String']['input']>;
  roomId: Scalars['UUID']['input'];
  senderId?: InputMaybe<Scalars['UUID']['input']>;
  sentAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The output of our create `RoomMessage` mutation. */
export type CreateRoomMessagePayload = {
  __typename?: 'CreateRoomMessagePayload';
  /** Reads a single `RoomMessage` that is related to this `RoomMessage`. */
  answeredMessage: Maybe<RoomMessage>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomMessage`. */
  room: Maybe<Room>;
  /** The `RoomMessage` that was created by this mutation. */
  roomMessage: Maybe<RoomMessage>;
  /** An edge for our `RoomMessage`. May be used by Relay 1. */
  roomMessageEdge: Maybe<RoomMessagesEdge>;
  /** Reads a single `User` that is related to this `RoomMessage`. */
  sender: Maybe<User>;
};


/** The output of our create `RoomMessage` mutation. */
export type CreateRoomMessagePayloadRoomMessageEdgeArgs = {
  orderBy?: Array<RoomMessagesOrderBy>;
};

/** All input for the create `RoomMessageAttachment` mutation. */
export type CreateRoomMessageAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RoomMessageAttachment` to be created by this mutation. */
  roomMessageAttachment: RoomMessageAttachmentInput;
};

/** An input for mutations affecting `RoomMessageAttachment` */
export type RoomMessageAttachmentInput = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  roomMessageId: Scalars['UUID']['input'];
  topicId: Scalars['UUID']['input'];
};

/** The output of our create `RoomMessageAttachment` mutation. */
export type CreateRoomMessageAttachmentPayload = {
  __typename?: 'CreateRoomMessageAttachmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `RoomMessage` that is related to this `RoomMessageAttachment`. */
  message: Maybe<RoomMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `RoomMessageAttachment` that was created by this mutation. */
  roomMessageAttachment: Maybe<RoomMessageAttachment>;
  /** An edge for our `RoomMessageAttachment`. May be used by Relay 1. */
  roomMessageAttachmentEdge: Maybe<RoomMessageAttachmentsEdge>;
  /** Reads a single `Topic` that is related to this `RoomMessageAttachment`. */
  topic: Maybe<Topic>;
};


/** The output of our create `RoomMessageAttachment` mutation. */
export type CreateRoomMessageAttachmentPayloadRoomMessageAttachmentEdgeArgs = {
  orderBy?: Array<RoomMessageAttachmentsOrderBy>;
};

/** All input for the create `RoomSubscription` mutation. */
export type CreateRoomSubscriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RoomSubscription` to be created by this mutation. */
  roomSubscription: RoomSubscriptionInput;
};

/** An input for mutations affecting `RoomSubscription` */
export type RoomSubscriptionInput = {
  lastVisitAt?: InputMaybe<Scalars['Datetime']['input']>;
  notifications?: InputMaybe<NotificationSetting>;
  /** Maintainers can manage subscriptions and delete the room. */
  role?: InputMaybe<RoomRole>;
  roomId: Scalars['UUID']['input'];
  /** The subscribing user. */
  subscriberId?: InputMaybe<Scalars['UUID']['input']>;
};

/** The output of our create `RoomSubscription` mutation. */
export type CreateRoomSubscriptionPayload = {
  __typename?: 'CreateRoomSubscriptionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomSubscription`. */
  room: Maybe<Room>;
  /** The `RoomSubscription` that was created by this mutation. */
  roomSubscription: Maybe<RoomSubscription>;
  /** An edge for our `RoomSubscription`. May be used by Relay 1. */
  roomSubscriptionEdge: Maybe<RoomSubscriptionsEdge>;
  /** Reads a single `User` that is related to this `RoomSubscription`. */
  subscriber: Maybe<User>;
};


/** The output of our create `RoomSubscription` mutation. */
export type CreateRoomSubscriptionPayloadRoomSubscriptionEdgeArgs = {
  orderBy?: Array<RoomSubscriptionsOrderBy>;
};

/** All input for the create `Topic` mutation. */
export type CreateTopicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Topic` to be created by this mutation. */
  topic: TopicInput;
};

/** An input for mutations affecting `Topic` */
export type TopicInput = {
  authorId?: InputMaybe<Scalars['UUID']['input']>;
  /** The topics contents as JSON. Can be converted to HTML with https://tiptap.dev/api/utilities/html */
  content: Scalars['JSON']['input'];
  /** Topics can be visible to anyone (`public`), to all signed-in users (`signed_in_users`), or within an organization (`organization_members`). */
  isVisibleFor?: InputMaybe<TopicVisibility>;
  /** Each topic can optionally be licensed. Hyperlinks are allowed. */
  license?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Each topic has a slug (a name made up of lowercase letters, digits, and hypens) to be addressed with. */
  slug: Scalars['String']['input'];
  /** Each topic can be categorized using tags. */
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Each topic has an optional title. In case of an article, this would be the headline. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Topic` mutation. */
export type CreateTopicPayload = {
  __typename?: 'CreateTopicPayload';
  /** Each topic has an author. The field might be null when the original author has unregistered from the application. */
  author: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `Topic`. */
  organization: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Topic` that was created by this mutation. */
  topic: Maybe<Topic>;
  /** An edge for our `Topic`. May be used by Relay 1. */
  topicEdge: Maybe<TopicsEdge>;
};


/** The output of our create `Topic` mutation. */
export type CreateTopicPayloadTopicEdgeArgs = {
  orderBy?: Array<TopicsOrderBy>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  /** Users can be notified about activities in the rooms they have subscribed to. This is the default setting. You can change it for each room. */
  defaultHandlingOfNotifications?: InputMaybe<NotificationSetting>;
  /** If there are any delayed notifications, they are sent at this time every day. */
  sendingTimeForDeferredNotifications?: InputMaybe<Scalars['Time']['input']>;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `User` that was created by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: Array<UsersOrderBy>;
};

/** All input for the create `UserEmail` mutation. */
export type CreateUserEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserEmail` to be created by this mutation. */
  userEmail: UserEmailInput;
};

/** An input for mutations affecting `UserEmail` */
export type UserEmailInput = {
  /** The users email address, in `a@b.c` format. */
  email: Scalars['String']['input'];
};

/** The output of our create `UserEmail` mutation. */
export type CreateUserEmailPayload = {
  __typename?: 'CreateUserEmailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  /** The `UserEmail` that was created by this mutation. */
  userEmail: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  userEmailEdge: Maybe<UserEmailsEdge>;
};


/** The output of our create `UserEmail` mutation. */
export type CreateUserEmailPayloadUserEmailEdgeArgs = {
  orderBy?: Array<UserEmailsOrderBy>;
};

/** All input for the `deleteFile` mutation. */
export type DeleteFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `File` mutation. */
export type DeleteFilePayload = {
  __typename?: 'DeleteFilePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `File`. */
  contributor: Maybe<User>;
  deletedFileNodeId: Maybe<Scalars['ID']['output']>;
  /** The `File` that was deleted by this mutation. */
  file: Maybe<File>;
  /** An edge for our `File`. May be used by Relay 1. */
  fileEdge: Maybe<FilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `File` mutation. */
export type DeleteFilePayloadFileEdgeArgs = {
  orderBy?: Array<FilesOrderBy>;
};

/** All input for the `deleteFileByNodeId` mutation. */
export type DeleteFileByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `File` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteOrganization` mutation. */
export type DeleteOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
};

/** The output of our `deleteOrganization` mutation. */
export type DeleteOrganizationPayload = {
  __typename?: 'DeleteOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deletePdfFile` mutation. */
export type DeletePdfFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `PdfFile` mutation. */
export type DeletePdfFilePayload = {
  __typename?: 'DeletePdfFilePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedPdfFileNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `File` that is related to this `PdfFile`. */
  file: Maybe<File>;
  /** The `PdfFile` that was deleted by this mutation. */
  pdfFile: Maybe<PdfFile>;
  /** An edge for our `PdfFile`. May be used by Relay 1. */
  pdfFileEdge: Maybe<PdfFilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `File` that is related to this `PdfFile`. */
  thumbnail: Maybe<File>;
};


/** The output of our delete `PdfFile` mutation. */
export type DeletePdfFilePayloadPdfFileEdgeArgs = {
  orderBy?: Array<PdfFilesOrderBy>;
};

/** All input for the `deletePdfFileByNodeId` mutation. */
export type DeletePdfFileByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PdfFile` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteRoom` mutation. */
export type DeleteRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Room` mutation. */
export type DeleteRoomPayload = {
  __typename?: 'DeleteRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedRoomNodeId: Maybe<Scalars['ID']['output']>;
  /** Each room can optionally belong to an organization. */
  organization: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was deleted by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our delete `Room` mutation. */
export type DeleteRoomPayloadRoomEdgeArgs = {
  orderBy?: Array<RoomsOrderBy>;
};

/** All input for the `deleteRoomByNodeId` mutation. */
export type DeleteRoomByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Room` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteRoomItem` mutation. */
export type DeleteRoomItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `RoomItem` mutation. */
export type DeleteRoomItemPayload = {
  __typename?: 'DeleteRoomItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `RoomItem`. */
  contributor: Maybe<User>;
  deletedRoomItemNodeId: Maybe<Scalars['ID']['output']>;
  /** Room items can be related in trees. */
  parent: Maybe<RoomItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomItem`. */
  room: Maybe<Room>;
  /** The `RoomItem` that was deleted by this mutation. */
  roomItem: Maybe<RoomItem>;
  /** An edge for our `RoomItem`. May be used by Relay 1. */
  roomItemEdge: Maybe<RoomItemsEdge>;
  /** Reads a single `Topic` that is related to this `RoomItem`. */
  topic: Maybe<Topic>;
};


/** The output of our delete `RoomItem` mutation. */
export type DeleteRoomItemPayloadRoomItemEdgeArgs = {
  orderBy?: Array<RoomItemsOrderBy>;
};

/** All input for the `deleteRoomItemAttachment` mutation. */
export type DeleteRoomItemAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `RoomItemAttachment` mutation. */
export type DeleteRoomItemAttachmentPayload = {
  __typename?: 'DeleteRoomItemAttachmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedRoomItemAttachmentNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `File` that is related to this `RoomItemAttachment`. */
  file: Maybe<File>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `RoomItem` that is related to this `RoomItemAttachment`. */
  roomItem: Maybe<RoomItem>;
  /** The `RoomItemAttachment` that was deleted by this mutation. */
  roomItemAttachment: Maybe<RoomItemAttachment>;
  /** An edge for our `RoomItemAttachment`. May be used by Relay 1. */
  roomItemAttachmentEdge: Maybe<RoomItemAttachmentsEdge>;
  /** Reads a single `Topic` that is related to this `RoomItemAttachment`. */
  topic: Maybe<Topic>;
};


/** The output of our delete `RoomItemAttachment` mutation. */
export type DeleteRoomItemAttachmentPayloadRoomItemAttachmentEdgeArgs = {
  orderBy?: Array<RoomItemAttachmentsOrderBy>;
};

/** All input for the `deleteRoomItemAttachmentByNodeId` mutation. */
export type DeleteRoomItemAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoomItemAttachment` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteRoomItemByNodeId` mutation. */
export type DeleteRoomItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoomItem` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteRoomMessage` mutation. */
export type DeleteRoomMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `RoomMessage` mutation. */
export type DeleteRoomMessagePayload = {
  __typename?: 'DeleteRoomMessagePayload';
  /** Reads a single `RoomMessage` that is related to this `RoomMessage`. */
  answeredMessage: Maybe<RoomMessage>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedRoomMessageNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomMessage`. */
  room: Maybe<Room>;
  /** The `RoomMessage` that was deleted by this mutation. */
  roomMessage: Maybe<RoomMessage>;
  /** An edge for our `RoomMessage`. May be used by Relay 1. */
  roomMessageEdge: Maybe<RoomMessagesEdge>;
  /** Reads a single `User` that is related to this `RoomMessage`. */
  sender: Maybe<User>;
};


/** The output of our delete `RoomMessage` mutation. */
export type DeleteRoomMessagePayloadRoomMessageEdgeArgs = {
  orderBy?: Array<RoomMessagesOrderBy>;
};

/** All input for the `deleteRoomMessageAttachment` mutation. */
export type DeleteRoomMessageAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `RoomMessageAttachment` mutation. */
export type DeleteRoomMessageAttachmentPayload = {
  __typename?: 'DeleteRoomMessageAttachmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedRoomMessageAttachmentNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `RoomMessage` that is related to this `RoomMessageAttachment`. */
  message: Maybe<RoomMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `RoomMessageAttachment` that was deleted by this mutation. */
  roomMessageAttachment: Maybe<RoomMessageAttachment>;
  /** An edge for our `RoomMessageAttachment`. May be used by Relay 1. */
  roomMessageAttachmentEdge: Maybe<RoomMessageAttachmentsEdge>;
  /** Reads a single `Topic` that is related to this `RoomMessageAttachment`. */
  topic: Maybe<Topic>;
};


/** The output of our delete `RoomMessageAttachment` mutation. */
export type DeleteRoomMessageAttachmentPayloadRoomMessageAttachmentEdgeArgs = {
  orderBy?: Array<RoomMessageAttachmentsOrderBy>;
};

/** All input for the `deleteRoomMessageAttachmentByNodeId` mutation. */
export type DeleteRoomMessageAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoomMessageAttachment` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteRoomMessageAttachmentByTopicIdAndRoomMessageId` mutation. */
export type DeleteRoomMessageAttachmentByTopicIdAndRoomMessageIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  roomMessageId: Scalars['UUID']['input'];
  topicId: Scalars['UUID']['input'];
};

/** All input for the `deleteRoomMessageByNodeId` mutation. */
export type DeleteRoomMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoomMessage` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteRoomSubscription` mutation. */
export type DeleteRoomSubscriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `RoomSubscription` mutation. */
export type DeleteRoomSubscriptionPayload = {
  __typename?: 'DeleteRoomSubscriptionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedRoomSubscriptionNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomSubscription`. */
  room: Maybe<Room>;
  /** The `RoomSubscription` that was deleted by this mutation. */
  roomSubscription: Maybe<RoomSubscription>;
  /** An edge for our `RoomSubscription`. May be used by Relay 1. */
  roomSubscriptionEdge: Maybe<RoomSubscriptionsEdge>;
  /** Reads a single `User` that is related to this `RoomSubscription`. */
  subscriber: Maybe<User>;
};


/** The output of our delete `RoomSubscription` mutation. */
export type DeleteRoomSubscriptionPayloadRoomSubscriptionEdgeArgs = {
  orderBy?: Array<RoomSubscriptionsOrderBy>;
};

/** All input for the `deleteRoomSubscriptionByNodeId` mutation. */
export type DeleteRoomSubscriptionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoomSubscription` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteRoomSubscriptionBySubscriberIdAndRoomId` mutation. */
export type DeleteRoomSubscriptionBySubscriberIdAndRoomIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  roomId: Scalars['UUID']['input'];
  /** The subscribing user. */
  subscriberId: Scalars['UUID']['input'];
};

/** All input for the `deleteTopic` mutation. */
export type DeleteTopicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Topic` mutation. */
export type DeleteTopicPayload = {
  __typename?: 'DeleteTopicPayload';
  /** Each topic has an author. The field might be null when the original author has unregistered from the application. */
  author: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedTopicNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `Topic`. */
  organization: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Topic` that was deleted by this mutation. */
  topic: Maybe<Topic>;
  /** An edge for our `Topic`. May be used by Relay 1. */
  topicEdge: Maybe<TopicsEdge>;
};


/** The output of our delete `Topic` mutation. */
export type DeleteTopicPayloadTopicEdgeArgs = {
  orderBy?: Array<TopicsOrderBy>;
};

/** All input for the `deleteTopicByNodeId` mutation. */
export type DeleteTopicByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Topic` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTopicBySlugAndOrganizationId` mutation. */
export type DeleteTopicBySlugAndOrganizationIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  /** Each topic has a slug (a name made up of lowercase letters, digits, and hypens) to be addressed with. */
  slug: Scalars['String']['input'];
};

/** All input for the `deleteUserAuthentication` mutation. */
export type DeleteUserAuthenticationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `UserAuthentication` mutation. */
export type DeleteUserAuthenticationPayload = {
  __typename?: 'DeleteUserAuthenticationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedUserAuthenticationNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserAuthentication`. */
  user: Maybe<User>;
  /** The `UserAuthentication` that was deleted by this mutation. */
  userAuthentication: Maybe<UserAuthentication>;
  /** An edge for our `UserAuthentication`. May be used by Relay 1. */
  userAuthenticationEdge: Maybe<UserAuthenticationsEdge>;
};


/** The output of our delete `UserAuthentication` mutation. */
export type DeleteUserAuthenticationPayloadUserAuthenticationEdgeArgs = {
  orderBy?: Array<UserAuthenticationsOrderBy>;
};

/** All input for the `deleteUserAuthenticationByNodeId` mutation. */
export type DeleteUserAuthenticationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserAuthentication` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserAuthenticationByServiceAndIdentifier` mutation. */
export type DeleteUserAuthenticationByServiceAndIdentifierInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the user within the login service. */
  identifier: Scalars['String']['input'];
  /** The login service used, e.g. `twitter` or `github`. */
  service: Scalars['String']['input'];
};

/** All input for the `deleteUserEmail` mutation. */
export type DeleteUserEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `UserEmail` mutation. */
export type DeleteUserEmailPayload = {
  __typename?: 'DeleteUserEmailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedUserEmailNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  /** The `UserEmail` that was deleted by this mutation. */
  userEmail: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  userEmailEdge: Maybe<UserEmailsEdge>;
};


/** The output of our delete `UserEmail` mutation. */
export type DeleteUserEmailPayloadUserEmailEdgeArgs = {
  orderBy?: Array<UserEmailsOrderBy>;
};

/** All input for the `deleteUserEmailByNodeId` mutation. */
export type DeleteUserEmailByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserEmail` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserEmailByUserIdAndEmail` mutation. */
export type DeleteUserEmailByUserIdAndEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The users email address, in `a@b.c` format. */
  email: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};

/** All input for the `forgotPassword` mutation. */
export type ForgotPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
};

/** The output of our `forgotPassword` mutation. */
export type ForgotPasswordPayload = {
  __typename?: 'ForgotPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `inviteToOrganization` mutation. */
export type InviteToOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  username?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `inviteToOrganization` mutation. */
export type InviteToOrganizationPayload = {
  __typename?: 'InviteToOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type LoginInput = {
  password: Scalars['String']['input'];
  username: Scalars['String']['input'];
};

export type LoginPayload = {
  __typename?: 'LoginPayload';
  user: User;
};

export type LogoutPayload = {
  __typename?: 'LogoutPayload';
  success: Maybe<Scalars['Boolean']['output']>;
};

/** All input for the `makeEmailPrimary` mutation. */
export type MakeEmailPrimaryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  emailId: Scalars['UUID']['input'];
};

/** The output of our `makeEmailPrimary` mutation. */
export type MakeEmailPrimaryPayload = {
  __typename?: 'MakeEmailPrimaryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  userEmail: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  userEmailEdge: Maybe<UserEmailsEdge>;
};


/** The output of our `makeEmailPrimary` mutation. */
export type MakeEmailPrimaryPayloadUserEmailEdgeArgs = {
  orderBy?: Array<UserEmailsOrderBy>;
};

export type RegisterInput = {
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  password: Scalars['String']['input'];
  username: Scalars['String']['input'];
};

export type RegisterPayload = {
  __typename?: 'RegisterPayload';
  user: User;
};

/** All input for the `removeFromOrganization` mutation. */
export type RemoveFromOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** The output of our `removeFromOrganization` mutation. */
export type RemoveFromOrganizationPayload = {
  __typename?: 'RemoveFromOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `requestAccountDeletion` mutation. */
export type RequestAccountDeletionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `requestAccountDeletion` mutation. */
export type RequestAccountDeletionPayload = {
  __typename?: 'RequestAccountDeletionPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `resendEmailVerificationCode` mutation. */
export type ResendEmailVerificationCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  emailId: Scalars['UUID']['input'];
};

/** The output of our `resendEmailVerificationCode` mutation. */
export type ResendEmailVerificationCodePayload = {
  __typename?: 'ResendEmailVerificationCodePayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `resetPassword` mutation. */
export type ResetPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  newPassword: Scalars['String']['input'];
  resetToken: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};

/** The output of our `resetPassword` mutation. */
export type ResetPasswordPayload = {
  __typename?: 'ResetPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  success: Maybe<Scalars['Boolean']['output']>;
};

/** All input for the `sendRoomMessage` mutation. */
export type SendRoomMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  draftId: Scalars['UUID']['input'];
};

/** The output of our `sendRoomMessage` mutation. */
export type SendRoomMessagePayload = {
  __typename?: 'SendRoomMessagePayload';
  /** Reads a single `RoomMessage` that is related to this `RoomMessage`. */
  answeredMessage: Maybe<RoomMessage>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomMessage`. */
  room: Maybe<Room>;
  roomMessage: Maybe<RoomMessage>;
  /** An edge for our `RoomMessage`. May be used by Relay 1. */
  roomMessageEdge: Maybe<RoomMessagesEdge>;
  /** Reads a single `User` that is related to this `RoomMessage`. */
  sender: Maybe<User>;
};


/** The output of our `sendRoomMessage` mutation. */
export type SendRoomMessagePayloadRoomMessageEdgeArgs = {
  orderBy?: Array<RoomMessagesOrderBy>;
};

/** All input for the `transferOrganizationBillingContact` mutation. */
export type TransferOrganizationBillingContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** The output of our `transferOrganizationBillingContact` mutation. */
export type TransferOrganizationBillingContactPayload = {
  __typename?: 'TransferOrganizationBillingContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our `transferOrganizationBillingContact` mutation. */
export type TransferOrganizationBillingContactPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** All input for the `transferOrganizationOwnership` mutation. */
export type TransferOrganizationOwnershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** The output of our `transferOrganizationOwnership` mutation. */
export type TransferOrganizationOwnershipPayload = {
  __typename?: 'TransferOrganizationOwnershipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our `transferOrganizationOwnership` mutation. */
export type TransferOrganizationOwnershipPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** All input for the `updateFile` mutation. */
export type UpdateFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `File` being updated. */
  patch: FilePatch;
};

/** Represents an update to a `File`. Fields that are set will be updated. */
export type FilePatch = {
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mimeType?: InputMaybe<Scalars['String']['input']>;
  totalBytes?: InputMaybe<Scalars['Int']['input']>;
  uploadedBytes?: InputMaybe<Scalars['Int']['input']>;
};

/** The output of our update `File` mutation. */
export type UpdateFilePayload = {
  __typename?: 'UpdateFilePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `File`. */
  contributor: Maybe<User>;
  /** The `File` that was updated by this mutation. */
  file: Maybe<File>;
  /** An edge for our `File`. May be used by Relay 1. */
  fileEdge: Maybe<FilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `File` mutation. */
export type UpdateFilePayloadFileEdgeArgs = {
  orderBy?: Array<FilesOrderBy>;
};

/** All input for the `updateFileByNodeId` mutation. */
export type UpdateFileByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `File` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `File` being updated. */
  patch: FilePatch;
};

/** All input for the `updateOrganization` mutation. */
export type UpdateOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Organization` being updated. */
  patch: OrganizationPatch;
};

/** Represents an update to a `Organization`. Fields that are set will be updated. */
export type OrganizationPatch = {
  name?: InputMaybe<Scalars['String']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `Organization` mutation. */
export type UpdateOrganizationPayload = {
  __typename?: 'UpdateOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Organization` that was updated by this mutation. */
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Organization` mutation. */
export type UpdateOrganizationPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** All input for the `updateOrganizationByNodeId` mutation. */
export type UpdateOrganizationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Organization` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Organization` being updated. */
  patch: OrganizationPatch;
};

/** All input for the `updateOrganizationBySlug` mutation. */
export type UpdateOrganizationBySlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Organization` being updated. */
  patch: OrganizationPatch;
  slug: Scalars['String']['input'];
};

/** All input for the `updatePdfFile` mutation. */
export type UpdatePdfFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `PdfFile` being updated. */
  patch: PdfFilePatch;
};

/** Represents an update to a `PdfFile`. Fields that are set will be updated. */
export type PdfFilePatch = {
  contentAsPlainText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  metadata?: InputMaybe<Scalars['JSON']['input']>;
  pages?: InputMaybe<Scalars['Int']['input']>;
  thumbnailId?: InputMaybe<Scalars['UUID']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `PdfFile` mutation. */
export type UpdatePdfFilePayload = {
  __typename?: 'UpdatePdfFilePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `File` that is related to this `PdfFile`. */
  file: Maybe<File>;
  /** The `PdfFile` that was updated by this mutation. */
  pdfFile: Maybe<PdfFile>;
  /** An edge for our `PdfFile`. May be used by Relay 1. */
  pdfFileEdge: Maybe<PdfFilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `File` that is related to this `PdfFile`. */
  thumbnail: Maybe<File>;
};


/** The output of our update `PdfFile` mutation. */
export type UpdatePdfFilePayloadPdfFileEdgeArgs = {
  orderBy?: Array<PdfFilesOrderBy>;
};

/** All input for the `updatePdfFileByNodeId` mutation. */
export type UpdatePdfFileByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PdfFile` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PdfFile` being updated. */
  patch: PdfFilePatch;
};

/** All input for the `updateRoom` mutation. */
export type UpdateRoomInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Room` being updated. */
  patch: RoomPatch;
};

/** Represents an update to a `Room`. Fields that are set will be updated. */
export type RoomPatch = {
  /** Each room has an optional abstract. */
  abstract?: InputMaybe<Scalars['String']['input']>;
  isAnonymousPostingAllowed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Rooms can be visible for their subscribers only (`subscribers`), to all members of the room's organisation (`organization_members`), for all currently signed-in users (`signed_in_users`), or general in `public`. */
  isVisibleFor?: InputMaybe<RoomVisibility>;
  itemsAreVisibleFor?: InputMaybe<RoomRole>;
  /** Sometimes you want to hide items of the room from users who join later. `since_subscription` allows subscribers to see items that were added *after* their subscription. Similarly, `since_invitation` allows subscribers to see items that were added *after* they had been invited to the room. `since_specified_date` allows all subscribers to see items after `items_are_visible_since_date`. Finally, `always` means that all items are visible for the room's audience. */
  itemsAreVisibleSince?: InputMaybe<RoomHistoryVisibility>;
  /** Each room has an optional title. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `Room` mutation. */
export type UpdateRoomPayload = {
  __typename?: 'UpdateRoomPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Each room can optionally belong to an organization. */
  organization: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Room` that was updated by this mutation. */
  room: Maybe<Room>;
  /** An edge for our `Room`. May be used by Relay 1. */
  roomEdge: Maybe<RoomsEdge>;
};


/** The output of our update `Room` mutation. */
export type UpdateRoomPayloadRoomEdgeArgs = {
  orderBy?: Array<RoomsOrderBy>;
};

/** All input for the `updateRoomByNodeId` mutation. */
export type UpdateRoomByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Room` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Room` being updated. */
  patch: RoomPatch;
};

/** All input for the `updateRoomItem` mutation. */
export type UpdateRoomItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `RoomItem` being updated. */
  patch: RoomItemPatch;
};

/** Represents an update to a `RoomItem`. Fields that are set will be updated. */
export type RoomItemPatch = {
  contributedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Decides which role can see the room item. This also applies to more powerful roles. If the value is not set, the default settings of the room will be used. */
  isVisibleFor?: InputMaybe<RoomRole>;
  /** Decides if room items are always visible or only to users who subscribed before they were added. If the value is not set, the default settings of the room will be used. */
  isVisibleSince?: InputMaybe<RoomHistoryVisibility>;
  isVisibleSinceDate?: InputMaybe<Scalars['Datetime']['input']>;
  messageBody?: InputMaybe<Scalars['JSON']['input']>;
  /** The default order is 0, but you can change it to different values to sort the items. */
  order?: InputMaybe<Scalars['Float']['input']>;
  /** The items in a room can be connected to each other, basically forming one or multiple trees. For example, you can use this to keep track of conversations. */
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  topicId?: InputMaybe<Scalars['UUID']['input']>;
};

/** The output of our update `RoomItem` mutation. */
export type UpdateRoomItemPayload = {
  __typename?: 'UpdateRoomItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `RoomItem`. */
  contributor: Maybe<User>;
  /** Room items can be related in trees. */
  parent: Maybe<RoomItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomItem`. */
  room: Maybe<Room>;
  /** The `RoomItem` that was updated by this mutation. */
  roomItem: Maybe<RoomItem>;
  /** An edge for our `RoomItem`. May be used by Relay 1. */
  roomItemEdge: Maybe<RoomItemsEdge>;
  /** Reads a single `Topic` that is related to this `RoomItem`. */
  topic: Maybe<Topic>;
};


/** The output of our update `RoomItem` mutation. */
export type UpdateRoomItemPayloadRoomItemEdgeArgs = {
  orderBy?: Array<RoomItemsOrderBy>;
};

/** All input for the `updateRoomItemByNodeId` mutation. */
export type UpdateRoomItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoomItem` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `RoomItem` being updated. */
  patch: RoomItemPatch;
};

/** All input for the `updateRoomMessage` mutation. */
export type UpdateRoomMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `RoomMessage` being updated. */
  patch: RoomMessagePatch;
};

/** Represents an update to a `RoomMessage`. Fields that are set will be updated. */
export type RoomMessagePatch = {
  answeredMessageId?: InputMaybe<Scalars['UUID']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  language?: InputMaybe<Scalars['String']['input']>;
  sentAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The output of our update `RoomMessage` mutation. */
export type UpdateRoomMessagePayload = {
  __typename?: 'UpdateRoomMessagePayload';
  /** Reads a single `RoomMessage` that is related to this `RoomMessage`. */
  answeredMessage: Maybe<RoomMessage>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomMessage`. */
  room: Maybe<Room>;
  /** The `RoomMessage` that was updated by this mutation. */
  roomMessage: Maybe<RoomMessage>;
  /** An edge for our `RoomMessage`. May be used by Relay 1. */
  roomMessageEdge: Maybe<RoomMessagesEdge>;
  /** Reads a single `User` that is related to this `RoomMessage`. */
  sender: Maybe<User>;
};


/** The output of our update `RoomMessage` mutation. */
export type UpdateRoomMessagePayloadRoomMessageEdgeArgs = {
  orderBy?: Array<RoomMessagesOrderBy>;
};

/** All input for the `updateRoomMessageByNodeId` mutation. */
export type UpdateRoomMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoomMessage` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `RoomMessage` being updated. */
  patch: RoomMessagePatch;
};

/** All input for the `updateRoomSubscription` mutation. */
export type UpdateRoomSubscriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `RoomSubscription` being updated. */
  patch: RoomSubscriptionPatch;
};

/** Represents an update to a `RoomSubscription`. Fields that are set will be updated. */
export type RoomSubscriptionPatch = {
  lastVisitAt?: InputMaybe<Scalars['Datetime']['input']>;
  notifications?: InputMaybe<NotificationSetting>;
  /** Maintainers can manage subscriptions and delete the room. */
  role?: InputMaybe<RoomRole>;
};

/** The output of our update `RoomSubscription` mutation. */
export type UpdateRoomSubscriptionPayload = {
  __typename?: 'UpdateRoomSubscriptionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Room` that is related to this `RoomSubscription`. */
  room: Maybe<Room>;
  /** The `RoomSubscription` that was updated by this mutation. */
  roomSubscription: Maybe<RoomSubscription>;
  /** An edge for our `RoomSubscription`. May be used by Relay 1. */
  roomSubscriptionEdge: Maybe<RoomSubscriptionsEdge>;
  /** Reads a single `User` that is related to this `RoomSubscription`. */
  subscriber: Maybe<User>;
};


/** The output of our update `RoomSubscription` mutation. */
export type UpdateRoomSubscriptionPayloadRoomSubscriptionEdgeArgs = {
  orderBy?: Array<RoomSubscriptionsOrderBy>;
};

/** All input for the `updateRoomSubscriptionByNodeId` mutation. */
export type UpdateRoomSubscriptionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoomSubscription` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `RoomSubscription` being updated. */
  patch: RoomSubscriptionPatch;
};

/** All input for the `updateRoomSubscriptionBySubscriberIdAndRoomId` mutation. */
export type UpdateRoomSubscriptionBySubscriberIdAndRoomIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `RoomSubscription` being updated. */
  patch: RoomSubscriptionPatch;
  roomId: Scalars['UUID']['input'];
  /** The subscribing user. */
  subscriberId: Scalars['UUID']['input'];
};

/** All input for the `updateTopic` mutation. */
export type UpdateTopicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Topic` being updated. */
  patch: TopicPatch;
};

/** Represents an update to a `Topic`. Fields that are set will be updated. */
export type TopicPatch = {
  authorId?: InputMaybe<Scalars['UUID']['input']>;
  /** The topics contents as JSON. Can be converted to HTML with https://tiptap.dev/api/utilities/html */
  content?: InputMaybe<Scalars['JSON']['input']>;
  /** Topics can be visible to anyone (`public`), to all signed-in users (`signed_in_users`), or within an organization (`organization_members`). */
  isVisibleFor?: InputMaybe<TopicVisibility>;
  /** Each topic can optionally be licensed. Hyperlinks are allowed. */
  license?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Each topic has a slug (a name made up of lowercase letters, digits, and hypens) to be addressed with. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** Each topic can be categorized using tags. */
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Each topic has an optional title. In case of an article, this would be the headline. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `Topic` mutation. */
export type UpdateTopicPayload = {
  __typename?: 'UpdateTopicPayload';
  /** Each topic has an author. The field might be null when the original author has unregistered from the application. */
  author: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `Topic`. */
  organization: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `Topic` that was updated by this mutation. */
  topic: Maybe<Topic>;
  /** An edge for our `Topic`. May be used by Relay 1. */
  topicEdge: Maybe<TopicsEdge>;
};


/** The output of our update `Topic` mutation. */
export type UpdateTopicPayloadTopicEdgeArgs = {
  orderBy?: Array<TopicsOrderBy>;
};

/** All input for the `updateTopicByNodeId` mutation. */
export type UpdateTopicByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Topic` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Topic` being updated. */
  patch: TopicPatch;
};

/** All input for the `updateTopicBySlugAndOrganizationId` mutation. */
export type UpdateTopicBySlugAndOrganizationIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Topic` being updated. */
  patch: TopicPatch;
  /** Each topic has a slug (a name made up of lowercase letters, digits, and hypens) to be addressed with. */
  slug: Scalars['String']['input'];
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the user. */
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  /** Optional avatar URL. */
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  /** Users can be notified about activities in the rooms they have subscribed to. This is the default setting. You can change it for each room. */
  defaultHandlingOfNotifications?: InputMaybe<NotificationSetting>;
  /** Public-facing name (or pseudonym) of the user. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** If there are any delayed notifications, they are sent at this time every day. */
  sendingTimeForDeferredNotifications?: InputMaybe<Scalars['Time']['input']>;
  /** Public-facing username (or 'handle') of the user. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `User` that was updated by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: Array<UsersOrderBy>;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserByUsername` mutation. */
export type UpdateUserByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  /** Public-facing username (or 'handle') of the user. */
  username: Scalars['String']['input'];
};

/** All input for the `verifyEmail` mutation. */
export type VerifyEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
  userEmailId: Scalars['UUID']['input'];
};

/** The output of our `verifyEmail` mutation. */
export type VerifyEmailPayload = {
  __typename?: 'VerifyEmailPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type ChangePasswordMutationVariables = Exact<{
  oldPassword: Scalars['String']['input'];
  newPassword: Scalars['String']['input'];
}>;


export type ChangePasswordMutation = { __typename?: 'Mutation', changePassword: { __typename?: 'ChangePasswordPayload', success: boolean | null } | null };

export type CreateRoomItemAttachmentMutationVariables = Exact<{
  input: RoomItemAttachmentInput;
}>;


export type CreateRoomItemAttachmentMutation = { __typename?: 'Mutation', createRoomItemAttachment: { __typename?: 'CreateRoomItemAttachmentPayload', roomItem: { __typename?: 'RoomItem', id: string, room: { __typename?: 'Room', id: string } | null } | null, roomItemAttachment: { __typename?: 'RoomItemAttachment', id: string, createdAt: string } | null } | null };

export type CreateRoomItemMutationVariables = Exact<{
  item: RoomItemInput;
}>;


export type CreateRoomItemMutation = { __typename?: 'Mutation', createRoomItem: { __typename?: 'CreateRoomItemPayload', roomItem: { __typename?: 'RoomItem', id: string, createdAt: string, contributor: { __typename?: 'User', id: string, username: string } | null } | null, room: { __typename?: 'Room', id: string, items: { __typename?: 'RoomItemsConnection', totalCount: number } } | null } | null };

export type CreateRoomMessageMutationVariables = Exact<{
  message: RoomMessageInput;
}>;


export type CreateRoomMessageMutation = { __typename?: 'Mutation', createRoomMessage: { __typename?: 'CreateRoomMessagePayload', roomMessage: { __typename?: 'RoomMessage', id: string, createdAt: string, body: string | null, sender: { __typename?: 'User', id: string, username: string } | null } | null, room: { __typename?: 'Room', id: string, latestMessage: { __typename?: 'RoomMessage', id: string } | null, messages: { __typename?: 'RoomMessagesConnection', totalCount: number } } | null } | null };

export type CreateRoomSubscriptionMutationVariables = Exact<{
  subscription: RoomSubscriptionInput;
}>;


export type CreateRoomSubscriptionMutation = { __typename?: 'Mutation', createRoomSubscription: { __typename?: 'CreateRoomSubscriptionPayload', roomSubscription: { __typename?: 'RoomSubscription', id: string, createdAt: string } | null, room: { __typename?: 'Room', id: string, nSubscriptions: any | null } | null } | null };

export type CreateRoomMutationVariables = Exact<{
  room: RoomInput;
}>;


export type CreateRoomMutation = { __typename?: 'Mutation', createRoom: { __typename?: 'CreateRoomPayload', room: { __typename?: 'Room', id: string } | null } | null };

export type CreateTopicMutationVariables = Exact<{
  topic: TopicInput;
}>;


export type CreateTopicMutation = { __typename?: 'Mutation', createTopic: { __typename?: 'CreateTopicPayload', topic: { __typename?: 'Topic', id: string, slug: string } | null } | null };

export type CurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUserQuery = { __typename?: 'Query', currentUser: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null };

export type DeleteRoomItemAttachmentMutationVariables = Exact<{
  id: Scalars['UUID']['input'];
}>;


export type DeleteRoomItemAttachmentMutation = { __typename?: 'Mutation', deleteRoomItemAttachment: { __typename?: 'DeleteRoomItemAttachmentPayload', roomItem: { __typename?: 'RoomItem', id: string } | null } | null };

export type DeleteRoomItemMutationVariables = Exact<{
  id: Scalars['UUID']['input'];
}>;


export type DeleteRoomItemMutation = { __typename?: 'Mutation', deleteRoomItem: { __typename?: 'DeleteRoomItemPayload', room: { __typename?: 'Room', id: string } | null } | null };

export type DeleteRoomSubscriptionByRoomAndUserMutationVariables = Exact<{
  roomId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
}>;


export type DeleteRoomSubscriptionByRoomAndUserMutation = { __typename?: 'Mutation', deleteRoomSubscriptionBySubscriberIdAndRoomId: { __typename?: 'DeleteRoomSubscriptionPayload', roomSubscription: { __typename?: 'RoomSubscription', id: string } | null, room: { __typename?: 'Room', id: string } | null } | null };

export type FetchDetailedTopicsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TopicCondition>;
  filter?: InputMaybe<TopicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TopicsOrderBy> | TopicsOrderBy>;
}>;


export type FetchDetailedTopicsQuery = { __typename?: 'Query', topics: { __typename?: 'TopicsConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean }, nodes: Array<{ __typename?: 'Topic', slug: string, tags: Array<string | null>, id: string, title: string | null, license: string | null, content: any, author: { __typename?: 'User', id: string, username: string } | null }> } | null };

export type RoomItemAttachmentAsLinkFragment = { __typename?: 'RoomItemAttachment', id: string, fileId: string | null, topicId: string | null, file: { __typename?: 'File', id: string, filename: string | null, mimeType: string | null, pdfFile: { __typename?: 'PdfFile', id: string, pages: number } | null } | null, topic: { __typename?: 'Topic', id: string, title: string | null, slug: string, contentPreview: any | null, author: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null } | null };

export type FetchRoomItemAttachmentsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomItemAttachmentCondition>;
  filter?: InputMaybe<RoomItemAttachmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomItemAttachmentsOrderBy> | RoomItemAttachmentsOrderBy>;
}>;


export type FetchRoomItemAttachmentsQuery = { __typename?: 'Query', roomItemAttachments: { __typename?: 'RoomItemAttachmentsConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean }, nodes: Array<{ __typename?: 'RoomItemAttachment', id: string, fileId: string | null, topicId: string | null, file: { __typename?: 'File', id: string, filename: string | null, mimeType: string | null, pdfFile: { __typename?: 'PdfFile', id: string, pages: number } | null } | null, topic: { __typename?: 'Topic', id: string, title: string | null, slug: string, contentPreview: any | null, author: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null } | null }> } | null };

export type FetchRoomItemsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomItemCondition>;
  filter?: InputMaybe<RoomItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomItemsOrderBy> | RoomItemsOrderBy>;
}>;


export type FetchRoomItemsQuery = { __typename?: 'Query', roomItems: { __typename?: 'RoomItemsConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean }, nodes: Array<{ __typename?: 'RoomItem', id: string, type: RoomItemType, order: number, parentId: string | null, messageBody: any | null, updatedAt: string, contributedAt: string | null, isVisibleFor: RoomRole | null, isVisibleSince: RoomHistoryVisibility | null, isVisibleSinceDate: string | null, nthItemSinceLastVisit: any | null, children: { __typename?: 'RoomItemsConnection', totalCount: number }, contributor: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null, parent: { __typename?: 'RoomItem', id: string, type: RoomItemType, createdAt: string, contributedAt: string | null, contributor: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null } | null, room: { __typename?: 'Room', id: string, itemsAreVisibleFor: RoomRole, itemsAreVisibleSince: RoomHistoryVisibility, itemsAreVisibleSinceDate: string } | null, topic: { __typename?: 'Topic', id: string, title: string | null, slug: string, contentPreview: any | null } | null, roomItemAttachments: { __typename?: 'RoomItemAttachmentsConnection', nodes: Array<{ __typename?: 'RoomItemAttachment', id: string, fileId: string | null, topicId: string | null, file: { __typename?: 'File', id: string, filename: string | null, mimeType: string | null, pdfFile: { __typename?: 'PdfFile', id: string, pages: number } | null } | null, topic: { __typename?: 'Topic', id: string, title: string | null, slug: string, contentPreview: any | null, author: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null } | null }> } }> } | null };

export type FetchRoomMessagesQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomMessageCondition>;
  filter?: InputMaybe<RoomMessageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomMessagesOrderBy> | RoomMessagesOrderBy>;
}>;


export type FetchRoomMessagesQuery = { __typename?: 'Query', roomMessages: { __typename?: 'RoomMessagesConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean }, nodes: Array<{ __typename?: 'RoomMessage', body: string | null, createdAt: string, id: string, sentAt: string | null, updatedAt: string, room: { __typename?: 'Room', id: string, title: string | null } | null, sender: { __typename?: 'User', id: string, username: string } | null }> } | null };

export type FetchRoomSubscriptionsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomSubscriptionCondition>;
  filter?: InputMaybe<RoomSubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomSubscriptionsOrderBy> | RoomSubscriptionsOrderBy>;
}>;


export type FetchRoomSubscriptionsQuery = { __typename?: 'Query', roomSubscriptions: { __typename?: 'RoomSubscriptionsConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean }, nodes: Array<{ __typename?: 'RoomSubscription', id: string, subscriberId: string, roomId: string, lastVisitAt: string | null, notifications: NotificationSetting, role: RoomRole, createdAt: string, updatedAt: string, subscriber: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null, room: { __typename?: 'Room', id: string, title: string | null } | null }> } | null };

export type FetchRoomsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoomCondition>;
  filter?: InputMaybe<RoomFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoomsOrderBy> | RoomsOrderBy>;
}>;


export type FetchRoomsQuery = { __typename?: 'Query', rooms: { __typename?: 'RoomsConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor: any | null, endCursor: any | null }, nodes: Array<{ __typename?: 'Room', id: string, title: string | null, abstract: string | null, createdAt: string, nSubscriptions: any | null, hasSubscriptions: boolean | null, nItems: any | null, nItemsSinceLastVisit: any | null, isVisibleFor: RoomVisibility, itemsAreVisibleFor: RoomRole, draftItemsAreVisibleFor: RoomRole | null, latestItem: { __typename?: 'RoomItem', id: string, contributedAt: string | null, nthItemSinceLastVisit: any | null, contributor: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null } | null, mySubscription: { __typename?: 'RoomSubscription', id: string, subscriberId: string, roomId: string, lastVisitAt: string | null, notifications: NotificationSetting, role: RoomRole, createdAt: string, updatedAt: string, subscriber: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null, room: { __typename?: 'Room', id: string, title: string | null } | null } | null }> } | null };

export type FetchTopicsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TopicCondition>;
  filter?: InputMaybe<TopicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TopicsOrderBy> | TopicsOrderBy>;
}>;


export type FetchTopicsQuery = { __typename?: 'Query', topics: { __typename?: 'TopicsConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean }, nodes: Array<{ __typename?: 'Topic', slug: string, tags: Array<string | null>, id: string, title: string | null, license: string | null, organization: { __typename?: 'Organization', id: string, slug: string } | null, author: { __typename?: 'User', id: string, username: string } | null }> } | null };

export type GetCurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCurrentUserQuery = { __typename?: 'Query', currentUser: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null, userEmails: { __typename?: 'UserEmailsConnection', nodes: Array<{ __typename?: 'UserEmail', id: string, isPrimary: boolean, email: string }> } } | null };

export type GetRoomMessageQueryVariables = Exact<{
  id: Scalars['UUID']['input'];
}>;


export type GetRoomMessageQuery = { __typename?: 'Query', roomMessage: { __typename?: 'RoomMessage', id: string, body: string | null, sender: { __typename?: 'User', id: string, username: string } | null } | null };

export type ShortRoomSubscriptionFragment = { __typename?: 'RoomSubscription', id: string, subscriberId: string, roomId: string, lastVisitAt: string | null, notifications: NotificationSetting, role: RoomRole, createdAt: string, updatedAt: string, subscriber: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null, room: { __typename?: 'Room', id: string, title: string | null } | null };

export type GetRoomSubscriptionOfUserInRoomQueryVariables = Exact<{
  userId: Scalars['UUID']['input'];
  roomId: Scalars['UUID']['input'];
}>;


export type GetRoomSubscriptionOfUserInRoomQuery = { __typename?: 'Query', roomSubscriptionBySubscriberIdAndRoomId: { __typename?: 'RoomSubscription', id: string, subscriberId: string, roomId: string, lastVisitAt: string | null, notifications: NotificationSetting, role: RoomRole, createdAt: string, updatedAt: string, subscriber: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null, room: { __typename?: 'Room', id: string, title: string | null } | null } | null };

export type GetRoomQueryVariables = Exact<{
  id: Scalars['UUID']['input'];
}>;


export type GetRoomQuery = { __typename?: 'Query', room: { __typename?: 'Room', id: string, title: string | null, abstract: string | null, hasSubscriptions: boolean | null, nSubscriptions: any | null, isVisibleFor: RoomVisibility, itemsAreVisibleFor: RoomRole, mySubscription: { __typename?: 'RoomSubscription', id: string, subscriberId: string, roomId: string, lastVisitAt: string | null, notifications: NotificationSetting, role: RoomRole, createdAt: string, updatedAt: string, subscriber: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null, room: { __typename?: 'Room', id: string, title: string | null } | null } | null, latestItem: { __typename?: 'RoomItem', id: string, contributedAt: string | null, nthItemSinceLastVisit: any | null, contributor: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null } | null } | null };

export type GetTopicBySlugQueryVariables = Exact<{
  slug: Scalars['String']['input'];
  organizationId: Scalars['UUID']['input'];
}>;


export type GetTopicBySlugQuery = { __typename?: 'Query', topicBySlugAndOrganizationId: { __typename?: 'Topic', id: string, title: string | null, tags: Array<string | null>, slug: string, content: any } | null };

export type GetTopicQueryVariables = Exact<{
  id: Scalars['UUID']['input'];
}>;


export type GetTopicQuery = { __typename?: 'Query', topic: { __typename?: 'Topic', id: string, title: string | null, tags: Array<string | null>, slug: string, content: any } | null };

export type GetUserByUsernameQueryVariables = Exact<{
  username: Scalars['String']['input'];
}>;


export type GetUserByUsernameQuery = { __typename?: 'Query', userByUsername: { __typename?: 'User', id: string, username: string } | null };

export type GlobalSearchQueryVariables = Exact<{
  term: Scalars['String']['input'];
  entities?: InputMaybe<Array<TextsearchableEntity> | TextsearchableEntity>;
  filter?: InputMaybe<TextsearchMatchFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TextsearchMatchCondition>;
}>;


export type GlobalSearchQuery = { __typename?: 'Query', globalSearch: { __typename?: 'TextsearchMatchesConnection', totalCount: number, nodes: Array<{ __typename?: 'TextsearchMatch', id: string, rankOrSimilarity: number, snippet: string | null, title: string, type: TextsearchableEntity }> } | null };

export type LoginMutationVariables = Exact<{
  username: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type LoginMutation = { __typename?: 'Mutation', login: { __typename?: 'LoginPayload', user: { __typename?: 'User', id: string, username: string } } | null };

export type LogoutMutationVariables = Exact<{ [key: string]: never; }>;


export type LogoutMutation = { __typename?: 'Mutation', logout: { __typename?: 'LogoutPayload', success: boolean | null } | null };

export type RegisterUserMutationVariables = Exact<{
  form: RegisterInput;
}>;


export type RegisterUserMutation = { __typename?: 'Mutation', register: { __typename?: 'RegisterPayload', user: { __typename?: 'User', id: string, username: string, createdAt: string } } | null };

export type ForgotPasswordMutationVariables = Exact<{
  email: Scalars['String']['input'];
}>;


export type ForgotPasswordMutation = { __typename?: 'Mutation', forgotPassword: { __typename?: 'ForgotPasswordPayload', clientMutationId: string | null } | null };

export type ResetPasswordMutationVariables = Exact<{
  id: Scalars['UUID']['input'];
  token: Scalars['String']['input'];
  newPassword: Scalars['String']['input'];
}>;


export type ResetPasswordMutation = { __typename?: 'Mutation', resetPassword: { __typename?: 'ResetPasswordPayload', success: boolean | null } | null };

export type RoomItemAsListItemFragment = { __typename?: 'RoomItem', id: string, type: RoomItemType, order: number, parentId: string | null, messageBody: any | null, updatedAt: string, contributedAt: string | null, isVisibleFor: RoomRole | null, isVisibleSince: RoomHistoryVisibility | null, isVisibleSinceDate: string | null, nthItemSinceLastVisit: any | null, children: { __typename?: 'RoomItemsConnection', totalCount: number }, contributor: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null, parent: { __typename?: 'RoomItem', id: string, type: RoomItemType, createdAt: string, contributedAt: string | null, contributor: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null } | null, room: { __typename?: 'Room', id: string, itemsAreVisibleFor: RoomRole, itemsAreVisibleSince: RoomHistoryVisibility, itemsAreVisibleSinceDate: string } | null, topic: { __typename?: 'Topic', id: string, title: string | null, slug: string, contentPreview: any | null } | null, roomItemAttachments: { __typename?: 'RoomItemAttachmentsConnection', nodes: Array<{ __typename?: 'RoomItemAttachment', id: string, fileId: string | null, topicId: string | null, file: { __typename?: 'File', id: string, filename: string | null, mimeType: string | null, pdfFile: { __typename?: 'PdfFile', id: string, pages: number } | null } | null, topic: { __typename?: 'Topic', id: string, title: string | null, slug: string, contentPreview: any | null, author: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null } | null }> } };

export type ShortProfileFragment = { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null };

export type UpdateRoomItemMutationVariables = Exact<{
  oldId: Scalars['UUID']['input'];
  patch: RoomItemPatch;
}>;


export type UpdateRoomItemMutation = { __typename?: 'Mutation', updateRoomItem: { __typename?: 'UpdateRoomItemPayload', roomItem: { __typename?: 'RoomItem', id: string, updatedAt: string, parent: { __typename?: 'RoomItem', id: string } | null } | null } | null };

export type UpdateRoomMessageMutationVariables = Exact<{
  oldId: Scalars['UUID']['input'];
  patch: RoomMessagePatch;
}>;


export type UpdateRoomMessageMutation = { __typename?: 'Mutation', updateRoomMessage: { __typename?: 'UpdateRoomMessagePayload', roomMessage: { __typename?: 'RoomMessage', id: string, updatedAt: string, answeredMessage: { __typename?: 'RoomMessage', id: string } | null } | null } | null };

export type UpdateRoomSubscriptionMutationVariables = Exact<{
  oldId: Scalars['UUID']['input'];
  patch: RoomSubscriptionPatch;
}>;


export type UpdateRoomSubscriptionMutation = { __typename?: 'Mutation', updateRoomSubscription: { __typename?: 'UpdateRoomSubscriptionPayload', roomSubscription: { __typename?: 'RoomSubscription', id: string, subscriberId: string, roomId: string, lastVisitAt: string | null, notifications: NotificationSetting, role: RoomRole, createdAt: string, updatedAt: string, subscriber: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null, room: { __typename?: 'Room', id: string, title: string | null } | null } | null } | null };

export type UpdateRoomMutationVariables = Exact<{
  oldId: Scalars['UUID']['input'];
  patch: RoomPatch;
}>;


export type UpdateRoomMutation = { __typename?: 'Mutation', updateRoom: { __typename?: 'UpdateRoomPayload', room: { __typename?: 'Room', id: string, updatedAt: string } | null } | null };

export type UpdateTopicMutationVariables = Exact<{
  oldId: Scalars['UUID']['input'];
  patch: TopicPatch;
}>;


export type UpdateTopicMutation = { __typename?: 'Mutation', updateTopic: { __typename?: 'UpdateTopicPayload', topic: { __typename?: 'Topic', id: string, slug: string, updatedAt: string } | null } | null };

export type VerifyEmailMutationVariables = Exact<{
  id: Scalars['UUID']['input'];
  token: Scalars['String']['input'];
}>;


export type VerifyEmailMutation = { __typename?: 'Mutation', verifyEmail: { __typename?: 'VerifyEmailPayload', success: boolean | null, query: { __typename?: 'Query', currentUser: { __typename?: 'User', id: string, isAdmin: boolean, isVerified: boolean, username: string, avatarUrl: string | null } | null } | null } | null };

export const ShortProfile = gql`
    fragment ShortProfile on User {
  id
  isAdmin
  isVerified
  username
  avatarUrl
}
    `;
export const ShortRoomSubscription = gql`
    fragment ShortRoomSubscription on RoomSubscription {
  id
  subscriberId
  subscriber {
    id
    ...ShortProfile
  }
  roomId
  room {
    id
    title
  }
  lastVisitAt
  notifications
  role
  createdAt
  updatedAt
}
    ${ShortProfile}`;
export const RoomItemAttachmentAsLink = gql`
    fragment RoomItemAttachmentAsLink on RoomItemAttachment {
  id
  fileId
  file {
    id
    filename
    mimeType
    pdfFile {
      id
      pages
    }
  }
  topicId
  topic {
    id
    title
    slug
    contentPreview
    author {
      id
      ...ShortProfile
    }
  }
}
    ${ShortProfile}`;
export const RoomItemAsListItem = gql`
    fragment RoomItemAsListItem on RoomItem {
  id
  type
  children {
    totalCount
  }
  contributor {
    id
    ...ShortProfile
  }
  order
  parentId
  parent {
    id
    type
    createdAt
    contributedAt
    contributor {
      id
      ...ShortProfile
    }
  }
  room {
    id
    itemsAreVisibleFor
    itemsAreVisibleSince
    itemsAreVisibleSinceDate
  }
  topic {
    id
    title
    slug
    contentPreview
  }
  roomItemAttachments(orderBy: [CREATED_AT_ASC]) {
    nodes {
      id
      ...RoomItemAttachmentAsLink
    }
  }
  messageBody
  updatedAt
  contributedAt
  isVisibleFor
  isVisibleSince
  isVisibleSinceDate
  nthItemSinceLastVisit
}
    ${ShortProfile}
${RoomItemAttachmentAsLink}`;
export const ChangePassword = gql`
    mutation ChangePassword($oldPassword: String!, $newPassword: String!) {
  changePassword(input: {oldPassword: $oldPassword, newPassword: $newPassword}) {
    success: boolean
  }
}
    `;
export const CreateRoomItemAttachment = gql`
    mutation CreateRoomItemAttachment($input: RoomItemAttachmentInput!) {
  createRoomItemAttachment(input: {roomItemAttachment: $input}) {
    roomItem {
      id
      room {
        id
      }
    }
    roomItemAttachment {
      id
      createdAt
    }
  }
}
    `;
export const CreateRoomItem = gql`
    mutation CreateRoomItem($item: RoomItemInput!) {
  createRoomItem(input: {roomItem: $item}) {
    roomItem {
      id
      createdAt
      contributor {
        id
        username
      }
    }
    room {
      id
      items {
        totalCount
      }
    }
  }
}
    `;
export const CreateRoomMessage = gql`
    mutation CreateRoomMessage($message: RoomMessageInput!) {
  createRoomMessage(input: {roomMessage: $message}) {
    roomMessage {
      id
      createdAt
      sender {
        id
        username
      }
      body
    }
    room {
      id
      latestMessage {
        id
      }
      messages {
        totalCount
      }
    }
  }
}
    `;
export const CreateRoomSubscription = gql`
    mutation CreateRoomSubscription($subscription: RoomSubscriptionInput!) {
  createRoomSubscription(input: {roomSubscription: $subscription}) {
    roomSubscription {
      id
      createdAt
    }
    room {
      id
      nSubscriptions
    }
  }
}
    `;
export const CreateRoom = gql`
    mutation CreateRoom($room: RoomInput!) {
  createRoom(input: {room: $room}) {
    room {
      id
    }
  }
}
    `;
export const CreateTopic = gql`
    mutation CreateTopic($topic: TopicInput!) {
  createTopic(input: {topic: $topic}) {
    topic {
      id
      slug
    }
  }
}
    `;
export const CurrentUser = gql`
    query CurrentUser {
  currentUser {
    id
    ...ShortProfile
  }
}
    ${ShortProfile}`;
export const DeleteRoomItemAttachment = gql`
    mutation DeleteRoomItemAttachment($id: UUID!) {
  deleteRoomItemAttachment(input: {id: $id}) {
    roomItem {
      id
    }
  }
}
    `;
export const DeleteRoomItem = gql`
    mutation DeleteRoomItem($id: UUID!) {
  deleteRoomItem(input: {id: $id}) {
    room {
      id
    }
  }
}
    `;
export const DeleteRoomSubscriptionByRoomAndUser = gql`
    mutation DeleteRoomSubscriptionByRoomAndUser($roomId: UUID!, $userId: UUID!) {
  deleteRoomSubscriptionBySubscriberIdAndRoomId(input: {roomId: $roomId, subscriberId: $userId}) {
    roomSubscription {
      id
    }
    room {
      id
    }
  }
}
    `;
export const FetchDetailedTopics = gql`
    query FetchDetailedTopics($after: Cursor, $before: Cursor, $condition: TopicCondition, $filter: TopicFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [TopicsOrderBy!]) {
  topics(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    nodes {
      author {
        id
        username
      }
      slug
      tags
      id
      title
      license
      content
    }
  }
}
    `;
export const FetchRoomItemAttachments = gql`
    query FetchRoomItemAttachments($after: Cursor, $before: Cursor, $condition: RoomItemAttachmentCondition, $filter: RoomItemAttachmentFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [RoomItemAttachmentsOrderBy!]) {
  roomItemAttachments(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    nodes {
      ...RoomItemAttachmentAsLink
    }
  }
}
    ${RoomItemAttachmentAsLink}`;
export const FetchRoomItems = gql`
    query FetchRoomItems($after: Cursor, $before: Cursor, $condition: RoomItemCondition, $filter: RoomItemFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [RoomItemsOrderBy!]) {
  roomItems(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    nodes {
      id
      ...RoomItemAsListItem
    }
  }
}
    ${RoomItemAsListItem}`;
export const FetchRoomMessages = gql`
    query FetchRoomMessages($after: Cursor, $before: Cursor, $condition: RoomMessageCondition, $filter: RoomMessageFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [RoomMessagesOrderBy!]) {
  roomMessages(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    nodes {
      body
      createdAt
      id
      room {
        id
        title
      }
      sender {
        id
        username
      }
      sentAt
      updatedAt
    }
  }
}
    `;
export const FetchRoomSubscriptions = gql`
    query FetchRoomSubscriptions($after: Cursor, $before: Cursor, $condition: RoomSubscriptionCondition, $filter: RoomSubscriptionFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [RoomSubscriptionsOrderBy!]) {
  roomSubscriptions(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    nodes {
      id
      ...ShortRoomSubscription
    }
  }
}
    ${ShortRoomSubscription}`;
export const FetchRooms = gql`
    query FetchRooms($after: Cursor, $before: Cursor, $condition: RoomCondition, $filter: RoomFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [RoomsOrderBy!]) {
  rooms(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    nodes {
      id
      title
      abstract
      createdAt
      latestItem {
        id
        contributedAt
        contributor {
          id
          ...ShortProfile
        }
        nthItemSinceLastVisit
      }
      mySubscription {
        id
        ...ShortRoomSubscription
      }
      nSubscriptions
      hasSubscriptions
      nItems
      nItemsSinceLastVisit
      isVisibleFor
      itemsAreVisibleFor
      draftItemsAreVisibleFor
    }
  }
}
    ${ShortProfile}
${ShortRoomSubscription}`;
export const FetchTopics = gql`
    query FetchTopics($after: Cursor, $before: Cursor, $condition: TopicCondition, $filter: TopicFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [TopicsOrderBy!]) {
  topics(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    nodes {
      organization {
        id
        slug
      }
      author {
        id
        username
      }
      slug
      tags
      id
      title
      license
    }
  }
}
    `;
export const GetCurrentUser = gql`
    query GetCurrentUser {
  currentUser {
    id
    ...ShortProfile
    userEmails {
      nodes {
        id
        isPrimary
        email
      }
    }
  }
}
    ${ShortProfile}`;
export const GetRoomMessage = gql`
    query GetRoomMessage($id: UUID!) {
  roomMessage(id: $id) {
    id
    body
    sender {
      id
      username
    }
  }
}
    `;
export const GetRoomSubscriptionOfUserInRoom = gql`
    query GetRoomSubscriptionOfUserInRoom($userId: UUID!, $roomId: UUID!) {
  roomSubscriptionBySubscriberIdAndRoomId(roomId: $roomId, subscriberId: $userId) {
    id
    ...ShortRoomSubscription
  }
}
    ${ShortRoomSubscription}`;
export const GetRoom = gql`
    query GetRoom($id: UUID!) {
  room(id: $id) {
    id
    title
    abstract
    hasSubscriptions
    nSubscriptions
    isVisibleFor
    itemsAreVisibleFor
    mySubscription {
      id
      ...ShortRoomSubscription
    }
    latestItem {
      id
      contributedAt
      contributor {
        id
        ...ShortProfile
      }
      nthItemSinceLastVisit
    }
  }
}
    ${ShortRoomSubscription}
${ShortProfile}`;
export const GetTopicBySlug = gql`
    query GetTopicBySlug($slug: String!, $organizationId: UUID!) {
  topicBySlugAndOrganizationId(organizationId: $organizationId, slug: $slug) {
    id
    title
    tags
    slug
    content
  }
}
    `;
export const GetTopic = gql`
    query GetTopic($id: UUID!) {
  topic(id: $id) {
    id
    title
    tags
    slug
    content
  }
}
    `;
export const GetUserByUsername = gql`
    query GetUserByUsername($username: String!) {
  userByUsername(username: $username) {
    id
    username
  }
}
    `;
export const GlobalSearch = gql`
    query GlobalSearch($term: String!, $entities: [TextsearchableEntity!] = [TOPIC, USER], $filter: TextsearchMatchFilter, $first: Int, $last: Int, $after: Cursor, $before: Cursor, $condition: TextsearchMatchCondition) {
  globalSearch(term: $term, entities: $entities, filter: $filter, first: $first, last: $last, after: $after, before: $before, condition: $condition) {
    totalCount
    nodes {
      id
      rankOrSimilarity
      snippet
      title
      type
    }
  }
}
    `;
export const Login = gql`
    mutation Login($username: String!, $password: String!) {
  login(input: {username: $username, password: $password}) {
    user {
      id
      username
    }
  }
}
    `;
export const Logout = gql`
    mutation Logout {
  logout {
    success
  }
}
    `;
export const RegisterUser = gql`
    mutation RegisterUser($form: RegisterInput!) {
  register(input: $form) {
    user {
      id
      username
      createdAt
    }
  }
}
    `;
export const ForgotPassword = gql`
    mutation ForgotPassword($email: String!) {
  forgotPassword(input: {email: $email}) {
    clientMutationId
  }
}
    `;
export const ResetPassword = gql`
    mutation ResetPassword($id: UUID!, $token: String!, $newPassword: String!) {
  resetPassword(input: {userId: $id, resetToken: $token, newPassword: $newPassword}) {
    success
  }
}
    `;
export const UpdateRoomItem = gql`
    mutation UpdateRoomItem($oldId: UUID!, $patch: RoomItemPatch!) {
  updateRoomItem(input: {patch: $patch, id: $oldId}) {
    roomItem {
      id
      updatedAt
      parent {
        id
      }
    }
  }
}
    `;
export const UpdateRoomMessage = gql`
    mutation UpdateRoomMessage($oldId: UUID!, $patch: RoomMessagePatch!) {
  updateRoomMessage(input: {patch: $patch, id: $oldId}) {
    roomMessage {
      id
      updatedAt
      answeredMessage {
        id
      }
    }
  }
}
    `;
export const UpdateRoomSubscription = gql`
    mutation UpdateRoomSubscription($oldId: UUID!, $patch: RoomSubscriptionPatch!) {
  updateRoomSubscription(input: {patch: $patch, id: $oldId}) {
    roomSubscription {
      id
      ...ShortRoomSubscription
    }
  }
}
    ${ShortRoomSubscription}`;
export const UpdateRoom = gql`
    mutation UpdateRoom($oldId: UUID!, $patch: RoomPatch!) {
  updateRoom(input: {patch: $patch, id: $oldId}) {
    room {
      id
      updatedAt
    }
  }
}
    `;
export const UpdateTopic = gql`
    mutation UpdateTopic($oldId: UUID!, $patch: TopicPatch!) {
  updateTopic(input: {patch: $patch, id: $oldId}) {
    topic {
      id
      slug
      updatedAt
    }
  }
}
    `;
export const VerifyEmail = gql`
    mutation VerifyEmail($id: UUID!, $token: String!) {
  verifyEmail(input: {userEmailId: $id, token: $token}) {
    success: boolean
    query {
      currentUser {
        id
        ...ShortProfile
      }
    }
  }
}
    ${ShortProfile}`;
export const ShortProfileFragmentDoc = gql`
    fragment ShortProfile on User {
  id
  isAdmin
  isVerified
  username
  avatarUrl
}
    `;
export const ShortRoomSubscriptionFragmentDoc = gql`
    fragment ShortRoomSubscription on RoomSubscription {
  id
  subscriberId
  subscriber {
    id
    ...ShortProfile
  }
  roomId
  room {
    id
    title
  }
  lastVisitAt
  notifications
  role
  createdAt
  updatedAt
}
    ${ShortProfileFragmentDoc}`;
export const RoomItemAttachmentAsLinkFragmentDoc = gql`
    fragment RoomItemAttachmentAsLink on RoomItemAttachment {
  id
  fileId
  file {
    id
    filename
    mimeType
    pdfFile {
      id
      pages
    }
  }
  topicId
  topic {
    id
    title
    slug
    contentPreview
    author {
      id
      ...ShortProfile
    }
  }
}
    ${ShortProfileFragmentDoc}`;
export const RoomItemAsListItemFragmentDoc = gql`
    fragment RoomItemAsListItem on RoomItem {
  id
  type
  children {
    totalCount
  }
  contributor {
    id
    ...ShortProfile
  }
  order
  parentId
  parent {
    id
    type
    createdAt
    contributedAt
    contributor {
      id
      ...ShortProfile
    }
  }
  room {
    id
    itemsAreVisibleFor
    itemsAreVisibleSince
    itemsAreVisibleSinceDate
  }
  topic {
    id
    title
    slug
    contentPreview
  }
  roomItemAttachments(orderBy: [CREATED_AT_ASC]) {
    nodes {
      id
      ...RoomItemAttachmentAsLink
    }
  }
  messageBody
  updatedAt
  contributedAt
  isVisibleFor
  isVisibleSince
  isVisibleSinceDate
  nthItemSinceLastVisit
}
    ${ShortProfileFragmentDoc}
${RoomItemAttachmentAsLinkFragmentDoc}`;
export const ChangePasswordDocument = gql`
    mutation ChangePassword($oldPassword: String!, $newPassword: String!) {
  changePassword(input: {oldPassword: $oldPassword, newPassword: $newPassword}) {
    success: boolean
  }
}
    `;

export function useChangePasswordMutation() {
  return Urql.useMutation<ChangePasswordMutation, ChangePasswordMutationVariables>(ChangePasswordDocument);
};
export const CreateRoomItemAttachmentDocument = gql`
    mutation CreateRoomItemAttachment($input: RoomItemAttachmentInput!) {
  createRoomItemAttachment(input: {roomItemAttachment: $input}) {
    roomItem {
      id
      room {
        id
      }
    }
    roomItemAttachment {
      id
      createdAt
    }
  }
}
    `;

export function useCreateRoomItemAttachmentMutation() {
  return Urql.useMutation<CreateRoomItemAttachmentMutation, CreateRoomItemAttachmentMutationVariables>(CreateRoomItemAttachmentDocument);
};
export const CreateRoomItemDocument = gql`
    mutation CreateRoomItem($item: RoomItemInput!) {
  createRoomItem(input: {roomItem: $item}) {
    roomItem {
      id
      createdAt
      contributor {
        id
        username
      }
    }
    room {
      id
      items {
        totalCount
      }
    }
  }
}
    `;

export function useCreateRoomItemMutation() {
  return Urql.useMutation<CreateRoomItemMutation, CreateRoomItemMutationVariables>(CreateRoomItemDocument);
};
export const CreateRoomMessageDocument = gql`
    mutation CreateRoomMessage($message: RoomMessageInput!) {
  createRoomMessage(input: {roomMessage: $message}) {
    roomMessage {
      id
      createdAt
      sender {
        id
        username
      }
      body
    }
    room {
      id
      latestMessage {
        id
      }
      messages {
        totalCount
      }
    }
  }
}
    `;

export function useCreateRoomMessageMutation() {
  return Urql.useMutation<CreateRoomMessageMutation, CreateRoomMessageMutationVariables>(CreateRoomMessageDocument);
};
export const CreateRoomSubscriptionDocument = gql`
    mutation CreateRoomSubscription($subscription: RoomSubscriptionInput!) {
  createRoomSubscription(input: {roomSubscription: $subscription}) {
    roomSubscription {
      id
      createdAt
    }
    room {
      id
      nSubscriptions
    }
  }
}
    `;

export function useCreateRoomSubscriptionMutation() {
  return Urql.useMutation<CreateRoomSubscriptionMutation, CreateRoomSubscriptionMutationVariables>(CreateRoomSubscriptionDocument);
};
export const CreateRoomDocument = gql`
    mutation CreateRoom($room: RoomInput!) {
  createRoom(input: {room: $room}) {
    room {
      id
    }
  }
}
    `;

export function useCreateRoomMutation() {
  return Urql.useMutation<CreateRoomMutation, CreateRoomMutationVariables>(CreateRoomDocument);
};
export const CreateTopicDocument = gql`
    mutation CreateTopic($topic: TopicInput!) {
  createTopic(input: {topic: $topic}) {
    topic {
      id
      slug
    }
  }
}
    `;

export function useCreateTopicMutation() {
  return Urql.useMutation<CreateTopicMutation, CreateTopicMutationVariables>(CreateTopicDocument);
};
export const CurrentUserDocument = gql`
    query CurrentUser {
  currentUser {
    id
    ...ShortProfile
  }
}
    ${ShortProfileFragmentDoc}`;

export function useCurrentUserQuery(options: Omit<Urql.UseQueryArgs<never, CurrentUserQueryVariables>, 'query'>) {
  return Urql.useQuery<CurrentUserQuery, CurrentUserQueryVariables>({ query: CurrentUserDocument, ...options });
};
export const DeleteRoomItemAttachmentDocument = gql`
    mutation DeleteRoomItemAttachment($id: UUID!) {
  deleteRoomItemAttachment(input: {id: $id}) {
    roomItem {
      id
    }
  }
}
    `;

export function useDeleteRoomItemAttachmentMutation() {
  return Urql.useMutation<DeleteRoomItemAttachmentMutation, DeleteRoomItemAttachmentMutationVariables>(DeleteRoomItemAttachmentDocument);
};
export const DeleteRoomItemDocument = gql`
    mutation DeleteRoomItem($id: UUID!) {
  deleteRoomItem(input: {id: $id}) {
    room {
      id
    }
  }
}
    `;

export function useDeleteRoomItemMutation() {
  return Urql.useMutation<DeleteRoomItemMutation, DeleteRoomItemMutationVariables>(DeleteRoomItemDocument);
};
export const DeleteRoomSubscriptionByRoomAndUserDocument = gql`
    mutation DeleteRoomSubscriptionByRoomAndUser($roomId: UUID!, $userId: UUID!) {
  deleteRoomSubscriptionBySubscriberIdAndRoomId(input: {roomId: $roomId, subscriberId: $userId}) {
    roomSubscription {
      id
    }
    room {
      id
    }
  }
}
    `;

export function useDeleteRoomSubscriptionByRoomAndUserMutation() {
  return Urql.useMutation<DeleteRoomSubscriptionByRoomAndUserMutation, DeleteRoomSubscriptionByRoomAndUserMutationVariables>(DeleteRoomSubscriptionByRoomAndUserDocument);
};
export const FetchDetailedTopicsDocument = gql`
    query FetchDetailedTopics($after: Cursor, $before: Cursor, $condition: TopicCondition, $filter: TopicFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [TopicsOrderBy!]) {
  topics(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    nodes {
      author {
        id
        username
      }
      slug
      tags
      id
      title
      license
      content
    }
  }
}
    `;

export function useFetchDetailedTopicsQuery(options: Omit<Urql.UseQueryArgs<never, FetchDetailedTopicsQueryVariables>, 'query'>) {
  return Urql.useQuery<FetchDetailedTopicsQuery, FetchDetailedTopicsQueryVariables>({ query: FetchDetailedTopicsDocument, ...options });
};
export const FetchRoomItemAttachmentsDocument = gql`
    query FetchRoomItemAttachments($after: Cursor, $before: Cursor, $condition: RoomItemAttachmentCondition, $filter: RoomItemAttachmentFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [RoomItemAttachmentsOrderBy!]) {
  roomItemAttachments(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    nodes {
      ...RoomItemAttachmentAsLink
    }
  }
}
    ${RoomItemAttachmentAsLinkFragmentDoc}`;

export function useFetchRoomItemAttachmentsQuery(options: Omit<Urql.UseQueryArgs<never, FetchRoomItemAttachmentsQueryVariables>, 'query'>) {
  return Urql.useQuery<FetchRoomItemAttachmentsQuery, FetchRoomItemAttachmentsQueryVariables>({ query: FetchRoomItemAttachmentsDocument, ...options });
};
export const FetchRoomItemsDocument = gql`
    query FetchRoomItems($after: Cursor, $before: Cursor, $condition: RoomItemCondition, $filter: RoomItemFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [RoomItemsOrderBy!]) {
  roomItems(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    nodes {
      id
      ...RoomItemAsListItem
    }
  }
}
    ${RoomItemAsListItemFragmentDoc}`;

export function useFetchRoomItemsQuery(options: Omit<Urql.UseQueryArgs<never, FetchRoomItemsQueryVariables>, 'query'>) {
  return Urql.useQuery<FetchRoomItemsQuery, FetchRoomItemsQueryVariables>({ query: FetchRoomItemsDocument, ...options });
};
export const FetchRoomMessagesDocument = gql`
    query FetchRoomMessages($after: Cursor, $before: Cursor, $condition: RoomMessageCondition, $filter: RoomMessageFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [RoomMessagesOrderBy!]) {
  roomMessages(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    nodes {
      body
      createdAt
      id
      room {
        id
        title
      }
      sender {
        id
        username
      }
      sentAt
      updatedAt
    }
  }
}
    `;

export function useFetchRoomMessagesQuery(options: Omit<Urql.UseQueryArgs<never, FetchRoomMessagesQueryVariables>, 'query'>) {
  return Urql.useQuery<FetchRoomMessagesQuery, FetchRoomMessagesQueryVariables>({ query: FetchRoomMessagesDocument, ...options });
};
export const FetchRoomSubscriptionsDocument = gql`
    query FetchRoomSubscriptions($after: Cursor, $before: Cursor, $condition: RoomSubscriptionCondition, $filter: RoomSubscriptionFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [RoomSubscriptionsOrderBy!]) {
  roomSubscriptions(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    nodes {
      id
      ...ShortRoomSubscription
    }
  }
}
    ${ShortRoomSubscriptionFragmentDoc}`;

export function useFetchRoomSubscriptionsQuery(options: Omit<Urql.UseQueryArgs<never, FetchRoomSubscriptionsQueryVariables>, 'query'>) {
  return Urql.useQuery<FetchRoomSubscriptionsQuery, FetchRoomSubscriptionsQueryVariables>({ query: FetchRoomSubscriptionsDocument, ...options });
};
export const FetchRoomsDocument = gql`
    query FetchRooms($after: Cursor, $before: Cursor, $condition: RoomCondition, $filter: RoomFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [RoomsOrderBy!]) {
  rooms(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    nodes {
      id
      title
      abstract
      createdAt
      latestItem {
        id
        contributedAt
        contributor {
          id
          ...ShortProfile
        }
        nthItemSinceLastVisit
      }
      mySubscription {
        id
        ...ShortRoomSubscription
      }
      nSubscriptions
      hasSubscriptions
      nItems
      nItemsSinceLastVisit
      isVisibleFor
      itemsAreVisibleFor
      draftItemsAreVisibleFor
    }
  }
}
    ${ShortProfileFragmentDoc}
${ShortRoomSubscriptionFragmentDoc}`;

export function useFetchRoomsQuery(options: Omit<Urql.UseQueryArgs<never, FetchRoomsQueryVariables>, 'query'>) {
  return Urql.useQuery<FetchRoomsQuery, FetchRoomsQueryVariables>({ query: FetchRoomsDocument, ...options });
};
export const FetchTopicsDocument = gql`
    query FetchTopics($after: Cursor, $before: Cursor, $condition: TopicCondition, $filter: TopicFilter, $first: Int, $last: Int, $offset: Int, $orderBy: [TopicsOrderBy!]) {
  topics(after: $after, before: $before, condition: $condition, filter: $filter, first: $first, last: $last, offset: $offset, orderBy: $orderBy) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    nodes {
      organization {
        id
        slug
      }
      author {
        id
        username
      }
      slug
      tags
      id
      title
      license
    }
  }
}
    `;

export function useFetchTopicsQuery(options: Omit<Urql.UseQueryArgs<never, FetchTopicsQueryVariables>, 'query'>) {
  return Urql.useQuery<FetchTopicsQuery, FetchTopicsQueryVariables>({ query: FetchTopicsDocument, ...options });
};
export const GetCurrentUserDocument = gql`
    query GetCurrentUser {
  currentUser {
    id
    ...ShortProfile
    userEmails {
      nodes {
        id
        isPrimary
        email
      }
    }
  }
}
    ${ShortProfileFragmentDoc}`;

export function useGetCurrentUserQuery(options: Omit<Urql.UseQueryArgs<never, GetCurrentUserQueryVariables>, 'query'>) {
  return Urql.useQuery<GetCurrentUserQuery, GetCurrentUserQueryVariables>({ query: GetCurrentUserDocument, ...options });
};
export const GetRoomMessageDocument = gql`
    query GetRoomMessage($id: UUID!) {
  roomMessage(id: $id) {
    id
    body
    sender {
      id
      username
    }
  }
}
    `;

export function useGetRoomMessageQuery(options: Omit<Urql.UseQueryArgs<never, GetRoomMessageQueryVariables>, 'query'>) {
  return Urql.useQuery<GetRoomMessageQuery, GetRoomMessageQueryVariables>({ query: GetRoomMessageDocument, ...options });
};
export const GetRoomSubscriptionOfUserInRoomDocument = gql`
    query GetRoomSubscriptionOfUserInRoom($userId: UUID!, $roomId: UUID!) {
  roomSubscriptionBySubscriberIdAndRoomId(roomId: $roomId, subscriberId: $userId) {
    id
    ...ShortRoomSubscription
  }
}
    ${ShortRoomSubscriptionFragmentDoc}`;

export function useGetRoomSubscriptionOfUserInRoomQuery(options: Omit<Urql.UseQueryArgs<never, GetRoomSubscriptionOfUserInRoomQueryVariables>, 'query'>) {
  return Urql.useQuery<GetRoomSubscriptionOfUserInRoomQuery, GetRoomSubscriptionOfUserInRoomQueryVariables>({ query: GetRoomSubscriptionOfUserInRoomDocument, ...options });
};
export const GetRoomDocument = gql`
    query GetRoom($id: UUID!) {
  room(id: $id) {
    id
    title
    abstract
    hasSubscriptions
    nSubscriptions
    isVisibleFor
    itemsAreVisibleFor
    mySubscription {
      id
      ...ShortRoomSubscription
    }
    latestItem {
      id
      contributedAt
      contributor {
        id
        ...ShortProfile
      }
      nthItemSinceLastVisit
    }
  }
}
    ${ShortRoomSubscriptionFragmentDoc}
${ShortProfileFragmentDoc}`;

export function useGetRoomQuery(options: Omit<Urql.UseQueryArgs<never, GetRoomQueryVariables>, 'query'>) {
  return Urql.useQuery<GetRoomQuery, GetRoomQueryVariables>({ query: GetRoomDocument, ...options });
};
export const GetTopicBySlugDocument = gql`
    query GetTopicBySlug($slug: String!, $organizationId: UUID!) {
  topicBySlugAndOrganizationId(organizationId: $organizationId, slug: $slug) {
    id
    title
    tags
    slug
    content
  }
}
    `;

export function useGetTopicBySlugQuery(options: Omit<Urql.UseQueryArgs<never, GetTopicBySlugQueryVariables>, 'query'>) {
  return Urql.useQuery<GetTopicBySlugQuery, GetTopicBySlugQueryVariables>({ query: GetTopicBySlugDocument, ...options });
};
export const GetTopicDocument = gql`
    query GetTopic($id: UUID!) {
  topic(id: $id) {
    id
    title
    tags
    slug
    content
  }
}
    `;

export function useGetTopicQuery(options: Omit<Urql.UseQueryArgs<never, GetTopicQueryVariables>, 'query'>) {
  return Urql.useQuery<GetTopicQuery, GetTopicQueryVariables>({ query: GetTopicDocument, ...options });
};
export const GetUserByUsernameDocument = gql`
    query GetUserByUsername($username: String!) {
  userByUsername(username: $username) {
    id
    username
  }
}
    `;

export function useGetUserByUsernameQuery(options: Omit<Urql.UseQueryArgs<never, GetUserByUsernameQueryVariables>, 'query'>) {
  return Urql.useQuery<GetUserByUsernameQuery, GetUserByUsernameQueryVariables>({ query: GetUserByUsernameDocument, ...options });
};
export const GlobalSearchDocument = gql`
    query GlobalSearch($term: String!, $entities: [TextsearchableEntity!] = [TOPIC, USER], $filter: TextsearchMatchFilter, $first: Int, $last: Int, $after: Cursor, $before: Cursor, $condition: TextsearchMatchCondition) {
  globalSearch(term: $term, entities: $entities, filter: $filter, first: $first, last: $last, after: $after, before: $before, condition: $condition) {
    totalCount
    nodes {
      id
      rankOrSimilarity
      snippet
      title
      type
    }
  }
}
    `;

export function useGlobalSearchQuery(options: Omit<Urql.UseQueryArgs<never, GlobalSearchQueryVariables>, 'query'>) {
  return Urql.useQuery<GlobalSearchQuery, GlobalSearchQueryVariables>({ query: GlobalSearchDocument, ...options });
};
export const LoginDocument = gql`
    mutation Login($username: String!, $password: String!) {
  login(input: {username: $username, password: $password}) {
    user {
      id
      username
    }
  }
}
    `;

export function useLoginMutation() {
  return Urql.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument);
};
export const LogoutDocument = gql`
    mutation Logout {
  logout {
    success
  }
}
    `;

export function useLogoutMutation() {
  return Urql.useMutation<LogoutMutation, LogoutMutationVariables>(LogoutDocument);
};
export const RegisterUserDocument = gql`
    mutation RegisterUser($form: RegisterInput!) {
  register(input: $form) {
    user {
      id
      username
      createdAt
    }
  }
}
    `;

export function useRegisterUserMutation() {
  return Urql.useMutation<RegisterUserMutation, RegisterUserMutationVariables>(RegisterUserDocument);
};
export const ForgotPasswordDocument = gql`
    mutation ForgotPassword($email: String!) {
  forgotPassword(input: {email: $email}) {
    clientMutationId
  }
}
    `;

export function useForgotPasswordMutation() {
  return Urql.useMutation<ForgotPasswordMutation, ForgotPasswordMutationVariables>(ForgotPasswordDocument);
};
export const ResetPasswordDocument = gql`
    mutation ResetPassword($id: UUID!, $token: String!, $newPassword: String!) {
  resetPassword(input: {userId: $id, resetToken: $token, newPassword: $newPassword}) {
    success
  }
}
    `;

export function useResetPasswordMutation() {
  return Urql.useMutation<ResetPasswordMutation, ResetPasswordMutationVariables>(ResetPasswordDocument);
};
export const UpdateRoomItemDocument = gql`
    mutation UpdateRoomItem($oldId: UUID!, $patch: RoomItemPatch!) {
  updateRoomItem(input: {patch: $patch, id: $oldId}) {
    roomItem {
      id
      updatedAt
      parent {
        id
      }
    }
  }
}
    `;

export function useUpdateRoomItemMutation() {
  return Urql.useMutation<UpdateRoomItemMutation, UpdateRoomItemMutationVariables>(UpdateRoomItemDocument);
};
export const UpdateRoomMessageDocument = gql`
    mutation UpdateRoomMessage($oldId: UUID!, $patch: RoomMessagePatch!) {
  updateRoomMessage(input: {patch: $patch, id: $oldId}) {
    roomMessage {
      id
      updatedAt
      answeredMessage {
        id
      }
    }
  }
}
    `;

export function useUpdateRoomMessageMutation() {
  return Urql.useMutation<UpdateRoomMessageMutation, UpdateRoomMessageMutationVariables>(UpdateRoomMessageDocument);
};
export const UpdateRoomSubscriptionDocument = gql`
    mutation UpdateRoomSubscription($oldId: UUID!, $patch: RoomSubscriptionPatch!) {
  updateRoomSubscription(input: {patch: $patch, id: $oldId}) {
    roomSubscription {
      id
      ...ShortRoomSubscription
    }
  }
}
    ${ShortRoomSubscriptionFragmentDoc}`;

export function useUpdateRoomSubscriptionMutation() {
  return Urql.useMutation<UpdateRoomSubscriptionMutation, UpdateRoomSubscriptionMutationVariables>(UpdateRoomSubscriptionDocument);
};
export const UpdateRoomDocument = gql`
    mutation UpdateRoom($oldId: UUID!, $patch: RoomPatch!) {
  updateRoom(input: {patch: $patch, id: $oldId}) {
    room {
      id
      updatedAt
    }
  }
}
    `;

export function useUpdateRoomMutation() {
  return Urql.useMutation<UpdateRoomMutation, UpdateRoomMutationVariables>(UpdateRoomDocument);
};
export const UpdateTopicDocument = gql`
    mutation UpdateTopic($oldId: UUID!, $patch: TopicPatch!) {
  updateTopic(input: {patch: $patch, id: $oldId}) {
    topic {
      id
      slug
      updatedAt
    }
  }
}
    `;

export function useUpdateTopicMutation() {
  return Urql.useMutation<UpdateTopicMutation, UpdateTopicMutationVariables>(UpdateTopicDocument);
};
export const VerifyEmailDocument = gql`
    mutation VerifyEmail($id: UUID!, $token: String!) {
  verifyEmail(input: {userEmailId: $id, token: $token}) {
    success: boolean
    query {
      currentUser {
        id
        ...ShortProfile
      }
    }
  }
}
    ${ShortProfileFragmentDoc}`;

export function useVerifyEmailMutation() {
  return Urql.useMutation<VerifyEmailMutation, VerifyEmailMutationVariables>(VerifyEmailDocument);
};